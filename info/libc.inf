This is Info file ../../info/libc.inf, produced by Makeinfo-1.63 from
the input file libc.tex.

This is the reference manual for libc.a

Copyright (c) 1996 DJ Delorie


File: libc,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

* Menu:

* Introduction::

* Functional Categories::  All public symbols listed by
                           category

* Alphabetical List::      All public symbols in alphabetical
                           order

* Index::


File: libc,  Node: Introduction,  Next: Functional Categories,  Prev: Top,  Up: Top

Introduction
************

The standard C library, `libc.a', is automatically linked into your
programs by the `gcc' control program.  It provides many of the
functions that are normally associated with C programs.  This document
gives the proper usage information about each of the functions and
variables found in `libc.a'.

For each function or variable that the library provides, the definition
of that symbol will include information on which header files to include
in your source to obtain prototypes and type definitions relevent to the
use of that symbol.

Note that many of the functions in `libm.a' (the math library) are
defined in `math.h' but are not present in libc.a.  Some are, which may
get confusing, but the rule of thumb is this - the C library contains
those functions that ANSI dictates must exist, so that you don't need
the `-lm' if you only use ANSI functions.  These functions are,
however, vastly simplified compared to the ANSI spec and the functions
in `libm.a', which includes replacements.  For example, `libc.a''s
`ldexp()' doesn't set `errno' on error, but `libm.a''s `ldexp()' does.


File: libc,  Node: Functional Categories,  Next: Alphabetical List,  Prev: Introduction,  Up: Top

Functional Categories
*********************

* Menu:

* bios functions::
* conio functions::
* cpu functions::
* ctype functions::
* dos functions::
* dpmi functions::
* environment functions::
* file system functions::
* go32 functions::
* io functions::
* locale functions::
* math functions::
* memory functions::
* misc functions::
* mono functions::
* posix functions::
* process functions::
* random number functions::
* shell functions::
* signal functions::
* sound functions::
* startup functions::
* stdio functions::
* stdlib functions::
* string functions::
* time functions::
* unix functions::


File: libc,  Node: bios functions,  Next: conio functions,  Up: Functional Categories

bios functions
==============

* Menu:

* _bios_disk::
* _bios_equiplist::
* _bios_keybrd::
* _bios_memsize::
* _bios_printer::
* _bios_serialcom::
* _bios_timeofday::
* bioscom::
* biosdisk::
* biosequip::
* bioskey::
* biosmemory::
* biosprint::
* biostime::
* getkey::
* getxkey::
* kbhit::


File: libc,  Node: conio functions,  Next: cpu functions,  Prev: bios functions,  Up: Functional Categories

conio functions
===============

* Menu:

* cgets::
* clreol::
* clrscr::
* _conio_kbhit::
* cprintf::
* cputs::
* cscanf::
* delline::
* getch::
* getche::
* gettext::
* gettextinfo::
* gotoxy::
* gppconio_init::
* highvideo::
* insline::
* lowvideo::
* movetext::
* normvideo::
* putch::
* puttext::
* Screen Variables::
* ScreenClear::
* ScreenCols::
* ScreenGetCursor::
* ScreenMode::
* ScreenPutChar::
* ScreenPutString::
* ScreenRetrieve::
* ScreenRows::
* ScreenSetCursor::
* ScreenUpdate::
* ScreenUpdateLine::
* ScreenVisualBell::
* _set_screen_lines::
* _setcursortype::
* textattr::
* textbackground::
* textcolor::
* textmode::
* ungetch::
* wherex::
* wherey::
* window::


File: libc,  Node: cpu functions,  Next: ctype functions,  Prev: conio functions,  Up: Functional Categories

cpu functions
=============

* Menu:

* _clear87::
* _control87::
* disable::
* enable::
* _fpreset::
* htonl::
* htons::
* inb::
* inp::
* inportb::
* inportl::
* inportsb::
* inportsl::
* inportsw::
* inportw::
* inpw::
* _my_cs::
* _my_ds::
* _my_ss::
* ntohl::
* ntohs::
* outb::
* outp::
* outportb::
* outportl::
* outportsb::
* outportsl::
* outportsw::
* outportw::
* outpw::
* _status87::


File: libc,  Node: ctype functions,  Next: dos functions,  Prev: cpu functions,  Up: Functional Categories

ctype functions
===============

* Menu:

* isalnum::
* isalpha::
* isascii::
* iscntrl::
* isdigit::
* isgraph::
* islower::
* isprint::
* ispunct::
* isspace::
* isupper::
* isxdigit::
* toascii::
* tolower::
* toupper::


File: libc,  Node: dos functions,  Next: dpmi functions,  Prev: ctype functions,  Up: Functional Categories

dos functions
=============

* Menu:

* bdos::
* bdosptr::
* delay::
* _dos_close::
* _dos_commit::
* _dos_creat::
* _dos_creatnew::
* _dos_findfirst::
* _dos_findnext::
* _dos_getdate::
* _dos_getdiskfree::
* _dos_getdrive::
* _dos_getfileattr::
* _dos_getftime::
* _dos_gettime::
* _dos_lock::
* _dos_open::
* _dos_read::
* _dos_setdate::
* _dos_setdrive::
* _dos_setfileattr::
* _dos_setftime::
* _dos_settime::
* _dos_unlock::
* _dos_write::
* dosexterr::
* getcbrk::
* getdisk::
* int386::
* int386x::
* int86::
* int86x::
* intdos::
* intdosx::
* setcbrk::
* setdisk::


File: libc,  Node: dpmi functions,  Next: environment functions,  Prev: dos functions,  Up: Functional Categories

dpmi functions
==============

* Menu:

* DPMI Overview::
* DPMI Specification::
* __dpmi_allocate_dos_memory::
* __dpmi_allocate_ldt_descriptors::
* __dpmi_allocate_linear_memory::
* __dpmi_allocate_memory::
* __dpmi_allocate_real_mode_callback::
* __dpmi_allocate_shared_memory::
* __dpmi_allocate_specific_ldt_descriptor::
* __dpmi_clear_debug_watchpoint::
* __dpmi_create_alias_descriptor::
* __dpmi_discard_page_contents::
* __dpmi_free_dos_memory::
* __dpmi_free_ldt_descriptor::
* __dpmi_free_memory::
* __dpmi_free_physical_address_mapping::
* __dpmi_free_real_mode_callback::
* __dpmi_free_serialization_on_shared_memory::
* __dpmi_free_shared_memory::
* __dpmi_get_and_disable_virtual_interrupt_state::
* __dpmi_get_and_enable_virtual_interrupt_state::
* __dpmi_get_and_set_virtual_interrupt_state::
* __dpmi_get_capabilities::
* __dpmi_get_coprocessor_status::
* __dpmi_get_descriptor::
* __dpmi_get_descriptor_access_rights::
* __dpmi_get_extended_exception_handler_vector_pm::
* __dpmi_get_extended_exception_handler_vector_rm::
* __dpmi_get_free_memory_information::
* __dpmi_get_memory_block_size_and_base::
* __dpmi_get_memory_information::
* __dpmi_get_multiple_descriptors::
* __dpmi_get_page_attributes::
* __dpmi_get_page_size::
* __dpmi_get_processor_exception_handler_vector::
* __dpmi_get_protected_mode_interrupt_vector::
* __dpmi_get_raw_mode_switch_addr::
* __dpmi_get_real_mode_interrupt_vector::
* __dpmi_get_segment_base_address::
* __dpmi_get_segment_limit::
* __dpmi_get_selector_increment_value::
* __dpmi_get_state_of_debug_watchpoint::
* __dpmi_get_state_save_restore_addr::
* __dpmi_get_vendor_specific_api_entry_point::
* __dpmi_get_version::
* __dpmi_get_virtual_interrupt_state::
* __dpmi_install_resident_service_provider_callback::
* __dpmi_int::
* __dpmi_lock_linear_region::
* __dpmi_map_conventional_memory_in_memory_block::
* __dpmi_map_device_in_memory_block::
* __dpmi_mark_page_as_demand_paging_candidate::
* __dpmi_mark_real_mode_region_as_pageable::
* __dpmi_physical_address_mapping::
* __dpmi_relock_real_mode_region::
* __dpmi_reset_debug_watchpoint::
* __dpmi_resize_dos_memory::
* __dpmi_resize_linear_memory::
* __dpmi_resize_memory::
* __dpmi_segment_to_descriptor::
* __dpmi_serialize_on_shared_memory::
* __dpmi_set_coprocessor_emulation::
* __dpmi_set_debug_watchpoint::
* __dpmi_set_descriptor::
* __dpmi_set_descriptor_access_rights::
* __dpmi_set_extended_exception_handler_vector_pm::
* __dpmi_set_extended_exception_handler_vector_rm::
* __dpmi_set_multiple_descriptors::
* __dpmi_set_page_attributes::
* __dpmi_set_processor_exception_handler_vector::
* __dpmi_set_protected_mode_interrupt_vector::
* __dpmi_set_real_mode_interrupt_vector::
* __dpmi_set_segment_base_address::
* __dpmi_set_segment_limit::
* __dpmi_simulate_real_mode_interrupt::
* __dpmi_simulate_real_mode_procedure_iret::
* __dpmi_simulate_real_mode_procedure_retf::
* __dpmi_simulate_real_mode_procedure_retf_stack::
* __dpmi_terminate_and_stay_resident::
* __dpmi_unlock_linear_region::
* __dpmi_yield::
* _go32_dpmi_allocate_dos_memory::
* _go32_dpmi_allocate_iret_wrapper::
* _go32_dpmi_allocate_real_mode_callback_iret::
* _go32_dpmi_allocate_real_mode_callback_retf::
* _go32_dpmi_chain_protected_mode_interrupt_vector::
* _go32_dpmi_free_dos_memory::
* _go32_dpmi_free_iret_wrapper::
* _go32_dpmi_free_real_mode_callback::
* _go32_dpmi_get_free_memory_information::
* _go32_dpmi_get_protected_mode_interrupt_vector::
* _go32_dpmi_get_real_mode_interrupt_vector::
* _go32_dpmi_remaining_physical_memory::
* _go32_dpmi_remaining_virtual_memory::
* _go32_dpmi_resize_dos_memory::
* _go32_dpmi_set_protected_mode_interrupt_vector::
* _go32_dpmi_set_real_mode_interrupt_vector::
* _go32_dpmi_simulate_fcall::
* _go32_dpmi_simulate_fcall_iret::
* _go32_dpmi_simulate_int::
* _go32_info_block::


File: libc,  Node: environment functions,  Next: file system functions,  Prev: dpmi functions,  Up: Functional Categories

environment functions
=====================

* Menu:

* getenv::
* putenv::


File: libc,  Node: file system functions,  Next: go32 functions,  Prev: environment functions,  Up: Functional Categories

file system functions
=====================

* Menu:

* access::
* chdir::
* chmod::
* _chmod::
* _close::
* closedir::
* _creat::
* File System Extensions::
* file_tree_walk::
* findfirst::
* findnext::
* _fixpath::
* fnmatch::
* fnmerge::
* fnsplit::
* fpathconf::
* __FSEXT_add_open_handler::
* __FSEXT_alloc_fd::
* __FSEXT_call_open_handlers::
* __FSEXT_get_function::
* __FSEXT_set_function::
* ftw::
* getcwd::
* getdfree::
* getftime::
* getwd::
* mkdir::
* mkstemp::
* mktemp::
* _open::
* opendir::
* _read::
* readdir::
* remove::
* rename::
* rewinddir::
* rmdir::
* searchpath::
* seekdir::
* setftime::
* statfs::
* telldir::
* umask::
* unlink::
* _use_lfn::
* utime::
* _write::


File: libc,  Node: go32 functions,  Next: io functions,  Prev: file system functions,  Up: Functional Categories

go32 functions
==============

* Menu:

* _go32_conventional_mem_selector::
* _go32_dpmi_lock_code::
* _go32_dpmi_lock_data::
* _go32_interrupt_stack_size::
* _go32_my_cs::
* _go32_my_ds::
* _go32_my_ss::
* _go32_rmcb_stack_size::
* _go32_want_ctrl_break::
* _go32_was_ctrl_break_hit::


File: libc,  Node: io functions,  Next: locale functions,  Prev: go32 functions,  Up: Functional Categories

io functions
============

* Menu:

* chsize::
* close::
* creat::
* crlf2nl::
* dup::
* dup2::
* fcntl::
* __file_exists::
* filelength::
* _get_dev_info::
* _is_executable::
* link::
* lock::
* lseek::
* open::
* read::
* setmode::
* stat::
* tell::
* truncate::
* unlock::
* write::


File: libc,  Node: locale functions,  Next: math functions,  Prev: io functions,  Up: Functional Categories

locale functions
================

* Menu:

* localeconv::
* mblen::
* mbstowcs::
* mbtowc::
* setlocale::
* strcoll::
* strxfrm::
* wcstombs::
* wctomb::


File: libc,  Node: math functions,  Next: memory functions,  Prev: locale functions,  Up: Functional Categories

math functions
==============

* Menu:

* abs::
* acos::
* acosh::
* asin::
* asinh::
* atan::
* atan2::
* atanh::
* ceil::
* cos::
* cosh::
* div::
* exp::
* fabs::
* floor::
* fmod::
* frexp::
* hypot::
* ldexp::
* ldiv::
* log::
* log10::
* log2::
* modf::
* modfl::
* pow::
* pow10::
* pow2::
* sin::
* sinh::
* sqrt::
* tan::
* tanh::


File: libc,  Node: memory functions,  Next: misc functions,  Prev: math functions,  Up: Functional Categories

memory functions
================

* Menu:

* alloca::
* bcmp::
* bcopy::
* brk::
* bzero::
* calloc::
* cfree::
* __djgpp_map_physical_memory::
* __djgpp_memory_handle::
* __djgpp_memory_handle_list::
* __djgpp_nearptr_disable::
* __djgpp_nearptr_enable::
* __djgpp_set_page_attributes::
* dosmemget::
* dosmemgetb::
* dosmemgetl::
* dosmemgetw::
* dosmemput::
* dosmemputb::
* dosmemputl::
* dosmemputw::
* _far*::
* free::
* malloc::
* memccpy::
* memchr::
* memcmp::
* memcpy::
* memmove::
* memset::
* movedata::
* movedatab::
* movedatal::
* movedataw::
* mprotect::
* realloc::
* sbrk::
* swab::
* xfree::
* xmalloc::
* xrealloc::


File: libc,  Node: misc functions,  Next: mono functions,  Prev: memory functions,  Up: Functional Categories

misc functions
==============

* Menu:

* assert::
* bsearch::
* _dxe_load::
* _get_dos_version::
* gethostname::
* getlongpass::
* getpagesize::
* getpass::
* insque::
* labs::
* longjmp::
* qsort::
* remque::
* setjmp::
* siglongjmp::
* sigsetjmp::


File: libc,  Node: mono functions,  Next: posix functions,  Prev: misc functions,  Up: Functional Categories

mono functions
==============

* Menu:

* _mono_clear::
* _mono_printf::
* _mono_putc::


File: libc,  Node: posix functions,  Next: process functions,  Prev: mono functions,  Up: Functional Categories

posix functions
===============

* Menu:

* getdtablesize::
* pathconf::
* sysconf::


File: libc,  Node: process functions,  Next: random number functions,  Prev: posix functions,  Up: Functional Categories

process functions
=================

* Menu:

* abort::
* alarm::
* atexit::
* exec*::
* _exit::
* exit::
* getitimer::
* kill::
* nice::
* pause::
* setitimer::
* sleep::
* spawn*::
* system::
* usleep::
* wait::
* waitpid::


File: libc,  Node: random number functions,  Next: shell functions,  Prev: process functions,  Up: Functional Categories

random number functions
=======================

* Menu:

* rand::
* random::
* srandom::


File: libc,  Node: shell functions,  Next: signal functions,  Prev: random number functions,  Up: Functional Categories

shell functions
===============

* Menu:

* glob::
* globfree::


File: libc,  Node: signal functions,  Next: sound functions,  Prev: shell functions,  Up: Functional Categories

signal functions
================

* Menu:

* raise::
* signal::


File: libc,  Node: sound functions,  Next: startup functions,  Prev: signal functions,  Up: Functional Categories

sound functions
===============

* Menu:

* nosound::
* sound::


File: libc,  Node: startup functions,  Next: stdio functions,  Prev: sound functions,  Up: Functional Categories

startup functions
=================

* Menu:

* __crt0_glob_function::
* __crt0_load_environment_file::
* __crt0_setup_arguments::
* _crt0_startup_flags::
* _stklen::


File: libc,  Node: stdio functions,  Next: stdlib functions,  Prev: startup functions,  Up: Functional Categories

stdio functions
===============

* Menu:

* clearerr::
* _djstat_describe_lossage::
* _djstat_fail_bits::
* _djstat_flags::
* _doprnt::
* _doscan::
* errno::
* fclose::
* fdopen::
* feof::
* ferror::
* fflush::
* fgetc::
* fgetpos::
* fgets::
* fileno::
* _fmode::
* fopen::
* fprintf::
* fpurge::
* fputc::
* fputs::
* fread::
* freopen::
* fscanf::
* fseek::
* fsetpos::
* fstat::
* fsync::
* ftell::
* ftruncate::
* _fwalk::
* fwrite::
* getc::
* getchar::
* gets::
* getw::
* perror::
* printf::
* putc::
* putchar::
* puts::
* putw::
* rewind::
* scanf::
* setbuf::
* setbuffer::
* setlinebuf::
* setvbuf::
* sprintf::
* sscanf::
* strerror::
* sys_errlist::
* sys_nerr::
* tmpfile::
* tmpnam::
* _truename::
* ungetc::
* vfprintf::
* vprintf::
* vsprintf::


File: libc,  Node: stdlib functions,  Next: string functions,  Prev: stdio functions,  Up: Functional Categories

stdlib functions
================

* Menu:

* setenv::


File: libc,  Node: string functions,  Next: time functions,  Prev: stdlib functions,  Up: Functional Categories

string functions
================

* Menu:

* atof::
* atoi::
* atol::
* _atold::
* ffs::
* index::
* itoa::
* rindex::
* stpcpy::
* strcase::
* strcasecmp::
* strcat::
* strchr::
* strcmp::
* strcpy::
* strcspn::
* strdup::
* stricmp::
* strlen::
* strlwr::
* strncase::
* strncasecmp::
* strncat::
* strncmp::
* strncpy::
* strnicmp::
* strpbrk::
* strrchr::
* strsep::
* strspn::
* strstr::
* strtod::
* strtok::
* strtol::
* _strtold::
* strtoul::
* strupr::


File: libc,  Node: time functions,  Next: unix functions,  Prev: string functions,  Up: Functional Categories

time functions
==============

* Menu:

* asctime::
* clock::
* ctime::
* difftime::
* ftime::
* getdate::
* gettime::
* gettimeofday::
* gmtime::
* localtime::
* mktime::
* rawclock::
* setdate::
* settime::
* settimeofday::
* strftime::
* time::
* times::
* uclock::
* utimes::


File: libc,  Node: unix functions,  Prev: time functions,  Up: Functional Categories

unix functions
==============

* Menu:

* addmntent::
* chown::
* endgrent::
* endmntent::
* endpwent::
* fgetgrent::
* fork::
* getegid::
* geteuid::
* getgid::
* getgrent::
* getgrgid::
* getgrnam::
* getlogin::
* getmntent::
* getpgrp::
* getpid::
* getpwent::
* getpwnam::
* getpwuid::
* getrusage::
* getuid::
* hasmntopt::
* isatty::
* mkfifo::
* mknod::
* pclose::
* pipe::
* popen::
* select::
* setgrent::
* setmntent::
* setpgid::
* setpwent::
* sync::
* ttyname::
* uname::


File: libc,  Node: Alphabetical List,  Prev: Functional Categories,  Up: Top

Alphabetical List
*****************

* Menu:

* abort::
* abs::
* access::
* acos::
* acosh::
* addmntent::
* alarm::
* alloca::
* asctime::
* asin::
* asinh::
* assert::
* atan::
* atan2::
* atanh::
* atexit::
* atof::
* atoi::
* atol::
* _atold::
* bcmp::
* bcopy::
* bdos::
* bdosptr::
* _bios_disk::
* _bios_equiplist::
* _bios_keybrd::
* _bios_memsize::
* _bios_printer::
* _bios_serialcom::
* _bios_timeofday::
* bioscom::
* biosdisk::
* biosequip::
* bioskey::
* biosmemory::
* biosprint::
* biostime::
* brk::
* bsearch::
* bzero::
* calloc::
* ceil::
* cfree::
* cgets::
* chdir::
* chmod::
* _chmod::
* chown::
* chsize::
* _clear87::
* clearerr::
* clock::
* close::
* _close::
* closedir::
* clreol::
* clrscr::
* _conio_kbhit::
* _control87::
* cos::
* cosh::
* cprintf::
* cputs::
* creat::
* _creat::
* crlf2nl::
* __crt0_glob_function::
* __crt0_load_environment_file::
* __crt0_setup_arguments::
* _crt0_startup_flags::
* cscanf::
* ctime::
* delay::
* delline::
* difftime::
* disable::
* div::
* __djgpp_map_physical_memory::
* __djgpp_memory_handle::
* __djgpp_memory_handle_list::
* __djgpp_nearptr_disable::
* __djgpp_nearptr_enable::
* __djgpp_set_page_attributes::
* _djstat_describe_lossage::
* _djstat_fail_bits::
* _djstat_flags::
* _doprnt::
* _dos_close::
* _dos_commit::
* _dos_creat::
* _dos_creatnew::
* _dos_findfirst::
* _dos_findnext::
* _dos_getdate::
* _dos_getdiskfree::
* _dos_getdrive::
* _dos_getfileattr::
* _dos_getftime::
* _dos_gettime::
* _dos_lock::
* _dos_open::
* _dos_read::
* _dos_setdate::
* _dos_setdrive::
* _dos_setfileattr::
* _dos_setftime::
* _dos_settime::
* _dos_unlock::
* _dos_write::
* _doscan::
* dosexterr::
* dosmemget::
* dosmemgetb::
* dosmemgetl::
* dosmemgetw::
* dosmemput::
* dosmemputb::
* dosmemputl::
* dosmemputw::
* DPMI Overview::
* DPMI Specification::
* __dpmi_allocate_dos_memory::
* __dpmi_allocate_ldt_descriptors::
* __dpmi_allocate_linear_memory::
* __dpmi_allocate_memory::
* __dpmi_allocate_real_mode_callback::
* __dpmi_allocate_shared_memory::
* __dpmi_allocate_specific_ldt_descriptor::
* __dpmi_clear_debug_watchpoint::
* __dpmi_create_alias_descriptor::
* __dpmi_discard_page_contents::
* __dpmi_free_dos_memory::
* __dpmi_free_ldt_descriptor::
* __dpmi_free_memory::
* __dpmi_free_physical_address_mapping::
* __dpmi_free_real_mode_callback::
* __dpmi_free_serialization_on_shared_memory::
* __dpmi_free_shared_memory::
* __dpmi_get_and_disable_virtual_interrupt_state::
* __dpmi_get_and_enable_virtual_interrupt_state::
* __dpmi_get_and_set_virtual_interrupt_state::
* __dpmi_get_capabilities::
* __dpmi_get_coprocessor_status::
* __dpmi_get_descriptor::
* __dpmi_get_descriptor_access_rights::
* __dpmi_get_extended_exception_handler_vector_pm::
* __dpmi_get_extended_exception_handler_vector_rm::
* __dpmi_get_free_memory_information::
* __dpmi_get_memory_block_size_and_base::
* __dpmi_get_memory_information::
* __dpmi_get_multiple_descriptors::
* __dpmi_get_page_attributes::
* __dpmi_get_page_size::
* __dpmi_get_processor_exception_handler_vector::
* __dpmi_get_protected_mode_interrupt_vector::
* __dpmi_get_raw_mode_switch_addr::
* __dpmi_get_real_mode_interrupt_vector::
* __dpmi_get_segment_base_address::
* __dpmi_get_segment_limit::
* __dpmi_get_selector_increment_value::
* __dpmi_get_state_of_debug_watchpoint::
* __dpmi_get_state_save_restore_addr::
* __dpmi_get_vendor_specific_api_entry_point::
* __dpmi_get_version::
* __dpmi_get_virtual_interrupt_state::
* __dpmi_install_resident_service_provider_callback::
* __dpmi_int::
* __dpmi_lock_linear_region::
* __dpmi_map_conventional_memory_in_memory_block::
* __dpmi_map_device_in_memory_block::
* __dpmi_mark_page_as_demand_paging_candidate::
* __dpmi_mark_real_mode_region_as_pageable::
* __dpmi_physical_address_mapping::
* __dpmi_relock_real_mode_region::
* __dpmi_reset_debug_watchpoint::
* __dpmi_resize_dos_memory::
* __dpmi_resize_linear_memory::
* __dpmi_resize_memory::
* __dpmi_segment_to_descriptor::
* __dpmi_serialize_on_shared_memory::
* __dpmi_set_coprocessor_emulation::
* __dpmi_set_debug_watchpoint::
* __dpmi_set_descriptor::
* __dpmi_set_descriptor_access_rights::
* __dpmi_set_extended_exception_handler_vector_pm::
* __dpmi_set_extended_exception_handler_vector_rm::
* __dpmi_set_multiple_descriptors::
* __dpmi_set_page_attributes::
* __dpmi_set_processor_exception_handler_vector::
* __dpmi_set_protected_mode_interrupt_vector::
* __dpmi_set_real_mode_interrupt_vector::
* __dpmi_set_segment_base_address::
* __dpmi_set_segment_limit::
* __dpmi_simulate_real_mode_interrupt::
* __dpmi_simulate_real_mode_procedure_iret::
* __dpmi_simulate_real_mode_procedure_retf::
* __dpmi_simulate_real_mode_procedure_retf_stack::
* __dpmi_terminate_and_stay_resident::
* __dpmi_unlock_linear_region::
* __dpmi_yield::
* dup::
* dup2::
* _dxe_load::
* enable::
* endgrent::
* endmntent::
* endpwent::
* errno::
* exec*::
* _exit::
* exit::
* exp::
* fabs::
* _far*::
* fclose::
* fcntl::
* fdopen::
* feof::
* ferror::
* fflush::
* ffs::
* fgetc::
* fgetgrent::
* fgetpos::
* fgets::
* File System Extensions::
* __file_exists::
* file_tree_walk::
* filelength::
* fileno::
* findfirst::
* findnext::
* _fixpath::
* floor::
* fmod::
* _fmode::
* fnmatch::
* fnmerge::
* fnsplit::
* fopen::
* fork::
* fpathconf::
* _fpreset::
* fprintf::
* fpurge::
* fputc::
* fputs::
* fread::
* free::
* freopen::
* frexp::
* fscanf::
* fseek::
* fsetpos::
* __FSEXT_add_open_handler::
* __FSEXT_alloc_fd::
* __FSEXT_call_open_handlers::
* __FSEXT_get_function::
* __FSEXT_set_function::
* fstat::
* fsync::
* ftell::
* ftime::
* ftruncate::
* ftw::
* _fwalk::
* fwrite::
* _get_dev_info::
* _get_dos_version::
* getc::
* getcbrk::
* getch::
* getchar::
* getche::
* getcwd::
* getdate::
* getdfree::
* getdisk::
* getdtablesize::
* getegid::
* getenv::
* geteuid::
* getftime::
* getgid::
* getgrent::
* getgrgid::
* getgrnam::
* gethostname::
* getitimer::
* getkey::
* getlogin::
* getlongpass::
* getmntent::
* getpagesize::
* getpass::
* getpgrp::
* getpid::
* getpwent::
* getpwnam::
* getpwuid::
* getrusage::
* gets::
* gettext::
* gettextinfo::
* gettime::
* gettimeofday::
* getuid::
* getw::
* getwd::
* getxkey::
* glob::
* globfree::
* gmtime::
* _go32_conventional_mem_selector::
* _go32_dpmi_allocate_dos_memory::
* _go32_dpmi_allocate_iret_wrapper::
* _go32_dpmi_allocate_real_mode_callback_iret::
* _go32_dpmi_allocate_real_mode_callback_retf::
* _go32_dpmi_chain_protected_mode_interrupt_vector::
* _go32_dpmi_free_dos_memory::
* _go32_dpmi_free_iret_wrapper::
* _go32_dpmi_free_real_mode_callback::
* _go32_dpmi_get_free_memory_information::
* _go32_dpmi_get_protected_mode_interrupt_vector::
* _go32_dpmi_get_real_mode_interrupt_vector::
* _go32_dpmi_lock_code::
* _go32_dpmi_lock_data::
* _go32_dpmi_remaining_physical_memory::
* _go32_dpmi_remaining_virtual_memory::
* _go32_dpmi_resize_dos_memory::
* _go32_dpmi_set_protected_mode_interrupt_vector::
* _go32_dpmi_set_real_mode_interrupt_vector::
* _go32_dpmi_simulate_fcall::
* _go32_dpmi_simulate_fcall_iret::
* _go32_dpmi_simulate_int::
* _go32_info_block::
* _go32_interrupt_stack_size::
* _go32_my_cs::
* _go32_my_ds::
* _go32_my_ss::
* _go32_rmcb_stack_size::
* _go32_want_ctrl_break::
* _go32_was_ctrl_break_hit::
* gotoxy::
* gppconio_init::
* hasmntopt::
* highvideo::
* htonl::
* htons::
* hypot::
* inb::
* index::
* inp::
* inportb::
* inportl::
* inportsb::
* inportsl::
* inportsw::
* inportw::
* inpw::
* insline::
* insque::
* int386::
* int386x::
* int86::
* int86x::
* intdos::
* intdosx::
* _is_executable::
* isalnum::
* isalpha::
* isascii::
* isatty::
* iscntrl::
* isdigit::
* isgraph::
* islower::
* isprint::
* ispunct::
* isspace::
* isupper::
* isxdigit::
* itoa::
* kbhit::
* kill::
* labs::
* ldexp::
* ldiv::
* link::
* localeconv::
* localtime::
* lock::
* log::
* log10::
* log2::
* longjmp::
* lowvideo::
* lseek::
* malloc::
* mblen::
* mbstowcs::
* mbtowc::
* memccpy::
* memchr::
* memcmp::
* memcpy::
* memmove::
* memset::
* mkdir::
* mkfifo::
* mknod::
* mkstemp::
* mktemp::
* mktime::
* modf::
* modfl::
* _mono_clear::
* _mono_printf::
* _mono_putc::
* movedata::
* movedatab::
* movedatal::
* movedataw::
* movetext::
* mprotect::
* _my_cs::
* _my_ds::
* _my_ss::
* nice::
* normvideo::
* nosound::
* ntohl::
* ntohs::
* open::
* _open::
* opendir::
* outb::
* outp::
* outportb::
* outportl::
* outportsb::
* outportsl::
* outportsw::
* outportw::
* outpw::
* pathconf::
* pause::
* pclose::
* perror::
* pipe::
* popen::
* pow::
* pow10::
* pow2::
* printf::
* putc::
* putch::
* putchar::
* putenv::
* puts::
* puttext::
* putw::
* qsort::
* raise::
* rand::
* random::
* rawclock::
* read::
* _read::
* readdir::
* realloc::
* remove::
* remque::
* rename::
* rewind::
* rewinddir::
* rindex::
* rmdir::
* sbrk::
* scanf::
* Screen Variables::
* ScreenClear::
* ScreenCols::
* ScreenGetCursor::
* ScreenMode::
* ScreenPutChar::
* ScreenPutString::
* ScreenRetrieve::
* ScreenRows::
* ScreenSetCursor::
* ScreenUpdate::
* ScreenUpdateLine::
* ScreenVisualBell::
* searchpath::
* seekdir::
* select::
* _set_screen_lines::
* setbuf::
* setbuffer::
* setcbrk::
* _setcursortype::
* setdate::
* setdisk::
* setenv::
* setftime::
* setgrent::
* setitimer::
* setjmp::
* setlinebuf::
* setlocale::
* setmntent::
* setmode::
* setpgid::
* setpwent::
* settime::
* settimeofday::
* setvbuf::
* siglongjmp::
* signal::
* sigsetjmp::
* sin::
* sinh::
* sleep::
* sound::
* spawn*::
* sprintf::
* sqrt::
* srandom::
* sscanf::
* stat::
* statfs::
* _status87::
* _stklen::
* stpcpy::
* strcase::
* strcasecmp::
* strcat::
* strchr::
* strcmp::
* strcoll::
* strcpy::
* strcspn::
* strdup::
* strerror::
* strftime::
* stricmp::
* strlen::
* strlwr::
* strncase::
* strncasecmp::
* strncat::
* strncmp::
* strncpy::
* strnicmp::
* strpbrk::
* strrchr::
* strsep::
* strspn::
* strstr::
* strtod::
* strtok::
* strtol::
* _strtold::
* strtoul::
* strupr::
* strxfrm::
* swab::
* sync::
* sys_errlist::
* sys_nerr::
* sysconf::
* system::
* tan::
* tanh::
* tell::
* telldir::
* textattr::
* textbackground::
* textcolor::
* textmode::
* time::
* times::
* tmpfile::
* tmpnam::
* toascii::
* tolower::
* toupper::
* _truename::
* truncate::
* ttyname::
* uclock::
* umask::
* uname::
* ungetc::
* ungetch::
* unlink::
* unlock::
* _use_lfn::
* usleep::
* utime::
* utimes::
* vfprintf::
* vprintf::
* vsprintf::
* wait::
* waitpid::
* wcstombs::
* wctomb::
* wherex::
* wherey::
* window::
* write::
* _write::
* xfree::
* xmalloc::
* xrealloc::


File: libc,  Node: abort,  Next: abs,  Up: Alphabetical List

abort
=====

Syntax
------

     #include <stdlib.h>
     
     void abort(void);

Description
-----------

When you call `abort', the message "Abort!" is printed on stdout and
the program exits with an exit code of one.

Return Value
------------

This function does not return.

Example
-------

     if ((q = malloc(100)) == NULL)
       abort();


File: libc,  Node: abs,  Next: access,  Prev: abort,  Up: Alphabetical List

abs
===

Syntax
------

     #include <stdlib.h>
     
     int abs(int value);

Return Value
------------

The absolute value of `value' is returned.

Example
-------

     int sq = 7;
     sq = sq * abs(sq) + 1;


File: libc,  Node: access,  Next: acos,  Prev: abs,  Up: Alphabetical List

access
======

Syntax
------

     #include <unistd.h>
     
     int access(const char *filename, int flags);

Description
-----------

This function determines what kind of access modes a given file allows.
The parameter FLAGS is the logical `or' of one or more of the following
flags:

`R_OK'
     Request if the file is readable.  Since all files are readable
     under MS-DOS, this access mode always exists.

`W_OK'
     Request if the file is writable.

`X_OK'
     Request if the file is executable.

`F_OK'
     Request if the file exists.

`D_OK'
     Request if the file is really a directory.

Return Value
------------

Zero if the requested access mode is allowed, nonzero if not.

Example
-------

     if (access("file.ext", W_OK))
       return ERROR_CANNOT_WRITE;
     open("file.ext", O_RDWR);


File: libc,  Node: acos,  Next: acosh,  Prev: access,  Up: Alphabetical List

acos
====

Syntax
------

     #include <math.h>
     
     double acos(double x);

Return Value
------------

The arc cosine of X.


File: libc,  Node: acosh,  Next: addmntent,  Prev: acos,  Up: Alphabetical List

acosh
=====

Syntax
------

     #include <math.h>
     
     double acosh(double x);

Return Value
------------

The arc hyperbolic cosine of X.


File: libc,  Node: addmntent,  Next: alarm,  Prev: acosh,  Up: Alphabetical List

addmntent
=========

Syntax
------

     #include <mntent.h>
     
     int addmntent(FILE *filep, struct mntent *mnt);

Description
-----------

This function is a no-op for MS-DOS, but is provided to assist in Unix
ports.  *Note getmntent::.

Return Value
------------

This function always returns nonzero to signify an error.


File: libc,  Node: alarm,  Next: alloca,  Prev: addmntent,  Up: Alphabetical List

alarm
=====

Syntax
------

     #include <unistd.h>
     
     unsigned alarm(unsigned seconds);

Description
-----------

This function causes the signal SIGALRM to be raised in SECONDS seconds.
A value of zero for SECONDS cancels any pending alarm.  If an alarm has
previously been set, the new alarm delay will superceed the prior call.

Return Value
------------

The number of seconds remaining on the timer (i.e. always SECONDS).

Example
-------

     signal(SIGALRM,my_alarm_routine);
     alarm(5);


File: libc,  Node: alloca,  Next: asctime,  Prev: alarm,  Up: Alphabetical List

alloca
======

Syntax
------

     #include <stdlib.h>
     
     void *alloca(size_t _size)

Description
-----------

Allocate memory that will be automatically released when the current
procedure exits.  Note that, when compiling with gcc, alloca is a
built-in function and not a library call.

Return Value
------------

A pointer to the memory, else NULL.

Example
-------

     q = alloca(strlen(x)+1);
     strcpy(q, x);


File: libc,  Node: asctime,  Next: asin,  Prev: alloca,  Up: Alphabetical List

asctime
=======

Syntax
------

     #include <time.h>
     
     char *asctime(const struct tm *tptr);

Description
-----------

This function returns an ASCII representation of the time represented by
TPTR.  The string returned is always 26 characters and has this format:

     Sun Jan 01 12:34:56 1993\n\0

The string pointed to is in a static buffer and will be overridden with
each call to asctime.  The data should be copied if it needs to be
preserved.

Return Value
------------

A pointer to the string.

Example
-------

     time_t now;
     time(&now);
     printf("The current time is %s", asctime(localtime(&now)));


File: libc,  Node: asin,  Next: asinh,  Prev: asctime,  Up: Alphabetical List

asin
====

Syntax
------

     #include <math.h>
     
     double asin(double x);

Return Value
------------

The arc sine of X.


File: libc,  Node: asinh,  Next: assert,  Prev: asin,  Up: Alphabetical List

asinh
=====

Syntax
------

     #include <math.h>
     
     double asinh(double x);

Return Value
------------

The arc hyperbolic sine of X.


File: libc,  Node: assert,  Next: atan,  Prev: asinh,  Up: Alphabetical List

assert
======

Syntax
------

     #define NDEBUG
     #include <assert.h>
     
     assert(expression);
     assertval(expression);

Description
-----------

These macros are used to assist in debugging.  The source code includes
references to assert and assertval, passing them expressions that should
be true (or non-zero).  When the expression equals zero, a diagnostic
message is printed to stderr and the program aborts.

If you define the macro `NDEBUG' before including `assert.h', then the
macros expand to nothing to reduce code size after debugging is done.

Return Value
------------

`assert' returns one if it passes, else it aborts.

`assertval' returns the value of the expression if nonzero, else it
aborts.

Example
-------

     int strdup(char *s)
     {
       assert(s != 0);


File: libc,  Node: atan,  Next: atan2,  Prev: assert,  Up: Alphabetical List

atan
====

Syntax
------

     #include <math.h>
     
     double atan(double x);

Return Value
------------

The arc tangent of X.


File: libc,  Node: atan2,  Next: atanh,  Prev: atan,  Up: Alphabetical List

atan2
=====

Syntax
------

     #include <math.h>
     
     double atan2(double y, double x);

Return Value
------------

The arc tangent of Y/X, with appropriate return values for Y=0 or X=0.


File: libc,  Node: atanh,  Next: atexit,  Prev: atan2,  Up: Alphabetical List

atanh
=====

Syntax
------

     #include <math.h>
     
     double atanh(double x);

Return Value
------------

The arc hyperbolic tangent of X.


File: libc,  Node: atexit,  Next: atof,  Prev: atanh,  Up: Alphabetical List

atexit
======

Syntax
------

     #include <stdlib.h>
     
     int atexit(void (*func)(void));

Description
-----------

This function places the specified function FUNC on a list of functions
to be called when `exit' is called.  These functions are called as if a
last-in-first-out queue is used, that is, the last function registered
with `atexit' will be the first function called by `exit'.

At least 32 functions can be registered this way.

Return Value
------------

Zero on success, non-zero on error.

Example
-------

     void exit_func()
     {
       remove("file.tmp");
     }
     
     ...
     atexit(exit_func);
     ...


File: libc,  Node: atof,  Next: atoi,  Prev: atexit,  Up: Alphabetical List

atof
====

Syntax
------

     #include <stdlib.h>
     
     double atof(const char *string);

Description
-----------

Convert as much of the string as possible to an equivalent double
precision real number.

This function is almost like `strtod(string, NULL)' (*note strtod::.).

Return Value
------------

The equivalent value, or zero if the string does not represent a number.

Example
-------

     main(int argc, char **argv)
     {
       double d = atof(argv[1]);
       ...


File: libc,  Node: atoi,  Next: atol,  Prev: atof,  Up: Alphabetical List

atoi
====

Syntax
------

     #include <stdlib.h>
     
     int atoi(const char *string);

Description
-----------

Convert as much of the string as possible to an equivalent integer
value.

This function is almost like `(int)strtol(string, NULL, 10)' (*note
strtol::.).

Return Value
------------

The equivalent value, or zero if the string does not represent a number.

Example
-------

     main(int argc, char **argv)
     {
       int i = atoi(argv[1]);
       ...


File: libc,  Node: atol,  Next: _atold,  Prev: atoi,  Up: Alphabetical List

atol
====

Syntax
------

     #include <stdlib.h>
     
     long atol(const char *string);

Description
-----------

Convert as much of the string as possible to an equivalent long integer
value.

This function is almost like `strtol(string, NULL, 10)' (*note
strtol::.).

Return Value
------------

The equivalent value, or zero if the string does not represent a number.

Example
-------

     main(int argc, char **argv)
     {
       long l = atol(argv[1]);
       ...


File: libc,  Node: _atold,  Next: bcmp,  Prev: atol,  Up: Alphabetical List

_atold
======

Syntax
------

     #include <stdlib.h>
     
     long double _atold(const char *string);

Description
-----------

Convert as much of the string as possible to an equivalent long double
precision real number.

This function is almost like `_strtold(string, NULL)' (*note
_strtold::.).

Return Value
------------

The equivalent value, or zero if the string does not represent a number.

Example
-------

     main(int argc, char **argv)
     {
       long double d = _atold(argv[1]);
       ...


File: libc,  Node: bcmp,  Next: bcopy,  Prev: _atold,  Up: Alphabetical List

bcmp
====

Syntax
------

     #include <string.h>
     
     int bcmp(const void *ptr1, const void *ptr2, int length);

Description
-----------

Compare memory pointed to by PTR1 and PTR2 for at most LENGTH bytes.

Return Value
------------

The number of bytes remaining when the first mismatch occurred, or zero
if all bytes were equal.

Example
-------

     void f(char *s1, char *s2)
     {
       int l = bcmp(s1, s2, strlen(s1));
       printf("Difference: %s, %s\n", s1+strlen(s1)-l, s2+strlen(s1)-l);
     }


File: libc,  Node: bcopy,  Next: bdos,  Prev: bcmp,  Up: Alphabetical List

bcopy
=====

Syntax
------

     #include <string.h>
     
     void bcopy(const void *source, void *dest, int length);

Description
-----------

Copy LENGTH bytes from SOURCE to DEST.  Overlapping regions are handled
properly, although this behavior is not portable.

Return Value
------------

No value is returned.

Example
-------

     struct s a, b;
     bcopy(a, b, sizeof(struct s));


File: libc,  Node: bdos,  Next: bdosptr,  Prev: bcopy,  Up: Alphabetical List

bdos
====

Syntax
------

     #include <dos.h>
     
     int bdos(int func, unsigned dx, unsigned al);

Description
-----------

Calls function FUNC of the software interrupt 0x21, passing it AL as
the subfunction and (the lower 16 bit of) DX in the `DX' register.
This function will only work for a subset of DOS functions which
require no arguments at all, or take non-pointer arguments in the `AL'
and `DX' registers only.  For functions which require a pointer in the
`DX' register, use `bdosptr' (*note bdosptr::.).

Return Value
------------

Whatever the called function returns in the AX register.

Example
-------

     /* read a character */
     int ch = bdos(1, 0, 0) & 0xff;


File: libc,  Node: bdosptr,  Next: _bios_disk,  Prev: bdos,  Up: Alphabetical List

bdosptr
=======

Syntax
------

     #include <dos.h>
     
     int bdosptr(int func, void *ptr, unsigned al);

Description
-----------

Calls function FUNC of the software interrupt 0x21, passing it AL as
the subfunction and a pointer to a copy of the buffer contents whose
address is in PTR through the `DX' register.  This function will only
work for a subset of DOS which require an argument in the `AL' register
and a pointer in `DX' register.  For functions which require
non-pointer arguments in the `DX' register, use `bdos' (*note bdos::.).
To make the contents of PTR available to DOS, `bdosptr' copies it to
the transfer buffer located in the low (below 1 Meg mark) memory.

Currently, some of the functions which take a pointer to a buffer in
`DX' are *NOT* supported (notably, most of the FCB-based functions).
*Note int86:: for the list of supported functions.

Return Value
------------

Whatever the called function returns in the AX register.

Example
-------

     /* print a string */
     bdos(9, "Hello, there$", 0);


File: libc,  Node: _bios_disk,  Next: _bios_equiplist,  Prev: bdosptr,  Up: Alphabetical List

_bios_disk
==========

Syntax
------

     #include <bios.h>
     
     unsigned _bios_disk(unsigned cmd, struct diskinfo_t *di)

Description
-----------

This function interfaces with the BIOS disk sevice (interrupt 0x13).
The parameter CMD select the corresponding disk service and the
structure DI holds the disk parameters.

     struct diskinfo_t {
       unsigned drive;       /* Drive number. */
       unsigned head;        /* Head number. */
       unsigned track;       /* Track number. */
       unsigned sector;      /* Sector number. */
       unsigned nsectors;    /* Number of sectors to read/write/verify. */
       void    *buffer;      /* Buffer for reading/writing/verifying. */
     }

The following services are available based on value of CMD:

`_DISK_RESET'
     Forces the disk controller to do a hard reset, preparing for
     floppy-disk I/O. This is useful after an error occurs in another
     operation, such as a read. If this service is specified, the DI
     argument is ignored. Status is returned in the 8 high-order bits
     (AH) of the return value. If there is an error, the high-order
     byte will contain a set of status flags, as defined below under
     Return Value.

`_DISK_STATUS'
     Obtains the status of the last disk operation. If this service is
     specified, the <diskinfo> argument is ignored. Status is returned
     in the 8 low-order bits (AL) of the return value. If there is an
     error, the low-order byte (AL) will contain a set of status flags,
     as defined below under Return Value.

`_DISK_READ'
     Reads one or more disk sectors into memory. This service uses all
     fields of the structure pointed to by DISKINFO. If no error
     occurs, the function returns 0 in the high-order byte and the
     number of sectors read in the low-order byte. If there is an
     error, the high-order byte (AH) will contain a set of status
     flags, as defined below under Return Value.

`_DISK_WRITE'
     Writes data from memory to one or more disk sectors. This service
     uses all fields of the structure pointed to by <diskinfo>. If no
     error occurs, the function returns 0 in the high-order byte (AH)
     and the number of sectors written in the low-order byte (AL). If
     there is an error, the high-order byte will contain a set of
     status flags, as defined below under Return Value.

`_DISK_FORMAT'
     Formats the track specified by DISKINFO. The HEAD and TRACK fields
     indicate the track to format. Only one track can be formatted in a
     single call. The BUFFER field points to a set of sector markers.
     The format of the markers depends on the type of disk drive (see a
     technical reference to the PC BIOS to determine the marker
     format). The high-order byte (AH) of the return value contains the
     status of the call; 0 equals success. If there is an error, the
     high-order byte will contain a set of status flags, as defined
     below under Return Value.

`_DISK_VERIFY'
     Checks the disk to be sure the specified sectors exist and can be
     read.  It also runs a CRC (cyclic redundancy check) test. This
     service uses all fields (except BUFFER) of the structure pointed
     to by DISKINFO.  If no error occurs, the function returns 0 in the
     high-order byte (AH) and the number of sectors compared in the
     low-order byte (AL), as defined below under Return Value.

Return Value
------------

Return value of AX register. The meaning of high-order byte (AH):
     0x00  No error
     0x01  Invalid request or a bad command
     0x02  Address mark not found
     0x03  Disk write protected
     0x04  Sector not found
     0x05  Reset failed
     0x06  Floppy disk removed
     0x07  Drive parameter activity failed
     0x08  Direct Memory Access (DMA) overrun
     0x09  DMA crossed 64K boundary
     0x0A  Bad sector flag detected
     0x0B  Bad track flag detected
     0x0C  Media type not found
     0x0D  Invalid number of sectors on format
     0x0E  Control data access mark detected
     0x0F  DMA arbitration level out of range
     0x10  Data read (CRC or ECC) error
     0x11  Corrected data read (ECC) error
     0x20  Controller failure
     0x40  Seek error
     0x80  Disk timed out or failed to respond
     0xAA  Drive not ready
     0xBB  Undefined error
     0xCC  Write fault on drive
     0xE0  Status error
     0xFF  Sense operation failed

Example
-------

     char record_buffer[512];
     struct diskinfo_t di;
     
     di.drive    = 0x80;
     di.head     = 0;
     di.track    = 0;
     di.sector   = 0;
     di.nsectors = 1;
     di.buffer   = &record_buffer;
     if ( _bios_disk(_DISK_READ, &di) )
       puts("Disk error.");


File: libc,  Node: _bios_equiplist,  Next: _bios_keybrd,  Prev: _bios_disk,  Up: Alphabetical List

_bios_equiplist
===============

Syntax
------

     #include <bios.h>
     
     unsigned _bios_equiplist(void)

Description
-----------

This function returns the equipment word from BIOS request 0x11.  The
bits correspond to the following values:

     Bits  Meaning
     0     True (1) if disk drive(s) installed
     1     True (1) if math coprocessor installed
     2-3   System RAM in 16K blocks (16-64K)
     4-5   Initial video mode:
                00 = Reserved
                01 = 40 x 25 color
                10 = 80 x 25 color
                11 = 80 x 25 monochrome
     6-7   Number of floppy-disk drives installed
           (00 = 1, 01 = 2, etc.)
     8     False (0) if and only if a Direct Memory Access (DMA)
           chip is installed
     9-11  Number of RS232 serial ports installed
     12    True (1) if and only if a game adapter is installed
     13    True (1) if and only if an internal modem is installed
     14-15 Number of printers installed

Return Value
------------

The equipment word.

Example
-------

     if ( _bios_equip() & 0xc000 )
       do_printing();


File: libc,  Node: _bios_keybrd,  Next: _bios_memsize,  Prev: _bios_equiplist,  Up: Alphabetical List

_bios_keybrd
============

Syntax
------

     #include <bios.h>
     
     unsigned _bios_keybrd(unsigned cmd);

Description
-----------

The _bios_keybrd routine uses INT 0x16 to access the keyboard services.
The CMD argument can be any of the following manifest constants:

`_KEYBRD_READ'
     Read the next key pressed

`_NKEYBRD_READ'
     Read the next extended key pressed

`_KEYBRD_READY'
     Check if the next key in the keyboard buffer

`_NKEYBRD_READY'
     Check if the next extended key in the keyboard buffer

`_KEYBRD_SHIFTSTATUS'
     Read keyboard shift state (0x0040:0x0017 byte):

          7654 3210  Meaning
          ---- ---X  Right SHIFT is pressed
          ---- --X-  Left SHIFT is pressed
          ---- -X--  CTRL is pressed
          ---- X---  ALT is pressed
          ---X ----  Scroll Lock locked
          --X- ----  Num Lock locked
          -X-- ----  Caps Lock locked
          X--- ----  Insert locked

`_NKEYBRD_SHIFTSTATUS'
     Read keyboard shift and extended shift state (0x0040:0x0017 word):

          FEDC BA98  7654 3210  Meaning
          ---- ----  ---- ---X  Right SHIFT is pressed
          ---- ----  ---- --X-  Left SHIFT is pressed
          ---- ----  ---- -X--  CTRL is pressed
          ---- ----  ---- X---  ALT is pressed
          ---- ----  ---X ----  Scroll Lock locked
          ---- ----  --X- ----  Num Lock locked
          ---- ----  -X-- ----  Caps Lock locked
          ---- ----  X--- ----  Insert locked
          
          ---- ---X  ---- ----  Left CTRL is pressed
          ---- --X-  ---- ----  Left ALT is pressed
          ---- -X--  ---- ----  Right CTRL is pressed
          ---- X---  ---- ----  Right ALT is pressed
          ---X ----  ---- ----  Scroll Lock is pressed
          --X- ----  ---- ----  Num Lock is pressed
          -X-- ----  ---- ----  Caps Lock is pressed
          X--- ----  ---- ----  SysReq is pressed

Return Value

With the ???_READ and ???_SHIFTSTATUS arguments, the _bios_keybrd
function returns the contents of the AX register after the BIOS call.

With the ???_READY argument, _bios_keybrd returns 0 if there is no key.
If there is a key, _bios_keybrd returns the key waiting to be read
(that is, the same value as _KEYBRD_READ).

With the ???_READ and ???_READY arguments, the _bios_keybrd function
returns -1 if CTRL+BREAK has been pressed and is the next keystroke to
be read.

Example
-------

     while( !_bios_keybrd(_KEYBRD_READY) )
       try_to_do_something();


File: libc,  Node: _bios_memsize,  Next: _bios_printer,  Prev: _bios_keybrd,  Up: Alphabetical List

_bios_memsize
=============

Syntax
------

     #include <bios.h>
     
     unsigned _bios_memsize(void);

Description
-----------

This function returns the amount of system memory in 1K blocks (up to
640K).

Return Value
------------

Size of memory (in K).

Example
-------

     printf("This system has %d bytes of memory\n", _bios_memsize() * 1024);


File: libc,  Node: _bios_printer,  Next: _bios_serialcom,  Prev: _bios_memsize,  Up: Alphabetical List

_bios_printer
=============

Syntax
------

     #include <bios.h>
     
     unsigned _bios_printer(unsigned cmd, unsigned printer, unsigned data);

Description
-----------

The _bios_printer routine uses INT 0x17 to perform printer output
services for parallel printers. The PRINTER argument specifies the
affected printer, where 0 is LPT1, 1 is LPT2, and so on.  The CMD
argument can be any of the following manifest constants:

`_PRINTER_INIT'
`Reset and initialize the specified printer port'
`_PRINTER_STATUS'
     Return the status of the specified printer port

`_PRINTER_WRITE'
     Print the DATA argument to the specified printer port

Return Value
------------

The _bios_printer function returns the value in the AX register after
the BIOS interrupt. The high-order byte (AH) of the return value
indicates the printer status after the operation, as defined below:

     Bit     Meaning if True
     
     0       Printer timed out
     1       Not used
     2       Not used
     3       I/O error
     4       Printer selected
     5       Out of paper
     6       Acknowledge
     7       Printer not busy

Example
-------

     while (*c)
       _bios_printer(_PRINTER_WRITE, *c++, 0);


File: libc,  Node: _bios_serialcom,  Next: _bios_timeofday,  Prev: _bios_printer,  Up: Alphabetical List

_bios_serialcom
===============

Syntax
------

     #include <bios.h>
     
     unsigned _bios_serialcom(unsigned cmd, unsingned serialport, unsigned data);

Description
-----------

The _bios_serialcom routine uses INT 0x14 to provide serial
communications services. The SERIALPORT argument is set to 0 for COM1,
to 1 for COM2, and so on. The CMD argument can be set to one of the
following manifest constants:

`_COM_INIT'
     Initialize com port (DATA is the settings)

`_COM_RECEIVE'
     Read a byte from port

`_COM_SEND'
     Write a byte to port

`_COM_STATUS'
     Get the port status

The DATA argument is ignored if CMD is set to _COM_RECEIVE or
_COM_STATUS. The DATA argument for _COM_INIT is created by combining
one or more of the following constants (with the OR operator):

     _COM_CHR7         7 bits/character
     _COM_CHR8         8 bits/character
     _COM_STOP1        1 stop bit
     _COM_STOP2        2 stop bits
     _COM_NOPARITY     no parity
     _COM_EVENPARITY   even parity
     _COM_ODDPARITY    odd parity
     _COM_110          110 baud
     _COM_150          150 baud
     _COM_300          300 baud
     _COM_600          600 baud
     _COM_1200         1200 baud
     _COM_2400         2400 baud
     _COM_4800         4800 baud
     _COM_9600         9600 baud

The default value of DATA is 1 stop bit, no parity, and 110 baud.

Return Value
------------

The function returns a 16-bit integer whose high-order byte contains
status bits. The meaning of the low-order byte varies, depending on the
CMD value. The high-order bits are as follows:

     Bit     Meaning if Set
     
     15      Timed out
     14      Transmission-shift register empty
     13      Transmission-hold register empty
     12      Break detected
     11      Framing error
     10      Parity error
      9      Overrun error
      8      Data ready

When service is _COM_SEND, bit 15 is set if data cannot be sent.

When service is _COM_RECEIVE, the byte read is returned in the
low-order bits if the call is successful. If an error occurs, any of
the bits 9, 10, 11, or 15 is set.

When service is _COM_INIT or _COM_STATUS, the low-order bits are
defined as follows:

     Bit     Meaning if Set
     
     7       Receive-line signal detected
     6       Ring indicator
     5       Data-set-ready
     4       Clear-to-send
     3       Change in receive-line signal detected
     2       Trailing-edge ring indicator
     1       Change in data-set-ready status
     0       Change in clear-to-send status

Example
-------

     /* 9600 baud, no parity, one stop, 8 bits */
     _bios_serialcom(_COM_INIT, 0, _COM_9600|_COM_NOPARITY|_COM_STOP1|_COM_CHR8);
     for(i=0; buf[i]; i++)
       _bios_serialcom(_COM_SEND, 0, buf[i]);


File: libc,  Node: _bios_timeofday,  Next: bioscom,  Prev: _bios_serialcom,  Up: Alphabetical List

_bios_timeofday
===============

Syntax
------

     #include <bios.h>
     
     unsigned _bios_timeofday(unsigned cmd, unsigned long *timeval);

Description
-----------

The _bios_timeofday routine uses INT 0x1A to get or set the clock count
(which is the number of 18.2 Hz ticks since midnight). The CMD argument
can be either the _TIME_GETCLOCK or _TIME_SETCLOCK manifest constant.

Return Value
------------

If the argument is _TIME_GETCLOCK, the routine returns a nonzero value
if midnight was passed since last read, or zero if midnight was not
passed. If the argument is _TIME_SETCLOCK, the return value is
undefined.

Example
-------

     unsigned hour, min, sec, hsec;
     unsigned long ticks;
     ...
     ticks = (unsigned long)(hour * 65543.33) + (min * 1092.38) +
             (sec * 18.21) + (hsec * 0.182);
     _bios_timeofday(_TIME_SETCLOCK, &ticks);


File: libc,  Node: bioscom,  Next: biosdisk,  Prev: _bios_timeofday,  Up: Alphabetical List

bioscom
=======

Syntax
------

     #include <bios.h>
     
     int bioscom(int cmd, char data, int port);

Description
-----------

This function accesses the BIOS interrupt 0x14 function, serial
communication services.  The valid values of cmd are:

0 - initialize com port (DATA is the settings)
1 - write byte to port
2 - read byte from port
3 - get port status

For initialization, the byte is made up of the following bits:

     0000 0000
     7654 3210  Meaning
     
     ---- --10  7 bits/character
     ---- --11  8 bits/character
     ---- -0--  1 stop bit
     ---- -1--  2 stop bits
     ---X 0---  no parity
     ---0 1---  odd parity
     ---1 1---  even parity
     000- ----  110 baud
     001- ----  150 baud
     010- ----  300 baud
     011- ----  600 baud
     100- ----  1200 baud
     101- ----  2400 baud
     110- ----  4800 baud
     111- ----  9600 baud

Return Value
------------

The return value is a sequence of bits that indicate the port status
and, for cmd=0 and 3, the modem status.  For read/write operations, the
lower eight bits are the character read.

     1111 1100 0000 0000
     5432 1098 7654 3210  Meaning
     
     ---- ---- ---- ---1  CTS change
     ---- ---- ---- --1-  DSR change
     ---- ---- ---- -1--  ring change
     ---- ---- ---- 1---  carrier detect change
     ---- ---- ---1 ----  CTS present
     ---- ---- --1- ----  DSR present
     ---- ---- -1-- ----  ring present
     ---- ---- 1--- ----  carrier detect
     ---- ---1 ---- ----  data ready
     ---- --1- ---- ----  overrun error
     ---- -1-- ---- ----  parity error
     ---- 1--- ---- ----  framing error
     ---1 ---- ---- ----  break detected
     --1- ---- ---- ----  transmit holding register empty
     -1-- ---- ---- ----  transmit shift register empty
     1--- ---- ---- ----  time out (=1 if error present for cmd=1,2)

Example
-------

     bioscom(0, 0xe3); /* 9600 baud, no parity, one stop, 8 bits */
     for (i=0; buf[i]; i++)
       bioscom(1, buf[i]);


File: libc,  Node: biosdisk,  Next: biosequip,  Prev: bioscom,  Up: Alphabetical List

biosdisk
========

Syntax
------

     #include <bios.h>
     
     int biosdisk(int cmd, int drive, int head, int track,
     	     int sector, int nsects, void *buffer);

Description
-----------

This function interfaces with the BIOS disk sevice (interrupt 0x13).
Please refer to a BIOS reference manual for detailed information about
the parameters of this call.  All known calls are supported.  A sector
size of 512 bytes is assumed.

0 - reset disk subsystem
1 - get disk subsystem status
2 - read one or more sectors
3 - write one or more sectors
5 - format a track
6 - format back track
7 - format drive
8 - get drive parameters
9 - initialize drive parameters
10 - read long sectors
11 - write long sectors
12 - seek to cylinder
13 - alternate fixed disk reset
14 - read test buffer
15 - write test buffer
16 - test for drive ready
17 - recalibrate drive
18 - controller RAM diagnostic
19 - controller drive diagnostic
20 - controller internal diagnostic
15 - read fixed disk type
22 - read disk change line status
23 - set DASD type (pass dasd in NSECTS)
24 - set media type for format

The first request with more sectors than will fit in the transfer
buffer will cause a DOS buffer to be allocated.  This buffer is
automatically freed when your application exits.  Since this buffer is
big enough to hold 18 sectors, requests for more sectors than that will
fail.

Request eight returns values in buffer as follows:

byte 0 = sectors per track (bits 0..5) and top two bits of cylinder (in bits 6..7)
byte 1 = cyliders (bits 0..7)
byte 2 = number of drives
byte 3 = number of heads

Return Value
------------

The value of AH returned by the BIOS.

Example
-------

     char buffer[512];
     if (biosdisk(2, 0x80, 0, 0, 0, 1, buffer))
       error("disk");


File: libc,  Node: biosequip,  Next: bioskey,  Prev: biosdisk,  Up: Alphabetical List

biosequip
=========

Syntax
------

     #include <bios.h>
     
     int biosequip(void);

Description
-----------

This function returns the equipment word from BIOS request 0x11.  The
bits correspond to the following values:

     1111 1100 0000 0000
     5432 1098 7654 3210  Meaning
     
     ---- ---- ---- ---X  1 = disk drive(s) installed
     ---- ---- ---- --X-  1 = math coprocessor installed
     ---- ---- ---- XX--  System memory 00=16k 01=32k 10=48k 11=64k (non PS/2)
     ---- ---- ---- -X--  1 = pointing device installed (PS/2)
     ---- ---- ---- X---  not used on PS/2
     ---- ---- --XX ----  initial video mode: 01=CO40 10=CO80 11=MONO
     ---- ---- XX-- ----  disk drives 00=1 01=2 10=3 11=4 (zero if bit 1=0)
     ---- ---X ---- ----  1 = no DMA available
     ---- XXX- ---- ----  number of serial ports installed (000=0 001=1 etc)
     ---X ---- ---- ----  1 = game port adapter installed
     --X- ---- ---- ----  1 = internal modem installed (PS/2)
     --X- ---- ---- ----  1 = serial printer attached (non PS/2)
     XX-- ---- ---- ----  number of printers installed (00=0 01=1 10=2 11=3)

Return Value
------------

The equipment word.

Example
-------

     if (biosequip() & 0xc000)
       do_printing();


File: libc,  Node: bioskey,  Next: biosmemory,  Prev: biosequip,  Up: Alphabetical List

bioskey
=======

Syntax
------

     #include <bios.h>
     
     int bioskey(int command)

Description
-----------

COMMAND = 0
     Returns the next key pressed

COMMAND = 1
     Checks the keyboard, returns zero if no key pressed, else the key.
     Does not dequeue the key.

COMMAND = 2
     Returns the shift state:

          7654 3210  Meaning
          
          ---- ---X  Right shift key down
          ---- --X-  Left shift key down
          ---- -X--  Ctrl key down
          ---- X---  Alt key down
          ---X ----  Scroll lock on
          --X- ----  Num lock on
          -X-- ----  Caps lock on
          X--- ----  Insert on

Return Value
------------

Depends on COMMAND.

Example
-------

     while (!bioskey(1))
       do_stuff();


File: libc,  Node: biosmemory,  Next: biosprint,  Prev: bioskey,  Up: Alphabetical List

biosmemory
==========

Syntax
------

     #include <bios.h>
     
     unsigned biosmemory(void);

Description
-----------

This function returns the amount of system memory in 1k blocks.

Note that this function will return 65535 if the system has more than
64M of memory.  This is a limitation of the BIOS.

Return Value
------------

Bytes of memory / 1024.

Example
-------

     printf("This system has %d bytes of memory\n", biosmemory()*1024);


File: libc,  Node: biosprint,  Next: biostime,  Prev: biosmemory,  Up: Alphabetical List

biosprint
=========

Syntax
------

     #include <stdio.h>
     
     int biosprint(int cmd, int byte, int port)

Description
-----------

COMMAND = 0
     `byte' is sent to parallel port PORT.

COMMAND = 1
     Parallel port PORT is reset and initialized.

COMMAND = 2
     The status of parallel port PORT is returned.

          7654 3210  Meaning
          
          ---- ---X  Timeout
          ---- -XX-  Unused
          ---- X---  I/O Error
          ---X ----  Selected
          --X- ----  Out of paper
          -X-- ----  Acknowledged
          X--- ----  Idle

Return Value
------------

The printer status.

Example
-------

     while (*c)
       biosprint(0, *c++, 0);


File: libc,  Node: biostime,  Next: brk,  Prev: biosprint,  Up: Alphabetical List

biostime
========

Syntax
------

     #include <bios.h>
     
     long biostime(int cmd, long newtime);

Description
-----------

This function reads (CMD=0) or sets (CMD=1) the internal tick counter,
which is the number of 18.2 Hz ticks since midnight.

Return Value
------------

When reading, the number of ticks since midnight.

Example
-------

     long ticks = biostime(0, 0);


File: libc,  Node: brk,  Next: bsearch,  Prev: biostime,  Up: Alphabetical List

brk
===

Syntax
------

     #include <stdlib.h>
     
     int brk(void *ptr);

Description
-----------

This function changes the *break* for the program.  This is the first
address that, if referenced, will cause a fault to occur.  The program
asks for more memory by specifying larger values for PTR.  Normally,
this is done transparently through the `malloc' function.

Return Value
------------

zero if the break was changed, -1 if not.  ERRNO is set to the error.

Example
-------

     if (brk(old_brk+1000))
       printf("no memory\n");


File: libc,  Node: bsearch,  Next: bzero,  Prev: brk,  Up: Alphabetical List

bsearch
=======

Syntax
------

     #include <stdlib.h>
     
     void *bsearch (const void *key, const void *base, size_t num,
       size_t size, int (*ptf)(const void *ckey, const void *celem));

Description
-----------

Given an array of values, perform a binary search on the values looking
for value that "matches" the given key.  A match is determined by
calling the provided function PTF and passing it the key as CKEY and a
pointer to one of the elements of the array as CELEM.  This function
must return a negative number if the key is closer than the element to
the beginning of the array, positive if it is closer to the end, and
zero if the element matches the key.

The array begins at address BASE and contains NUM elements, each of
size SIZE.

Return Value
------------

Returns a pointer to the element that matches the key, else NULL.

Example
-------

     typedef struct {
       int a, b;
     } q;
     
     int compare(void *key, void *elem)
     {
       return *(int *)key - ((q *)elem)->a;
     }
     
     q qlist[100];
     
     ...
     q *match = bsearch(4, qlist, 100, sizeof(q), compare);
     printf("4->%d=n", match->b);
     ...


File: libc,  Node: bzero,  Next: calloc,  Prev: bsearch,  Up: Alphabetical List

bzero
=====

Syntax
------

     #include <string.h>
     
     void bzero(void *pointer, int length);

Description
-----------

The data at POINTER is filled with LENGTH zeros.

Return Value
------------

None.

Example
-------

     char foo[100];
     bzero(foo,100);


File: libc,  Node: calloc,  Next: ceil,  Prev: bzero,  Up: Alphabetical List

calloc
======

Syntax
------

     #include <malloc.h>
     
     void *calloc(size_t num_elements, size_t size);

Description
-----------

This function allocates enough memory for NUM_ELEMENTS objects of size
SIZE.  The memory returned is initialized to all zeros.  The pointer
returned should later be passed to free (*note free::.) so that the
memory can be returned to the heap.

You may use cfree (*note xfree::.) to free the pointer also; it just
calls free.

Return Value
------------

A pointer to the memory, or `NULL' if no more memory is available.

Example
-------

     Complex *x = calloc(12, sizeof(Complex));
     cfree(x);


File: libc,  Node: ceil,  Next: cfree,  Prev: calloc,  Up: Alphabetical List

ceil
====

Syntax
------

     #include <math.h>
     
     double ceil(double x);

Return Value
------------

The smallest integer value greater than or equal to X.


File: libc,  Node: cfree,  Next: cgets,  Prev: ceil,  Up: Alphabetical List

cfree
=====

Syntax
------

     #include <stdlib.h>
     
     void cfree(void *pointer);

Description
-----------

This function returns the memory allocated by calloc (*note calloc::.)
to the heap.

Return Value
------------

None.

Example
-------

     Complex *x = calloc(12, sizeof(Complex));
     cfree(x);


File: libc,  Node: cgets,  Next: chdir,  Prev: cfree,  Up: Alphabetical List

cgets
=====

Syntax
------

     #include <conio.h>
     
     char *cgets(char *_str);

Description
-----------

Get a string from the console.  This will take advantage of any
command-line editing TSRs.  To use, you must pre-fill the first
character of the buffer.  The first character is the size of the
buffer.  On return, the second character is the number of characters
read.  The third character is the first character read.

Return Value
------------

A pointer to the first character read.


File: libc,  Node: chdir,  Next: chmod,  Prev: cgets,  Up: Alphabetical List

chdir
=====

Syntax
------

     #include <unistd.h>
     
     int chdir(const char *new_directory);

Description
-----------

This function changes the current directory to NEW_DIRECTORY.  If a
drive letter is specified, the current directory for that drive is
changed and the current disk is set to that drive, else the current
directory for the current drive is changed.

Return Value
------------

Zero if the new directory exists, else nonzero and ERRNO set if error.

Example
-------

     if (chdir("/tmp"))
       perror("/tmp");


File: libc,  Node: chmod,  Next: _chmod,  Prev: chdir,  Up: Alphabetical List

chmod
=====

Syntax
------

     #include <sys/stat.h>
     
     int chmod(const char *path, mode_t mode);

Description
-----------

This function changes the mode (writable or write-only) of the specified
file.  The value of MODE can be a combination of one or more of the
following:

`S_IRUSR'
     Make the file readable

`S_IWUSR'
     Make the file writable

Other `S_I*' values could be included, but they will be ignored.

Return Value
------------

Zero if the file exists and the mode was changed, else nonzero.

Example
-------

     chmod("/tmp/dj.dat", S_IWUSR|S_IRUSR);


File: libc,  Node: _chmod,  Next: chown,  Prev: chmod,  Up: Alphabetical List

_chmod
======

Syntax
------

     #include <io.h>
     
     int _chmod(const char *filename, int func, mode_t mode);

Description
-----------

This is a direct connection to the MS-DOS chmod function call, int
0x21, %ax = 0x4300/0x4301.  If FUNC is 0, then DOS is called with AX =
0x4300, which returns an attribute byte of a file.  If FUNC is 1, then
the attributes of a file are set as specified in MODE.  Note that the
directory and volume attribute bits must always be 0 when `_chmod()' is
called with FUNC = 1, or else the call will fail.  The third argument
is optional when getting attributes.  The attribute bits are defined as
follows:

       Bit       Meaning
     76543210
     .......1    Read-only
     ......1.    Hidden
     .....1..    System
     ....1...    Volume Label
     ...1....    Directory
     ..1.....    Archive
     xx......    Reserved (used by some network redirectors)

Return Value
------------

If the file exists, `_chmod()' returns its attribute byte in case it
succeded, or -1 in case of failure.


File: libc,  Node: chown,  Next: chsize,  Prev: _chmod,  Up: Alphabetical List

chown
=====

Syntax
------

     #include <unistd.h>
     
     int chown(const char *file, int owner, int group);

Description
-----------

This function does nothing under MS-DOS

Return Value
------------

This function always returns zero if the file exists, else it returns
-1 and sets ERRNO to `ENOENT'.


File: libc,  Node: chsize,  Next: _clear87,  Prev: chown,  Up: Alphabetical List

chsize
======

Syntax
------

     #include <io.h>
     
     int chsize(int handle, long size);

Description
-----------

Just calls ftruncate (*note ftruncate::.).

Return Value
------------

Zero on success, -1 on failure.


File: libc,  Node: _clear87,  Next: clearerr,  Prev: chsize,  Up: Alphabetical List

_clear87
========

Syntax
------

     #include <float.h>
     
     unsigned int _clear87(void);

Description
-----------

Clears the floating point processor's exception flags.

Return Value
------------

The previous status word.


File: libc,  Node: clearerr,  Next: clock,  Prev: _clear87,  Up: Alphabetical List

clearerr
========

Syntax
------

     #include <stdio.h>
     
     void clearerr(FILE *stream);

Description
-----------

This function clears the EOF and error indicators for the file STREAM.

Return Value
------------

None.

Example
-------

     clearerr(stdout);


File: libc,  Node: clock,  Next: close,  Prev: clearerr,  Up: Alphabetical List

clock
=====

Syntax
------

     #include <time.h>
     
     clock_t clock(void);

Description
-----------

This function returns the number of clock ticks since an arbitrary time,
actually, since the first call to `clock', which itself returns zero.
The number of tics per second is CLOCKS_PER_SEC.

Return Value
------------

The number of tics.

Example
-------

     printf("%d seconds have elapsed\n", clock()/CLOCKS_PER_SEC);


File: libc,  Node: close,  Next: _close,  Prev: clock,  Up: Alphabetical List

close
=====

Syntax
------

     #include <unistd.h>
     
     int close(int fd);

Description
-----------

The open file associated with FD is closed.

Return Value
------------

Zero if the file was closed, nonzero if FD was invalid or already
closed.

Example
-------

     int fd = open("data", O_RDONLY);
     close(fd);


File: libc,  Node: _close,  Next: closedir,  Prev: close,  Up: Alphabetical List

_close
======

Syntax
------

     #include <io.h>
     
     int _close(int fd);

Description
-----------

This is a direct connection to the MS-DOS close function call, int
0x21, %ah = 0x3e.

Return Value
------------

Zero if the file was closed, else nonzero.


File: libc,  Node: closedir,  Next: clreol,  Prev: _close,  Up: Alphabetical List

closedir
========

Syntax
------

     #include <dirent.h>
     
     int closedir(DIR *dir);

Description
-----------

This function closes a directory opened by opendir (*note opendir::.).

Return Value
------------

Zero on success, nonzero if DIR is invalid.


File: libc,  Node: clreol,  Next: clrscr,  Prev: closedir,  Up: Alphabetical List

clreol
======

Syntax
------

     #include <conio.h>
     
     void clreol(void);

Description
-----------

Clear to end of line.

Return Value
------------

None.


File: libc,  Node: clrscr,  Next: _conio_kbhit,  Prev: clreol,  Up: Alphabetical List

clrscr
======

Syntax
------

     #include <conio.h>
     
     void clrscr(void);

Description
-----------

Clear the entire screen.


File: libc,  Node: _conio_kbhit,  Next: _control87,  Prev: clrscr,  Up: Alphabetical List

_conio_kbhit
============

Syntax
------

     #include <conio.h>
     
     int _conio_kbhit(void);

Description
-----------

Determines whether or not a character is waiting at the keyboard.  If
there is an ungetch'd character, this function returns true.  Note that
if you include `conio.h', the *Note kbhit:: function is redefined to be
this function instead.

Return Value
------------

Nonzero if a key is waiting, else zero.


File: libc,  Node: _control87,  Next: cos,  Prev: _conio_kbhit,  Up: Alphabetical List

_control87
==========

Syntax
------

     #include <float.h>
     
     unsigned int _control87(unsigned int newcw, unsigned int mask);

Description
-----------

Sets or resets bits in the FPU's control register.  The bits are
defined by macros in float.h, and by this table:

     ---- ---- --XX XXXX = MCW_EM - exception masks (1=handle exception internally, 0=fault)
     ---- ---- ---- ---X = EM_INVALID - invalid operation
     ---- ---- ---- --X- = EM_DENORMAL - denormal operand
     ---- ---- ---- -X-- = EM_ZERODIVIDE - divide by zero
     ---- ---- ---- X--- = EM_OVERFLOW - overflow
     ---- ---- ---X ---- = EM_UNDERFLOW - underflow
     ---- ---- --X- ---- = EM_INEXACT - rounding was required
     ---- --XX ---- ---- = MCW_PC - precision control
     ---- --00 ---- ---- = PC_24 - single precision
     ---- --10 ---- ---- = PC_53 - double precision
     ---- --11 ---- ---- = PC_64 - extended precision
     ---- XX-- ---- ---- = MCW_RC - rounding control
     ---- 00-- ---- ---- = RC_NEAR - round to nearest
     ---- 01-- ---- ---- = RC_DOWN - round towards -Inf
     ---- 10-- ---- ---- = RC_UP - round towards +Inf
     ---- 11-- ---- ---- = RC_CHOP - round towards zero
     ---X ---- ---- ---- = MCW_IC - infinity control (obsolete, always affine)
     ---0 ---- ---- ---- = IC_AFFINE - -Inf < +Inf
     ---1 ---- ---- ---- = IC_PROJECTIVE - -Inf == +Inf

Return Value
------------

The previous control word.


File: libc,  Node: cos,  Next: cosh,  Prev: _control87,  Up: Alphabetical List

cos
===

Syntax
------

     #include <math.h>
     
     double cos(double x);

Return Value
------------

The cosine of X.


File: libc,  Node: cosh,  Next: cprintf,  Prev: cos,  Up: Alphabetical List

cosh
====

Syntax
------

     #include <math.h>
     
     double cosh(double x);

Return Value
------------

The hyperbolic cosine of X.


File: libc,  Node: cprintf,  Next: cputs,  Prev: cosh,  Up: Alphabetical List

cprintf
=======

Syntax
------

     #include <conio.h>
     
     int cprintf(const char *_format, ...);

Description
-----------

Like `printf' (*note printf::.), but prints through the console, taking
into consideration window borders and text attributes.  There is
currently a 2048-byte limit on the size of each individual cprintf call.

Return Value
------------

The number of characters written.


File: libc,  Node: cputs,  Next: creat,  Prev: cprintf,  Up: Alphabetical List

cputs
=====

Syntax
------

     #include <conio.h>
     
     int cputs(const char *_str);

Description
-----------

Puts the string onto the console.  The cursor position is updated.

Return Value
------------

zero on success.


File: libc,  Node: creat,  Next: _creat,  Prev: cputs,  Up: Alphabetical List

creat
=====

Syntax
------

     #include <fcntl.h>
     #include <sys/stat.h> /* for mode definitions */
     
     int creat(const char *filename, mode_t mode);

Description
-----------

This function creates the given file and opens it for writing.  If the
file exists, it is truncated to zero size, unless it is read-only, in
which case the function fails.  If the file does not exist, it will be
created read-only if MODE does not have `S_IWUSR' set.

Return Value
------------

A file descriptor >= 0, or a negative number on error.

Example
-------

     int fd = creat("data", S_IRUSR|S_IWUSR);
     write(fd, buf, 1024);
     close(fd);


File: libc,  Node: _creat,  Next: crlf2nl,  Prev: creat,  Up: Alphabetical List

_creat
======

Syntax
------

     #include <io.h>
     
     int _creat(const char *path, int attrib);

Description
-----------

This is a direct connection to the MS-DOS creat function call, int
0x21, %ah = 0x3c.  The file is set to binary mode.

Return Value
------------

The new file descriptor, else -1 on error.


File: libc,  Node: crlf2nl,  Next: __crt0_glob_function,  Prev: _creat,  Up: Alphabetical List

crlf2nl
=======

Syntax
------

     size_t crlf2nl(char *buf, ssize_t len);

Description
-----------

This function removes Ctrl-M characters from the given BUF.

Return Value
------------

The number of characters remaining in the buffer are returned.


File: libc,  Node: __crt0_glob_function,  Next: __crt0_load_environment_file,  Prev: crlf2nl,  Up: Alphabetical List

__crt0_glob_function
====================

Syntax
------

     #include <crt0.h>
     
     char **__crt0_glob_function(char *_argument);

Description
-----------

If the application wishes to provide a wildcard expansion function, it
should define a __crt0_glob_function function.  It should return a list
of the expanded values, or 0 if no expansion will occur.  The startup
code will free the returned pointer if it is nonzero.

If no expander function is provided, wildcards will be expanded in the
POSIX.1 style.  To disable expansion, provide a __crt0_glob_function
that always returns 0.


File: libc,  Node: __crt0_load_environment_file,  Next: __crt0_setup_arguments,  Prev: __crt0_glob_function,  Up: Alphabetical List

__crt0_load_environment_file
============================

Syntax
------

     #include <crt0.h>
     
     void   __crt0_load_environment_file(char *_app_name);

Description
-----------

This function, provided by libc.a, does all the work required to load
additional environment variables from the file $DJGPP.  If the
application does not use environment variables, the programmer can
reduce the size of the program image by providing a version of this
function that does nothing.

*Note __crt0_setup_arguments::.


File: libc,  Node: __crt0_setup_arguments,  Next: _crt0_startup_flags,  Prev: __crt0_load_environment_file,  Up: Alphabetical List

__crt0_setup_arguments
======================

Syntax
------

     #include <crt0.h>
     
     void   __crt0_setup_arguments(void);

Description
-----------

This function, provided by libc.a, does all the work required to
provide the two arguments passed to main() (usually `argc' and `argv').
If main() does not use these arguments, the programmer can reduce the
size of the program image by providing a version of this function that
does nothing.

*Note __crt0_load_environment_file::.


File: libc,  Node: _crt0_startup_flags,  Next: cscanf,  Prev: __crt0_setup_arguments,  Up: Alphabetical List

_crt0_startup_flags
===================

Syntax
------

     #include <crt0.h>
     
     int _crt0_startup_flags = ...;

Description
-----------

This variable can be used to determine what the startup code will (or
will not) do when the program begins.  This can be used to tailor the
startup environment to a particular program.

`_CRT0_FLAG_PRESERVE_UPPER_CASE'
     If set, argv[0] is left in whatever case it was.  If not set, all
     characters are mapped to lower case.  Note that if the argv0 field
     in the stubinfo structure is present, the case of that part of
     argv0 is not affected.

`_CRT0_FLAG_USE_DOS_SLASHES'
     If set, reverse slashes (dos-style) are preserved in argv[0].  If
     not set, all reverse slashes are replaced with unix-style slashes.

`_CRT0_FLAG_DROP_EXE_SUFFIX'
     If set, the .EXE suffix is removed from the file name component of
     argv[0].  If not set, the suffix remains.

`_CRT0_FLAG_DROP_DRIVE_SPECIFIER'
     If set, the drive specifier (ex: `C:') is removed from the
     beginning of argv[0] (if present).  If not set, the drive
     specifier remains.

`_CRT0_FLAG_DISALLOW_RESPONSE_FILES'
     If set, response files (ex: @gcc.rf) are not expanded.  If not
     set, the contents of the response files are used to create
     arguments.  Note that if the file does not exist, that argument
     remains unexpanded.

`_CRT0_FLAG_FILL_SBRK_MEMORY'
     If set, fill sbrk()'d memory with a constant value.  If not, memory
     gets whatever happens to have been in there, which breaks some
     applications.

`_CRT0_FLAG_FILL_DEADBEEF'
     If set, fill memory (above) with 0xdeadbeef, else fill with zero.
     This is especially useful for debugging uninitialized memory
     problems.

`_CRT0_FLAG_NEARPTR'
     If set, set DS limit to 4GB which allows use of near pointers to
     DOS (and other) memory.  WARNING, disables memory protection and
     bad pointers may crash the machine or wipe out your data.

`_CRT0_FLAG_NULLOK'
     If set, disable NULL pointer protection (if it can be controlled
     at all).

`_CRT0_FLAG_NMI_SIGNAL'
     If set, enabled capture of NMI in exception code.  This may cause
     problems with laptops and "green" boxes which use it to wake up.
     Default is to leave NMIs alone and pass through to real mode code.
     You decide.

`_CRT0_FLAG_NO_LFN'
     If set, disable usage of long file name functions even on systems
     (such as Win95) which support them.  This might be needed to work
     around program assumptions on file name format on programs written
     specifically for DOS.

`_CRT0_FLAG_NONMOVE_SBRK'
     If set, the sbrk() algorithm used used multiple DPMI memory blocks
     which makes sure the base of CS/DS/SS does not change.  This may
     cause problems with sbrk(0) values and programs with other
     assumptions about sbrk behavior.  This flag is useful with near
     pointers, since a constant pointer to DOS/Video memory can be
     computed without needing to reload it after any routine which
     might call sbrk().

`_CRT0_FLAG_UNIX_SBRK'
     If set, the sbrk() algorithm used resizes memory blocks so that
     the layout of memory is set up to be the most compatible with unix
     sbrk() expectations.  This mode should not be used with hardware
     interrupts, near pointers, and may cause problems with QDPMI
     virtual memory.  If your program requires a specific sbrk()
     behavior, you should set one of these flags, since the default may
     change in different libc releases.

`_CRT0_FLAG_LOCK_MEMORY'
     If set, locks all memory as it is allocated.  This effectively
     disables virtual memory, and may be useful if using extensive
     hardware interrupt codes in a relatively small image size.  The
     memory is locked after it is sbrk()ed, so the locking may fail.
     This bit may be set or cleared during execution.  When sbrk() uses
     multiple memory zones, it can be difficult to lock all memory
     since the memory block size and location is impossible to
     determine.


File: libc,  Node: cscanf,  Next: ctime,  Prev: _crt0_startup_flags,  Up: Alphabetical List

cscanf
======

Syntax
------

     #include <conio.h>
     
     int cscanf(const char *_format, ...);

Description
-----------

Like `scanf' (*note scanf::.), but it reads from the keyboard directly.

Return Value
------------

The number of fields stored.


File: libc,  Node: ctime,  Next: delay,  Prev: cscanf,  Up: Alphabetical List

ctime
=====

Syntax
------

     #include <time.h>
     
     char *ctime(const time_t *cal);

Description
-----------

This function returns an ASCII representation of the time in CAL.  This
is equivalent to `asctime(localtime(cal))'.  *Note asctime::.  *Note
localtime::.

Return Value
------------

The ascii representation of the time.


File: libc,  Node: delay,  Next: delline,  Prev: ctime,  Up: Alphabetical List

delay
=====

Syntax
------

     void delay(unsigned msec);

Description
-----------

This function causes the program to pause for MSEC milliseconds.  It
uses the `int 15h' delay function to relinquish the CPU to other
programs that might need it.

Return Value
------------

None.

Example
-------

     delay(200); /* delay for 1/5 second */


File: libc,  Node: delline,  Next: difftime,  Prev: delay,  Up: Alphabetical List

delline
=======

Syntax
------

     #include <conio.h>
     
     void    delline(void);

Description
-----------

The line the cursor is on is deleted; lines below it scroll up.


File: libc,  Node: difftime,  Next: disable,  Prev: delline,  Up: Alphabetical List

difftime
========

Syntax
------

     #include <time.h>
     
     double difftime(time_t t1, time_t t0);

Description
-----------

This function returns the difference in time, in seconds, from T0 to T1.

Return Value
------------

The number of seconds.

Example
-------

     time_t t1, t0;
     double elapsed;
     time(&t0);
     do_something();
     time(&t1);
     elapsed = difftime(t1, t0);


File: libc,  Node: disable,  Next: div,  Prev: difftime,  Up: Alphabetical List

disable
=======

Syntax
------

     #include <dos.h>
     
     int disable(void);

Description
-----------

This function disables interrupts.

*Note enable::.

Return Value
------------

Returns nonzero if the interrupts had been enabled before this call,
zero if they were already disabled.

Example
-------

     int ints_were_enabled;
     
     ints_were_enabled = disable();
     . . . do some stuff . . .
     if (ints_were_enabled)
       enable();


File: libc,  Node: div,  Next: __djgpp_map_physical_memory,  Prev: disable,  Up: Alphabetical List

div
===

Syntax
------

     #include <stdlib.h>
     
     div_t div(int numberator, int denomonator);

Description
-----------

Returns the quotient and remainder of the division NUMBERATOR divided
by DENOMONATOR.  The return type is as follows:

     typedef struct {
       int quot;
       int rem;
     } div_t;

Return Value
------------

The results of the division are returned.

Example
-------

     div_t d = div(42, 3);
     printf("42 = %d x 3 + %d\n", d.quot, d.rem);
     
     div(+40, +3) = { +13, +1 }
     div(+40, -3) = { -13, -1 }
     div(-40, +3) = { -13, -1 }
     div(-40, -3) = { +13, -1 }


File: libc,  Node: __djgpp_map_physical_memory,  Next: __djgpp_memory_handle,  Prev: div,  Up: Alphabetical List

__djgpp_map_physical_memory
===========================

Syntax
------

     #include <dpmi.h>
     
     int __djgpp_map_physical_memory(void *our_addr, unsigned long num_bytes,
     			        unsigned long phys_addr);

Description
-----------

This function attempts to map a range of physical memory over the
specified addresses.  One common use of this routine is to map device
memory, such as a linear frame buffer, into the address space of the
calling program.  OUR_ADDR, NUM_BYTES, and PHYS_ADDR must be
page-aligned.  If they are not page-aligned, ERRNO will be set to
`EINVAL' and the routine will fail.

This routine properly handles memory ranges that span multiple DPMI
handles, while `__dpmi_map_device_in_memory_block' does not.

Consult DPMI documentation on function 0508H for details on how this
function works.  Note: since 0508H is a DPMI service new with DPMI 1.0,
this call will fail on most DPMI 0.9 servers.  For your program to work
on a wide range of systems, you should not assume this call will
succeed.

Even on failure, this routine may affect a subset of the pages
specified.

Return Value
------------

0 on success, -1 on failure.  On failure, ERRNO will be set to `EINVAL'
for illegal input parameters, or `EACCES' if the DPMI server rejected
the mapping request.

Example
-------

     if (__djgpp_map_physical_memory (my_page_aligned_memory, 16384, 0x40000000))
       printf ("Failed to map physical addresses!\n");


File: libc,  Node: __djgpp_memory_handle,  Next: __djgpp_memory_handle_list,  Prev: __djgpp_map_physical_memory,  Up: Alphabetical List

__djgpp_memory_handle
=====================

Syntax
------

     #include <crt0.h>
     
     __djgpp_sbrk_handle *__djgpp_memory_handle(unsigned address);

Description
-----------

This function returns a pointer to a structure containing the memory
handle and program relative offset associated with the address passed.
It is just a convenient way to process the __djgpp_memory_handle_list.

Return Value
------------

A pointer to the __djgpp_sbrk_handle associated with a particular
address.


File: libc,  Node: __djgpp_memory_handle_list,  Next: __djgpp_nearptr_disable,  Prev: __djgpp_memory_handle,  Up: Alphabetical List

__djgpp_memory_handle_list
==========================

Syntax
------

     #include <crt0.h>
     
     extern __djgpp_sbrk_handle __djgpp_memory_handle_list[256];

Description
-----------

This array contains a list of memory handles and program relative
offsets allocated by sbrk() in addition to the handle allocated by the
stub.  These values are normally not needed unless you are doing
low-level DPMI page protection or memory mapping.


File: libc,  Node: __djgpp_nearptr_disable,  Next: __djgpp_nearptr_enable,  Prev: __djgpp_memory_handle_list,  Up: Alphabetical List

__djgpp_nearptr_disable
=======================

Syntax
------

     #include <sys/nearptr.h>
     
     void __djgpp_nearptr_disable(void);

Description
-----------

This function disables near pointers, and re-enables protection.  *Note
__djgpp_nearptr_enable::.


File: libc,  Node: __djgpp_nearptr_enable,  Next: __djgpp_set_page_attributes,  Prev: __djgpp_nearptr_disable,  Up: Alphabetical List

__djgpp_nearptr_enable
======================

Syntax
------

     #include <sys/nearptr.h>
     
     int __djgpp_nearptr_enable(void);

Description
-----------

This function enables "near pointers" to be used to access the DOS
memory arena.  Sort of.  When you call this function, it will return
nonzero if it has successfully enabled near pointers.  If so, you must
add the value `__djgpp_conventional_base' to the linear address of the
physical memory.  For example:

     if (__djgpp_nearptr_enable())
     {
       short *screen = (short *)(__djgpp_conventional_base + 0xb8000);
       for (i=0; i<80*24*2; i++)
         screen[i] = 0x0720;
       __djgpp_nearptr_disable();
     }

The variable `__djgpp_base_address' contains the linear base address of
the application's data segment.  You can subtract this value from other
linear addresses that DPMI functions might return in order to obtain a
near pointer to those linear regions as well.

If using the Unix-like sbrk algorithm, near pointers are only valid
until the next `malloc', `system', `spawn*', or `exec*' function call,
since the linear base address of the application may be changed by
these calls.

WARNING: When you enable near pointers, you disable all the protection
that the system is providing.  If you are not careful, your application
may destroy the data in your computer.  USE AT YOUR OWN RISK!

Return Value
------------

Returns 0 if near pointers are not available, or nonzero if they are.


File: libc,  Node: __djgpp_set_page_attributes,  Next: _djstat_describe_lossage,  Prev: __djgpp_nearptr_enable,  Up: Alphabetical List

__djgpp_set_page_attributes
===========================

Syntax
------

     #include <dpmi.h>
     
     int __djgpp_set_page_attributes(void *our_addr, unsigned long num_bytes,
     			        unsigned short attributes);

Description
-----------

This function sets the DPMI page attributes for the pages in a range of
memory.  OUR_ADDR and NUM_BYTES must be page-aligned.  If they are not
page-aligned, ERRNO will be set to `EINVAL' and the routine will fail.

Consult DPMI documentation on function 0507H for the meaning of the
ATTRIBUTES argument.  Note: since 0507H is a DPMI service new with DPMI
1.0, this call will fail on most DPMI 0.9 servers.  For your program to
work on a wide range of systems, you should not assume this call will
succeed.

Even on failure, this routine may affect a subset of the pages
specified.

Return Value
------------

0 on success, -1 on failure.  On failure, ERRNO will be set to `EINVAL'
for illegal input parameters, or `EACCES' if the DPMI server rejected
the attribute setting.

Example
-------

     if (__djgpp_set_page_attributes (my_page_aligned_memory, 16384, 0))
       printf ("Failed to make pages uncommitted!\n");


File: libc,  Node: _djstat_describe_lossage,  Next: _djstat_fail_bits,  Prev: __djgpp_set_page_attributes,  Up: Alphabetical List

_djstat_describe_lossage
========================

Syntax
------

     #include <stdio.h>
     
     void _djstat_describe_lossage(FILE *fp);

Description
-----------

Accesses the global variable *Note _djstat_fail_bits:: and prints to the
stream given by FP a human-readable description of the undocumented DOS
features which the last call to `stat()' or `fstat()' failed to use.
(If FP is zero, the function prints to stderr.)  If the last call to
`f?stat()' didn't set any failure bits, an "all's well" message is
printed.  This function is designed to help in debugging these
functions in hostile environments (like DOS clones) and in adapting
them to the future DOS versions.  If you ever have any strange results
returned by `f?stat()', please call this function and post the
diagnostics it printed to the DJGPP mailing list.

The diagnostic messages this function prints are almost
self-explanatory.  Some explanations of terminology and abbreviations
used by the printed messages will further clarify them.

SDA (Swappable DOS Area) - this is an internal DOS structure.  `stat()'
uses it to get the full directory entry (including the starting cluster
number) of a file.  The pointer to SDA found by `stat()' is trusted
only if we find the pathname of our file at a specific offset in that
SDA.

SFT (System File Table) - another internal DOS structure, used in file
operations.  `fstat()' uses it to get full information on a file given
its handle.  An SFT entry which is found by `fstat()' is only trusted
if it contains files size and time stamp like those returned by DOS
functions 57h and 42h.  Novell NetWare 3.x traps DOS file operations in
such a way they never get to SFT, so some failure messages refer
specifically to Novell.

Hashing - the fall-back method of returning a unique inode number for
each file.  It is used whenever the starting cluster of a file couldn't
be reliably determined.

Return Value
------------

None.

Example
-------

       if (stat(path, &stat_buf))
         _djstat_describe_lossage((FILE *)0);


File: libc,  Node: _djstat_fail_bits,  Next: _djstat_flags,  Prev: _djstat_describe_lossage,  Up: Alphabetical List

_djstat_fail_bits
=================

Syntax
------

     #include <sys/stat.h>
     
     extern unsigned short   _djstat_fail_bits;

As proper operation of *Note stat:: and *Note fstat:: depend on
undocumented DOS features, they could fail in some incompatible
environment or a future DOS version.  If they do, the
`_djstat_fail_bits' variable will have some of its bits set.  Each bit
describes a single feature which was used and failed.  The function
*Note _djstat_describe_lossage:: may be called to print a
human-readable description of the bits which were set by the last call
to `f?stat()'.  This should make debugging `f?stat()' failures in an
unanticipated environment a lot easier.

The following bits are currently defined:

`_STFAIL_SDA'
     Indicates that Get SDA call failed.

`_STFAIL_OSVER'
     Indicates an unsupported DOS version (less than 3.10 for `stat()'
     or less than 2.0 for `fstat()').

`_STFAIL_BADSDA'
     The pointer to SDA was found to be bogus.

`_STFAIL_TRUENAME'
     Indicates that *Note _truename:: function call failed.

`_STFAIL_HASH'
     Indicates that the starting cluster of the file is unavailable,
     and inode number was computed by hashing its name.

`_STFAIL_LABEL'
     The application requested the time stamp of a root dir, but no
     volume label was found.

`_STFAIL_DCOUNT'
     The number of SDA reported is ridiculously large (probbaly an
     unsupported DOS clone).

`_STFAIL_WRITEBIT'
     `fstat()' was asked to get write access bit of a file, but
     couldn't.

`_STFAIL_DEVNO'
     `fstat()' failed to get device number.

`_STFAIL_BADSFT'
     An SFT entry for this file was found by `fstat()', but its contents
     can't be trusted because it didn't match file size and time stamp
     as reported by DOS.

`_STFAIL_SFTIDX'
     The SFT index in Job File Table in program's PSP is negative.

`_STFAIL_SFTNF'
     The file entry was not found in the SFT array.

Below are some explanations of terminology and abbreviations used by the
printed messages, which will further clarify the meaning of the above
bits and their descriptions printed by *Note _djstat_describe_lossage::.

SDA (Swappable DOS Area) - this is an internal DOS structure.  `stat()'
uses it to get the full directory entry (including the starting cluster
number) of a file.  The pointer to SDA found by `stat()' is trusted
only if we find the pathname of our file at a specific offset in that
SDA.

SFT (System File Table) - another internal DOS structure, used in file
operations.  `fstat()' uses it to get full information on a file given
its handle.  An SFT entry which is found by `fstat()' is only trusted
if it contains files size and time stamp like those returned by DOS
functions 57h and 42h.  Novell NetWare 3.x traps DOS file operations in
such a way they never get to SFT, so some failure messages refer
specifically to Novell.

Hashing - the fall-back method of returning a unique inode number for
each file.  It is used whenever the starting cluster of a file couldn't
be reliably determined.


File: libc,  Node: _djstat_flags,  Next: _doprnt,  Prev: _djstat_fail_bits,  Up: Alphabetical List

_djstat_flags
=============

Syntax
------

     #include <sys/stat.h>
     
     extern unsigned short   _djstat_flags;

This variable contains bits for some fields of struct stat which are
expensive to compute under DOS.  Any such computation is only done by
*Note stat:: or *Note fstat:: if the corresponding bit in
`_djstat_flags' is cleared.  By default, all the bits are cleared, so
applications which don't care, automagically get a full version,
possibly at a price of performance.  To get the fastest possible
`f?stat()' for your application, clear only the bits which you need and
set all the others.

The following bits are currently defined:

`_STAT_INODE'
     Causes `f?stat()' to compute the `st_ino' (inode number) field.

`_STAT_EXEC_EXT'
     Tells `f?stat()' to compute the execute access bit from extension.

`_STAT_EXEC_MAGIC'
     Tells `f?stat()' to compute the execute access bit from magic
     signature (the first two bytes of the file, see *Note
     _is_executable::.  Note that if _STAT_EXEC_MAGIC is set, but
     _STAT_EXEC_EXT is not, some files which shouldn't be flagged as
     executables (e.g., COFF *.o object files) will have their execute
     bit set, because they have the magic number signature at their
     beginning.  Therefore, only use the above combination if you want
     to debug the list of extensions provided in is_exec.c file.

`_STAT_DIRSIZE'
     Causes `stat' to compute directory size by counting the number of
     its entries (unless some friendly network redirector brought a
     true directory size with it).

`_STAT_ROOT_TIME'
     Causes `stat()' to try to get time stamp of root directory from its
     volume label entry, if there is one.

`_STAT_WRITEBIT'
     Tells `fstat()' that file's write access bit is required (this
     could be a problem only under some versions of Novell Netware).

Note that if you set a bit, some failure bits in *Note
_djstat_fail_bits:: might not be set, because some computations which
report failures are only done when they are required.


File: libc,  Node: _doprnt,  Next: _dos_close,  Prev: _djstat_flags,  Up: Alphabetical List

_doprnt
=======

Syntax
------

     #include <stdio.h>
     
     int _doprnt(const char *format, void *params, FILE *file);

Description
-----------

This is an internal function that is used by all the `printf' style
functions, which simply pass their format, arguments, and stream to this
function.

*Note printf:: for a discussion of the allowed formats and arguments.

Return Value
------------

The number of characters generated is returned.

Example
-------

     int args[] = { 1, 2, 3, 66 };
     _doprnt("%d %d %d %c\n", args, stdout);


File: libc,  Node: _dos_close,  Next: _dos_commit,  Prev: _doprnt,  Up: Alphabetical List

_dos_close
==========

Syntax
------

     #include <dos.h>
     
     unsigned int _dos_close(int handle);

Description
-----------

This is a direct connection to the MS-DOS close function call (%ah =
0x3E).  This function closes the specified file.

*Note _dos_open::. *Note _dos_creat::. *Note _dos_creatnew::.  *Note
_dos_read::. *Note _dos_write::.

Return Value
------------

Returns 0 if successful or DOS error code on error (and sets ERRNO).

Example
-------

     int handle;
     
     _dos_creat("FOO.DAT", _A_ARCH, &handle);
     ...
     _dos_close(handle);


File: libc,  Node: _dos_commit,  Next: _dos_creat,  Prev: _dos_close,  Up: Alphabetical List

_dos_commit
===========

Syntax
------

     #include <dos.h>
     
     unsigned int _dos_commit(int handle);

Description
-----------

This is a direct connection to the MS-DOS commit function call (%ah =
0x68).  This function flushes DOS internal file buffers to disk.

Return Value
------------

Returns 0 if successful or DOS error code on error (and sets ERRNO).

Example
-------

     _dos_write(handle, buffer, 1000, &result);
     _dos_commit(handle);
     _dos_close(handle);


File: libc,  Node: _dos_creat,  Next: _dos_creatnew,  Prev: _dos_commit,  Up: Alphabetical List

_dos_creat
==========

Syntax
------

     #include <dos.h>
     
     unsigned int _dos_creat(const char *filename, unsigned short attr, int *handle);

Description
-----------

This is a direct connection to the MS-DOS creat function call (%ah =
0x3C).  This function creates the given file with the given attribute
and puts file handle into HANDLE if creating is successful. If the file
already exists it truncates the file to zero length. Meaning of ATTR
parameter is the following:

`_A_NORMAL (0x00)'
     Normal file (no read/write restrictions)

`_A_RDONLY (0x01)'
     Read only file

`_A_HIDDEN (0x02)'
     Hidden file

`_A_SYSTEM (0x04)'
     System file

`_A_ARCH (0x20)'
     Archive file

*Note _dos_open::. *Note _dos_creatnew::. *Note _dos_read::.  *Note
_dos_write::. *Note _dos_close::

Return Value
------------

Returns 0 if successful or DOS error code on error (and sets ERRNO)

Example
-------

     int handle;
     
     if ( !_dos_creat("FOO.DAT", _A_ARCH, &handle) )
        puts("Creating was successful !");


File: libc,  Node: _dos_creatnew,  Next: _dos_findfirst,  Prev: _dos_creat,  Up: Alphabetical List

_dos_creatnew
=============

Syntax
------

     #include <dos.h>
     
     unsigned int _dos_creatnew(const char *filename, unsigned short attr, int *handle);

Description
-----------

This is a direct connection to the MS-DOS create unique function call
(%ah = 0x5B). This function creates the given file with the given
attribute and puts file handle into HANDLE if creating is successful.
This function will fail if the specified file exists. Meaning of ATTR
parameter is the following:

`_A_NORMAL (0x00)'
     Normal file (no read/write restrictions)

`_A_RDONLY (0x01)'
     Read only file

`_A_HIDDEN (0x02)'
     Hidden file

`_A_SYSTEM (0x04)'
     System file

`_A_ARCH (0x20)'
     Archive file

*Note _dos_open::. *Note _dos_creat::. *Note _dos_read::.  *Note
_dos_write::. *Note _dos_close::

Return Value
------------

Returns 0 if successful or DOS error code on error (and sets ERRNO).

Example
-------

     int handle;
     
     if ( !_dos_creatnew("FOO.DAT", _A_NORMAL, &handle) )
        puts("Creating was successful !");


File: libc,  Node: _dos_findfirst,  Next: _dos_findnext,  Prev: _dos_creatnew,  Up: Alphabetical List

_dos_findfirst
==============

Syntax
------

     #include <dos.h>
     
     unsigned int _dos_findfirst(char *name, unsigned int attr, struct find_t *result);

Description
-----------

This function and the related `_dos_findnext' (*note _dos_findnext::.)
are used to scan directories for the list of files therein. The NAME is
a wildcard that specifies the directory and files to search. RESULT is
a structure to hold the results and state of the search, and ATTR is a
combination of the following:

`_A_NORMAL (0x00)'
     Normal file (no read/write restrictions)

`_A_RDONLY (0x01)'
     Read only file

`_A_HIDDEN (0x02)'
     Hidden file

`_A_SYSTEM (0x04)'
     System file

`_A_VOLID (0x08)'
     Volume ID file

`_A_SUBDIR (0x10)'
     Subdirectory

`_A_ARCH (0x20)'
     Archive file

*Note _dos_findnext::.

Return Value
------------

Zero if a match is found, DOS error code if not found (and sets ERRNO).

Example
-------

     struct find_t f;
     
     if ( !_dos_findfirst("*.DAT", &result, _A_ARCH | _A_RDONLY) )
     {
       do
       {
         printf("%-14s %10u %02u:%02u:%02u %02u/%02u/%04u\n",
                f.name,
                f.size,
                (f.wr_time >> 11) & 0x1f,
                (f.wr_time >>  5) & 0x3f,
                (f.wr_time & 0x1f) * 2,
                (f.wr_date >>  5) & 0x0f,
                (f.wr_date & 0x1f),
                ((f.wr_date >> 9) & 0x7f) + 1980,
       } while( !_dos_findnext(&f) );
     }


File: libc,  Node: _dos_findnext,  Next: _dos_getdate,  Prev: _dos_findfirst,  Up: Alphabetical List

_dos_findnext
=============

Syntax
------

     #include <dos.h>
     
     unsigned int _dos_findnext(struct _find_t *result);

Description
-----------

This finds the next file in the search started by `_dos_findfirst'.

*Note _dos_findfirst::.

Return Value
------------

Zero if a match is found, DOS error code if not found (and sets ERRNO).


File: libc,  Node: _dos_getdate,  Next: _dos_getdiskfree,  Prev: _dos_findnext,  Up: Alphabetical List

_dos_getdate
============

Syntax
------

     #include <dos.h>
     
     void _dos_getdate(struct dosdate_t *date);

Description
-----------

This function gets the current date and fills the DATE structure with
these values.

     struct dosdate_t {
       unsigned char  day;       /* 1-31          */
       unsigned char  month;     /* 1-12          */
       unsigned short year;      /* 1980-2099     */
       unsigned char  dayofweek; /* 0-6, 0=Sunday */
     };

*Note _dos_setdate::. *Note _dos_gettime::. *Note _dos_settime::.

Return Value
------------

None.

Example
-------

     struct dosdate_t date;
     
     _dos_getdate(&date);


File: libc,  Node: _dos_getdiskfree,  Next: _dos_getdrive,  Prev: _dos_getdate,  Up: Alphabetical List

_dos_getdiskfree
================

`_dos_getdiskfree'
==================

Syntax
------

     #include <dos.h>
     
     unsigned int _dos_getdiskfree(unsigned int drive, struct diskfree_t *diskspace);

Description
-----------

This function determines the free space on DRIVE drive (0=default,
1=A:, 2=B:, etc.) and fills DISKSPACE structure.

Return Value
------------

Returns with 0 if successful and non-zero on error (sets ERRNO=EINVAL).

Example
-------

     struct diskfree_t df;
     unsigned long freebytes;
     
     if ( !_dos_getdiskfree(0, &df) )
     {
       freebytes = (unsigned long)df.avail_clusters *
                   (unsigned long)df.bytes_per_sector *
                   (unsigned long)df.sectors_per_cluster;
       printf("There is %lu free bytes on the current drive.\n", freebytes);
     }
     else
       printf("Unable to get free disk space.\n");


File: libc,  Node: _dos_getdrive,  Next: _dos_getfileattr,  Prev: _dos_getdiskfree,  Up: Alphabetical List

_dos_getdrive
=============

`_dos_getdrive'
===============

Syntax
------

     #include <dos.h>
     
     void _dos_getdrive(unsigned int *p_drive);

Description
-----------

This function determine the current default drive and writes this value
into P_DRIVE (1=A:, 2=B:, etc.).

*Note _dos_setdrive::.

Return Value
------------

None.

Example
-------

     unsigned int drive;
     
     _dos_getdrive(&drive);
     printf("The current drive is %c:.\n", 'A' - 1 + drive);


File: libc,  Node: _dos_getfileattr,  Next: _dos_getftime,  Prev: _dos_getdrive,  Up: Alphabetical List

_dos_getfileattr
================

`_dos_getfileattr'
==================

Syntax
------

     #include <dos.h>
     
     unsigned int _dos_getfileattr(const char *filename, unsigned int *p_attr);

Description
-----------

This function determines the attributes of given file and fills ATTR
with it. Use the following constans (in DOS.H) to check this value.

`_A_NORMAL (0x00)'
     Normal file (no read/write restrictions)

`_A_RDONLY (0x01)'
     Read only file

`_A_HIDDEN (0x02)'
     Hidden file

`_A_SYSTEM (0x04)'
     System file

`_A_VOLID (0x08)'
     Volume ID file

`_A_SUBDIR (0x10)'
     Subdirectory

`_A_ARCH (0x20)'
     Archive file

*Note _dos_setfileattr::.

Return Value
------------

Returns with 0 if successful and DOS error value on error (and sets
ERRNO=ENOENT).

Example
-------

     unsigned int attr;
     
     if ( !_dos_getfileattr("FOO.DAT", &attr) )
     {
       puts("FOO.DAT attributes are:");
       if ( attr & _A_ARCH )   puts("Archive");
       if ( attr & _A_RDONLY ) puts("Read only");
       if ( attr & _A_HIDDEN ) puts("Hidden");
       if ( attr & _A_SYSTEM ) puts("Is it part of DOS ?");
       if ( attr & _A_VOLID )  puts("Volume ID");
       if ( attr & _A_SUBDIR ) puts("Directory");
     }
     else
       puts("Unable to get FOO.DAT attributes.");


File: libc,  Node: _dos_getftime,  Next: _dos_gettime,  Prev: _dos_getfileattr,  Up: Alphabetical List

_dos_getftime
=============

Syntax
------

     #include <dos.h>
     
     unsigned int _dos_getftime(int handle, unsigned int *p_date, unsigned *p_time);

Description
-----------

This function gets the date and time of the given file and puts these
values into P_DATE and P_TIME variable. The meaning of DOS date in the
P_DATE variable is the following:

     F   E   D   C   B   A   9   8   7   6   5   4   3   2   1   0  (bits)
     X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X
     *-----------------------*   *-----------*   *---------------*
             year                    month              day
     
     year  = 0-119 (relative to 1980)
     month = 1-12
     day   = 1-31

The meaning of DOS time in the P_TIME variable is the following:

     F   E   D   C   B   A   9   8   7   6   5   4   3   2   1   0
     X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X
     *---------------*   *-------------------*   *---------------*
           hours              minutes                seconds
     
     hours   = 0-23
     minutes = 0-59
     seconds = 0-29 in two-second intervals

*Note _dos_setftime::.

Return Value
------------

Returns 0 if successful and return DOS error on error (and sets
ERRNO=EBADF).

Example
-------

     unsigned int handle, date, time;
     
     _dos_open("FOO.DAT", O_RDWR, &handle);
     _dos_gettime(handle, &date, &time);
     _dos_close(handle);
     printf("FOO.DAT date and time is: %04u-%02u-%02u %02u:%02u:%02u.\n",
            /*       year                      month              day    */
            ((date >> 9) & 0x7F) + 1980U, (date >>  5) & 0x0F, date & 0x1F,
            /*       hour                minute           second         */
            (time >> 11) & 0x1F, (time >>  5) & 0x3F, (time & 0x1F) * 2);


File: libc,  Node: _dos_gettime,  Next: _dos_lock,  Prev: _dos_getftime,  Up: Alphabetical List

_dos_gettime
============

Syntax
------

     #include <dos.h>
     
     void _dos_gettime(struct dostime_t *time);

Description
-----------

This function gets the current time and fills the TIME structure with
these values.

     struct dostime_t {
       unsigned char hour;     /* 0-23 */
       unsigned char minute;   /* 0-59 */
       unsigned char second;   /* 0-59 */
       unsigned char hsecond;  /* 0-99 */
     };

*Note _dos_settime::. *Note _dos_getdate::. *Note _dos_setdate::.

Return Value
------------

None.

Example
-------

     struct dostime_t time;
     
     _dos_gettime(&time);


File: libc,  Node: _dos_lock,  Next: _dos_open,  Prev: _dos_gettime,  Up: Alphabetical List

_dos_lock
=========

Syntax
------

     #include <io.h>
     
     _dos_lock(int _fd, long _offset, long _length)

Description
-----------

Adds an advisory lock to the specified region of the file.

Return Value
------------

Zero if the lock was added, nonzero otherwise.


File: libc,  Node: _dos_open,  Next: _dos_read,  Prev: _dos_lock,  Up: Alphabetical List

_dos_open
=========

Syntax
------

     #include <fcntl.h>
     #include <share.h>
     #include <dos.h>
     
     unsigned int _dos_open(const char *filename, unsigned short mode, int *handle);

Description
-----------

This is a direct connection to the MS-DOS open function call (%ah =
0x3D).  This function opens the given file with the given mode and puts
handle of file into HANDLE if openning is successful.  Meaning of MODE
parameter is the following:

Access mode bits (in FCNTL.H):
`O_RDONLY (_O_RDONLY) 0x00'
     Open for read only

`O_WRONLY (_O_WRONLY) 0x01'
     Open for write only

`O_RDWR (_O_RDWR) 0x02'
     Open for read and write

Sharing mode bits (in SHARE.H):
`SH_COMPAT (_SH_COMPAT) 0x00'
     Compatibility mode

`SH_DENYRW (_SH_DENYRW) 0x10'
     Deny read/write mode

`SH_DENYWR (_SH_DENYWR) 0x20'
     Deny write mode

`SH_DENYRD (_SH_DENYRD) 0x30'
     Deny read mode

`SH_DENYNO (_SH_DENYNO) 0x40'
     Deny none mode

Inheritance bits (in FCNTL.H):
`O_NOINHERIT (_O_NOINHERIT) 0x80'
     File is not inherited by child process

*Note _dos_creat::. *Note _dos_creatnew::. *Note _dos_read::.  *Note
_dos_write::. *Note _dos_close::

Return Value
------------

Returns 0 if successful or DOS error code on error (and sets ERRNO to
EACCES, EINVAL, EMFILE or ENOENT).

Example
-------

     int handle;
     
     if ( !_dos_open("FOO.DAT", O_RDWR, &handle) )
        puts("Wow, file opening was successful !");


File: libc,  Node: _dos_read,  Next: _dos_setdate,  Prev: _dos_open,  Up: Alphabetical List

_dos_read
=========

Syntax
------

     #include <dos.h>
     
     unsigned int _dos_read(int handle, void *buffer, unsigned int count, unsigned int *result);

Description
-----------

This is a direct connection to the MS-DOS read function call (%ah =
0x3F).  No conversion is done on the data; it is read as raw binary
data. This function reads from HANDLE into BUFFER COUNT bytes.  COUNT
value may be arbitrary size (for example > 64KB). It puts number of
bytes read into RESULT if reading is successful.

*Note _dos_open::. *Note _dos_creat::. *Note _dos_creatnew::.  *Note
_dos_write::. *Note _dos_close::

Return Value
------------

Returns 0 if successful or DOS error code on error (and sets ERRNO to
EACCES or EBADF)

Example
-------

     int handle;
     unsigned int result;
     char *filebuffer;
     
     if ( !_dos_open("FOO.DAT", O_RDONLY, &handle) )
     {
        puts("FOO.DAT openning was successful.");
        if ( (filebuffer = malloc(130000)) != NULL )
        {
          if ( !_dos_read(handle, buffer, 130000, &result) )
            printf("%u bytes read from FOO.DAT.\n", result);
          else
            puts("Reading error.");
          ...
          /* Do something with filebuffer. */
          ...
        }
        _dos_close(handle);
     }


File: libc,  Node: _dos_setdate,  Next: _dos_setdrive,  Prev: _dos_read,  Up: Alphabetical List

_dos_setdate
============

Syntax
------

     #include <dos.h>
     
     unsigned int _dos_setdate(struct dosdate_t *date);

Description
-----------

This function sets the current date. The DOSDATE_T structure is as
follows:

     struct dosdate_t {
       unsigned char  day;       /* 1-31          */
       unsigned char  month;     /* 1-12          */
       unsigned short year;      /* 1980-2099     */
       unsigned char  dayofweek; /* 0-6, 0=Sunday */
     };

DAYOFWEEK field has no effect at this function call.

*Note _dos_getdate::. *Note _dos_gettime::. *Note _dos_settime::.

Return Value
------------

Returns 0 if successful and non-zero on error (and sets ERRNO=EINVAL).

Example
-------

     struct dosdate_t date;
     
     date->year  = 1999;
     date->month = 12;
     date->day   = 31;
     if ( !_dos_setdate(&date) )
       puts("It was a valid date.");


File: libc,  Node: _dos_setdrive,  Next: _dos_setfileattr,  Prev: _dos_setdate,  Up: Alphabetical List

_dos_setdrive
=============

`_dos_setdrive'
===============

Syntax
------

     #include <dos.h>
     
     void _dos_setdrive(unsigned int drive, unsigned int *p_drives);

Description
-----------

This function set the current default drive based on DRIVE (1=A:, 2=B:,
etc.) and determines the number of available logical drives and fills
P_DRIVES with it.

*Note _dos_getdrive::.

Return Value
------------

None.

Example
-------

     unsigned int available_drives;
     
     /* The current drive will be A: */
     _dos_setdrive(1, &available_drives);
     printf("Number of available logical drives %u.\n", available_drives);


File: libc,  Node: _dos_setfileattr,  Next: _dos_setftime,  Prev: _dos_setdrive,  Up: Alphabetical List

_dos_setfileattr
================

`_dos_setfileattr'
==================

Syntax
------

     #include <dos.h>
     
     unsigned int _dos_setfileattr(const char *filename, unsigned int attr);

Description
-----------

This function sets the attributes of given file. Use the following
constans in DOS.H to create ATTR parameter:

`_A_NORMAL (0x00)'
     Normal file (no read/write restrictions)

`_A_RDONLY (0x01)'
     Read only file

`_A_HIDDEN (0x02)'
     Hidden file

`_A_SYSTEM (0x04)'
     System file

`_A_VOLID (0x08)'
     Volume ID file

`_A_SUBDIR (0x10)'
     Subdirectory

`_A_ARCH (0x20)'
     Archive file

*Note _dos_getfileattr::.

Return Value
------------

Returns with 0 if successful and DOS error value on error (and sets
ERRNO to ENOENT or EACCES).

Example
-------

     if ( !_dos_setfileattr("FOO.DAT", _A_RDONLY | _A_HIDDEN) )
        puts("FOO.DAT is hidden now.");


File: libc,  Node: _dos_setftime,  Next: _dos_settime,  Prev: _dos_setfileattr,  Up: Alphabetical List

_dos_setftime
=============

Syntax
------

     #include <dos.h>
     
     unsigned int _dos_setftime(int handle, unsigned int date, unsigned time);

Description
-----------

This function sets the date and time of the given file. The meaning of
DOS date in the DATE variable is the following:

     F E D C B A 9 8 7 6 5 4 3 2 1 0 (bits)
     x x x x x x x x x x x x x x x x
     *-----------* *-----* *-------*
         year       month     day
     
     year  = 0-119 (relative to 1980)
     month = 1-12
     day   = 1-31

The meaning of DOS time in the TIME variable is the following:

     F E D C B A 9 8 7 6 5 4 3 2 1 0 (bits)
     x x x x x x x x x x x x x x x x
     *-------* *---------* *-------*
       hours     minutes    seconds
     
     hours   = 0-23
     minutes = 0-59
     seconds = 0-29 in two-second intervals

*Note _dos_getftime::.

Return Value
------------

Returns 0 if successful and return DOS error on error (and sets
ERRNO=EBADF).

Example
-------

     struct dosdate_t d;
     struct dostime_t t;
     unsigned int handle, date, time;
     
     _dos_open("FOO.DAT", O_RDWR, &handle);
     _dos_getdate(&d);
     _dos_gettime(&t);
     date = ((d.year - 1980) << 9) | (d.month << 5) | d.day;
     time = (t.hour << 11) | (t.minute << 5) | (t.second / 2);
     _dos_settime(handle, date, time);
     _dos_close(handle);


File: libc,  Node: _dos_settime,  Next: _dos_unlock,  Prev: _dos_setftime,  Up: Alphabetical List

_dos_settime
============

Syntax
------

     #include <dos.h>
     
     void _dos_settime(struct dostime_t *time);

Description
-----------

This function sets the current time. The TIME structure is as follows:

     struct dostime_t {
       unsigned char hour;     /* 0-23 */
       unsigned char minute;   /* 0-59 */
       unsigned char second;   /* 0-59 */
       unsigned char hsecond;  /* 0-99 */
     };

*Note _dos_gettime::. *Note _dos_getdate::. *Note _dos_setdate::.

Return Value
------------

Returns 0 if successful and non-zero on error (and sets ERRNO=EINVAL).

Example
-------

     struct dostime_t time;
     
     time->hour    = 23;
     time->minute  = 59;
     time->second  = 59;
     time->hsecond = 99;
     if ( !_dos_settime(&time) )
       puts("It was a valid time.");


File: libc,  Node: _dos_unlock,  Next: _dos_write,  Prev: _dos_settime,  Up: Alphabetical List

_dos_unlock
===========

Syntax
------

     #include <io.h>
     
     _dos_unlock(int _fd, long _offset, long _length)

Description
-----------

Removes an advisory lock to the specified region of the file.

Return Value
------------

Zero if the lock was removed, nonzero otherwise.


File: libc,  Node: _dos_write,  Next: _doscan,  Prev: _dos_unlock,  Up: Alphabetical List

_dos_write
==========

Syntax
------

     #include <dos.h>
     
     unsigned int _dos_write(int handle, const void *buffer, unsigned int count,
                             unsigned int *result);

Description
-----------

This is a direct connection to the MS-DOS write function call (%ah =
0x40).  No conversion is done on the data; it is written as raw binary
data. This function writes COUNT bytes from BUFFER to HANDLE.  COUNT
value may be arbitrary size (e.g. > 64KB). It puts number of bytes
written into RESULT if writing is successful.

*Note _dos_open::. *Note _dos_creat::. *Note _dos_creatnew::.  *Note
_dos_read::. *Note _dos_close::

Return Value
------------

Returns 0 if successful or DOS error code on error (and sets ERRNO to
EACCES or EBADF)

Example
-------

     int handle;
     unsigned int result;
     char *filebuffer;
     
     if ( !_dos_creat("FOO.DAT", _A_ARCH, &handle) )
     {
        puts("FOO.DAT creating was successful.");
        if ( (filebuffer = malloc(130000)) != NULL )
        {
          ...
          /* Put something into filebuffer. */
          ...
          if ( !_dos_write(handle, buffer, 130000, &result) )
            printf("%u bytes written into FOO.DAT.", result);
          else
            puts("Writing error.");
        }
        _dos_close(handle);
     }


File: libc,  Node: _doscan,  Next: dosexterr,  Prev: _dos_write,  Up: Alphabetical List

_doscan
=======

Syntax
------

     #include <stdio.h>
     
     int _doscan(FILE *file, const char *format, void **ptrs_to_args);

Description
-----------

This is an internal function that is used by all the `scanf' style
functions, which simply pass their format, arguments, and stream to this
function.

*Note scanf:: for a discussion of the allowed formats and arguments.

Return Value
------------

The number of characters successfully scanned is returned, or -1 on
error.

Example
-------

     int x, y;
     int *args[2];
     args[0] = &x;
     args[1] = &y;
     _doscan(stdin, "%d %d", args);


File: libc,  Node: dosexterr,  Next: dosmemget,  Prev: _doscan,  Up: Alphabetical List

dosexterr
=========

Syntax
------

     #include <dos.h>
     
     int dosexterr(struct DOSERROR *p_error);

Description
-----------

This function reads extended error information from DOS and fills
P_ERROR structure.

     struct _DOSERROR {
       int  exterror;
       char class;
       char action;
       char locus;
     };

Values for extended error code (EXTERROR field):
     00h (0)   no error
     01h (1)   function number invalid
     02h (2)   file not found
     03h (3)   path not found
     04h (4)   too many open files (no handles available)
     05h (5)   access denied
     06h (6)   invalid handle
     07h (7)   memory control block destroyed
     08h (8)   insufficient memory
     09h (9)   memory block address invalid
     0Ah (10)  environment invalid (usually >32K in length)
     0Bh (11)  format invalid
     0Ch (12)  access code invalid
     0Dh (13)  data invalid
     0Eh (14)  reserved
     0Fh (15)  invalid drive
     10h (16)  attempted to remove current directory
     11h (17)  not same device
     12h (18)  no more files
     13h (19)  disk write-protected
     14h (20)  unknown unit
     15h (21)  drive not ready
     16h (22)  unknown command
     17h (23)  data error (CRC)
     18h (24)  bad request structure length
     19h (25)  seek error
     1Ah (26)  unknown media type (non-DOS disk)
     1Bh (27)  sector not found
     1Ch (28)  printer out of paper
     1Dh (29)  write fault
     1Eh (30)  read fault
     1Fh (31)  general failure
     20h (32)  sharing violation
     21h (33)  lock violation
     22h (34)  disk change invalid (ES:DI -> media ID structure)(see below)
     23h (35)  FCB unavailable
     24h (36)  sharing buffer overflow
     25h (37)  (DOS 4+) code page mismatch
     26h (38)  (DOS 4+) cannot complete file operation (out of input)
     27h (39)  (DOS 4+) insufficient disk space
     28h-31h   reserved
     32h (50)  network request not supported
     33h (51)  remote computer not listening
     34h (52)  duplicate name on network
     35h (53)  network name not found
     36h (54)  network busy
     37h (55)  network device no longer exists
     38h (56)  network BIOS command limit exceeded
     39h (57)  network adapter hardware error
     3Ah (58)  incorrect response from network
     3Bh (59)  unexpected network error
     3Ch (60)  incompatible remote adapter
     3Dh (61)  print queue full
     3Eh (62)  queue not full
     3Fh (63)  not enough space to print file
     40h (64)  network name was deleted
     41h (65)  network: Access denied
     42h (66)  network device type incorrect
     43h (67)  network name not found
     44h (68)  network name limit exceeded
     45h (69)  network BIOS session limit exceeded
     46h (70)  temporarily paused
     47h (71)  network request not accepted
     48h (72)  network print/disk redirection paused
     49h (73)  network software not installed
               (LANtastic) invalid network version
     4Ah (74)  unexpected adapter close
               (LANtastic) account expired
     4Bh (75)  (LANtastic) password expired
     4Ch (76)  (LANtastic) login attempt invalid at this time
     4Dh (77)  (LANtastic v3+) disk limit exceeded on network node
     4Eh (78)  (LANtastic v3+) not logged in to network node
     4Fh (79)  reserved
     50h (80)  file exists
     51h (81)  reserved
     52h (82)  cannot make directory
     53h (83)  fail on INT 24h
     54h (84)  (DOS 3.3+) too many redirections
     55h (85)  (DOS 3.3+) duplicate redirection
     56h (86)  (DOS 3.3+) invalid password
     57h (87)  (DOS 3.3+) invalid parameter
     58h (88)  (DOS 3.3+) network write fault
     59h (89)  (DOS 4+) function not supported on network
     5Ah (90)  (DOS 4+) required system component not installed
     64h (100) (MSCDEX) unknown error
     65h (101) (MSCDEX) not ready
     66h (102) (MSCDEX) EMS memory no longer valid
     67h (103) (MSCDEX) not High Sierra or ISO-9660 format
     68h (104) (MSCDEX) door open

Values for error class (CLASS field):
     01h  out of resource (storage space or I/O channels)
     02h  temporary situation (file or record lock)
     03h  authorization (denied access)
     04h  internal (system software bug)
     05h  hardware failure
     06h  system failure (configuration file missing or incorrect)
     07h  application program error
     08h  not found
     09h  bad format
     0Ah  locked
     0Bh  media error
     0Ch  already exists
     0Dh  unknown

Values for suggested action (ACTION field):
     01h  retry
     02h  delayed retry
     03h  prompt user to reenter input
     04h  abort after cleanup
     05h  immediate abort
     06h  ignore
     07h  retry after user intervention

Values for error locus (LOCUS field):
     01h  unknown or not appropriate
     02h  block device (disk error)
     03h  network related
     04h  serial device (timeout)
     05h  memory related

Return Value
------------

Returns with the extended error code.

Example
-------

     #include <stdio.h>
     #include <dos.h>
     
     void main(void)
     {
       FILE *fp;
       struct _DOSERROR de;
     
       fp = fopen("EXAMPLE.DAT","r");
       if ( fp == NULL )
       {
         puts("Unable to open file for reading.");
         _dosexterr(&de);
         printf("Extended DOS error information:\n");
         printf("Extended error: %i\n",de.exterror);
         printf("Class:          %x\n",de.class);
         printf("Action:         %x\n",de.action);
         printf("Error Locus:    %x\n",de.locus);
       }
     }


File: libc,  Node: dosmemget,  Next: dosmemgetb,  Prev: dosexterr,  Up: Alphabetical List

dosmemget
=========

Syntax
------

     #include <sys/movedata.h>
     
     void dosmemget(int offset, int length, void *buffer);

Description
-----------

This function transfers data from MS-DOS's conventional memory space to
the program's virtual address space.  The OFFSET is a physical address,
which can be computed from a real-mode segment/offset pair as follows:

     offset = segment * 16 + offset;

The LENGTH is the number of bytes to transfer, and BUFFER is a pointer
to somewhere in your virtual address space (such as memory obtained
from `malloc') where the data will go.

Return Value
------------

None.

Example
-------

     unsigned short shift_state;
     dosmemget(0x417, 2, &shift_state);
     if (shift_state & 0x0004)
       /* Ctrl key pressed */;


File: libc,  Node: dosmemgetb,  Next: dosmemgetl,  Prev: dosmemget,  Up: Alphabetical List

dosmemgetb
==========

Syntax
------

     #include <sys/movedata.h>
     
     void _dosmemgetb(unsigned long offset, size_t xfers, void *buffer);

Description
-----------

This function transfers data from MS-DOS's conventional memory space to
the program's virtual address space, using only byte transfers.  The
OFFSET is a physical address, which can be computed from a real-mode
segment/offset pair as follows:

     offset = segment * 16 + offset;

The XFERS is the number of bytes to transfer, and BUFFER is a pointer
to somewhere in your virtual address space (such as memory obtained
from `malloc') where the data will go.

Return Value
------------

None.

Example
-------

     unsigned short shift_state;
     dosmemgetb(0x417, 2, &shift_state);
     if (shift_state & 0x0004)
       /* Ctrl key pressed */;


File: libc,  Node: dosmemgetl,  Next: dosmemgetw,  Prev: dosmemgetb,  Up: Alphabetical List

dosmemgetl
==========

Syntax
------

     #include <sys/movedata.h>
     
     void _dosmemgetl(unsigned long offset, size_t xfers, void *buffer);

Description
-----------

This function transfers data from MS-DOS's conventional memory space to
the program's virtual address space, using only long-word (32-bit)
transfers.  The OFFSET is a physical address, which can be computed
from a real-mode segment/offset pair as follows:

     offset = segment * 16 + offset;

The COUNT is the number of long-words to transfer, and BUFFER is a
pointer to somewhere in your virtual address space (such as memory
obtained from `malloc') where the data will go.

Return Value
------------

None.

Example
-------

     unsigned long shift_state;
     dosmemgetl(0x417, 1, &shift_state);
     if (shift_state & 0x0004)
       /* Ctrl key pressed */;


File: libc,  Node: dosmemgetw,  Next: dosmemput,  Prev: dosmemgetl,  Up: Alphabetical List

dosmemgetw
==========

Syntax
------

     #include <sys/movedata.h>
     
     void _dosmemgetw(unsigned long offset, size_t xfers, void *buffer);

Description
-----------

This function transfers data from MS-DOS's conventional memory space to
the program's virtual address space, using only short-word (16-bit)
transfers.  The OFFSET is a physical address, which can be computed
from a real-mode segment/offset pair as follows:

     offset = segment * 16 + offset;

The XFERS is the number of words to transfer, and BUFFER is a pointer
to somewhere in your virtual address space (such as memory obtained
from `malloc') where the data will go.

Return Value
------------

None.

Example
-------

     unsigned short shift_state;
     dosmemgetw(0x417, 1, &shift_state);
     if (shift_state & 0x0004)
       /* Ctrl key pressed */;


File: libc,  Node: dosmemput,  Next: dosmemputb,  Prev: dosmemgetw,  Up: Alphabetical List

dosmemput
=========

Syntax
------

     #include <sys/movedata.h>
     
     void dosmemput(const void *buffer, int length, int offset);

Description
-----------

This function transfers data from the program's virtual address space to
MS-DOS's conventional memory space.  The OFFSET is a physical address,
which can be computed from a real-mode segment/offset pair as follows:

     offset = segment * 16 + offset;

The LENGTH is the number of bytes to transfer, and BUFFER is a pointer
to somewhere in your virtual address space (such as memory obtained
from `malloc') where the data will come from.

Return Value
------------

None.

Example
-------

     unsigned short save_screen[25][80];
     dosmemput(save_screen, 0xb8000, 80*2*25);


File: libc,  Node: dosmemputb,  Next: dosmemputl,  Prev: dosmemput,  Up: Alphabetical List

dosmemputb
==========

Syntax
------

     #include <sys/movedata.h>
     
     void _dosmemputb(const void *buffer, size_t xfers, unsigned long offset);

Description
-----------

This function transfers data from the program's virtual address space
to MS-DOS's conventional memory space, using only byte (8-bit)
transfers.  The OFFSET is a physical address, which can be computed
from a real-mode segment/offset pair as follows:

     offset = segment * 16 + offset;

The XFERS is the number of bytes to transfer, and BUFFER is a pointer
to somewhere in your virtual address space (such as memory obtained
from `malloc') where the data will come from.

Return Value
------------

None.

Example
-------

     unsigned short save_screen[25][80];
     dosmemputb(save_screen, 0xb8000, 80*2*25);


File: libc,  Node: dosmemputl,  Next: dosmemputw,  Prev: dosmemputb,  Up: Alphabetical List

dosmemputl
==========

Syntax
------

     #include <sys/movedata.h>
     
     void _dosmemputl(const void *buffer, size_t xfers unsigned long offset);

Description
-----------

This function transfers data from the program's virtual address space
to MS-DOS's conventional memory space, using only long-word (32-bit)
transfers.  The OFFSET is a physical address, which can be computed
from a real-mode segment/offset pair as follows:

     offset = segment * 16 + offset;

The XFERS is the number of long-words to transfer, and BUFFER is a
pointer to somewhere in your virtual address space (such as memory
obtained from `malloc') where the data will come from.

Return Value
------------

None.

Example
-------

     unsigned short save_screen[25][80];
     dosmemputl(save_screen, 0xb8000, 40*25);


File: libc,  Node: dosmemputw,  Next: DPMI Overview,  Prev: dosmemputl,  Up: Alphabetical List

dosmemputw
==========

Syntax
------

     #include <sys/movedata.h>
     
     void _dosmemputw(const void *buffer, size_t xfers, unsigned long offset);

Description
-----------

This function transfers data from the program's virtual address space
to MS-DOS's conventional memory space, using only short-word (16-bit)
transfers.  The OFFSET is a physical address, which can be computed
from a real-mode segment/offset pair as follows:

     offset = segment * 16 + offset;

The XFERS is the number of short-words to transfer, and BUFFER is a
pointer to somewhere in your virtual address space (such as memory
obtained from `malloc') where the data will come from.

Return Value
------------

None.

Example
-------

     unsigned short save_screen[25][80];
     dosmemputw(save_screen, 0xb8000, 80*25);


File: libc,  Node: DPMI Overview,  Next: DPMI Specification,  Prev: dosmemputw,  Up: Alphabetical List

DPMI Overview
=============

     extern unsigned short __dpmi_error;

For most functions, the error returned from the DPMI server is stored
in this variable.

     typedef struct {
       unsigned short offset16;
       unsigned short segment;
     } __dpmi_raddr;

This structure is used to hold a real-mode address, which consists of a
segment:offset pair.

     typedef struct {
       unsigned long  offset32;
       unsigned short selector;
     } __dpmi_paddr;

This structure is used to hold a protected-mode address, which consists
of a selector:offset pair.

     typedef struct {
       unsigned long handle;			/* 0, 2 */
       unsigned long size; 	/* or count */	/* 4, 6 */
       unsigned long address;		/* 8, 10 */
     } __dpmi_meminfo;

This structure is used by many functions that need to refer to blocks
of 32-bit memory.  The `size' field doubles as a count for those
operations that want a count of something, or return a count.

     typedef union {
       struct {
         unsigned long edi;
         unsigned long esi;
         unsigned long ebp;
         unsigned long res;
         unsigned long ebx;
         unsigned long edx;
         unsigned long ecx;
         unsigned long eax;
       } d;
       struct {
         unsigned short di, di_hi;
         unsigned short si, si_hi;
         unsigned short bp, bp_hi;
         unsigned short res, res_hi;
         unsigned short bx, bx_hi;
         unsigned short dx, dx_hi;
         unsigned short cx, cx_hi;
         unsigned short ax, ax_hi;
         unsigned short flags;
         unsigned short es;
         unsigned short ds;
         unsigned short fs;
         unsigned short gs;
         unsigned short ip;
         unsigned short cs;
         unsigned short sp;
         unsigned short ss;
       } x;
       struct {
         unsigned char edi[4];
         unsigned char esi[4];
         unsigned char ebp[4];
         unsigned char res[4];
         unsigned char bl, bh, ebx_b2, ebx_b3;
         unsigned char dl, dh, edx_b2, edx_b3;
         unsigned char cl, ch, ecx_b2, ecx_b3;
         unsigned char al, ah, eax_b2, eax_b3;
       } h;
     } __dpmi_regs;

This structure is used by functions that pass register information,
such as simulating real-mode calls.

     typedef struct {
       unsigned char  major;
       unsigned char  minor;
       unsigned short flags;
       unsigned char  cpu;
       unsigned char  master_pic;
       unsigned char  slave_pic;
     } __dpmi_version_ret;

This structure is used to return version information to the program.

     typedef struct {
       unsigned long largest_available_free_block_in_bytes;
       unsigned long maximum_unlocked_page_allocation_in_pages;
       unsigned long maximum_locked_page_allocation_in_pages;
       unsigned long linear_address_space_size_in_pages;
       unsigned long total_number_of_unlocked_pages;
       unsigned long total_number_of_free_pages;
       unsigned long total_number_of_physical_pages;
       unsigned long free_linear_address_space_in_pages;
       unsigned long size_of_paging_file_partition_in_pages;
       unsigned long reserved[3];
     } __dpmi_free_mem_info;

This structure is used to return information about the state of virtual
memory in the system.

     typedef struct {
       unsigned long total_allocated_bytes_of_physical_memory_host;
       unsigned long total_allocated_bytes_of_virtual_memory_host;
       unsigned long total_available_bytes_of_virtual_memory_host;
       unsigned long total_allocated_bytes_of_virtual_memory_vcpu;
       unsigned long total_available_bytes_of_virtual_memory_vcpu;
       unsigned long total_allocated_bytes_of_virtual_memory_client;
       unsigned long total_available_bytes_of_virtual_memory_client;
       unsigned long total_locked_bytes_of_memory_client;
       unsigned long max_locked_bytes_of_memory_client;
       unsigned long highest_linear_address_available_to_client;
       unsigned long size_in_bytes_of_largest_free_memory_block;
       unsigned long size_of_minimum_allocation_unit_in_bytes;
       unsigned long size_of_allocation_alignmentunit_in_bytes;
       unsigned long reserved[19];
     } __dpmi_memory_info;

This is also used to return memory information, but by a different
function.

     typedef struct {
       unsigned long data16[2];
       unsigned long code16[2];
       unsigned short ip;
       unsigned short reserved;
       unsigned long data32[2];
       unsigned long code32[2];
       unsigned long eip;
     } __dpmi_callback_info;

This structure is used to install TSR programs.

     typedef struct {
       unsigned long size_requested;
       unsigned long size;
       unsigned long handle;
       unsigned long address;
       unsigned long name_offset;
       unsigned short name_selector;
       unsigned short reserved1;
       unsigned long reserved2;
     } __dpmi_shminfo;

This structure is used to manipulate shared memory regions.


File: libc,  Node: DPMI Specification,  Next: __dpmi_allocate_dos_memory,  Prev: DPMI Overview,  Up: Alphabetical List

DPMI Specification
==================

To obtain the DPMI specification, Contact Intel and order document
number 240977-001.  Also, try ftp.qdeck.com:/pub/memory/dpmi* and
http://www.delorie.com/djgpp/doc/dpmi/.


File: libc,  Node: __dpmi_allocate_dos_memory,  Next: __dpmi_allocate_ldt_descriptors,  Prev: DPMI Specification,  Up: Alphabetical List

__dpmi_allocate_dos_memory
==========================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_allocate_dos_memory(int _paragraphs, int *_ret_selector_or_max);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0100

This function allocates DOS memory.  You pass it the number of
paragraphs ((bytes+15)>>4) to allocate.  If it succeeds, it returns a
segment (dos-style) and fills in _RET_SELECTOR_OR_MAX with a selector
(protected-mode) that you can use to reference the same memory.  Note
that it's the selector you use to free the block, not the segment.

Return Value
------------

-1 on error, else the segment [0000..FFFF].


File: libc,  Node: __dpmi_allocate_ldt_descriptors,  Next: __dpmi_allocate_linear_memory,  Prev: __dpmi_allocate_dos_memory,  Up: Alphabetical List

__dpmi_allocate_ldt_descriptors
===============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_allocate_ldt_descriptors(int count);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0000

Allocates COUNT descriptors.

Return Value
------------

-1 on error, else the first descriptor.  Use *Note
__dpmi_get_selector_increment_value:: to figure out the remaining
selectors.

Example
-------

     short sel = __dpmi_allocate_ldt_descriptors(1);


File: libc,  Node: __dpmi_allocate_linear_memory,  Next: __dpmi_allocate_memory,  Prev: __dpmi_allocate_ldt_descriptors,  Up: Alphabetical List

__dpmi_allocate_linear_memory
=============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_allocate_linear_memory

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0504 (DPMI 1.0 only)

This allocates a block of page-aligned linear address space.  Pass a
desired address (or zero for any) and a size.  _COMMIT is 1 for
committed pages, else they are uncommitted.  It returns a handle and
the actual address.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_allocate_memory,  Next: __dpmi_allocate_real_mode_callback,  Prev: __dpmi_allocate_linear_memory,  Up: Alphabetical List

__dpmi_allocate_memory
======================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_allocate_memory(__dpmi_meminfo *_info);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0501

This allocates virtual memory.  Fill in size, returns handle and
address.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_allocate_real_mode_callback,  Next: __dpmi_allocate_shared_memory,  Prev: __dpmi_allocate_memory,  Up: Alphabetical List

__dpmi_allocate_real_mode_callback
==================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_allocate_real_mode_callback(void (*_handler)(void), __dpmi_regs *_regs, __dpmi_raddr *_ret);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0303

This function gives you a real-mode address to pass to TSRs that gets
reflected to your protected-mode handler.  You pass it a register block
to use; it gets filled in with the real-mode registers when your
handler is called, and the registers are set from it when the handler
returns.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_allocate_shared_memory,  Next: __dpmi_allocate_specific_ldt_descriptor,  Prev: __dpmi_allocate_real_mode_callback,  Up: Alphabetical List

__dpmi_allocate_shared_memory
=============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_allocate_shared_memory(__dpmi_shminfo *_info);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0d00 (DPMI 1.0 only)

See the spec.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_allocate_specific_ldt_descriptor,  Next: __dpmi_clear_debug_watchpoint,  Prev: __dpmi_allocate_shared_memory,  Up: Alphabetical List

__dpmi_allocate_specific_ldt_descriptor
=======================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_allocate_specific_ldt_descriptor(int _selector);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x000d

This allocates the specific selector given.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_clear_debug_watchpoint,  Next: __dpmi_create_alias_descriptor,  Prev: __dpmi_allocate_specific_ldt_descriptor,  Up: Alphabetical List

__dpmi_clear_debug_watchpoint
=============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_clear_debug_watchpoint(unsigned long _handle);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0b01

Clear a debug watchpoint.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_create_alias_descriptor,  Next: __dpmi_discard_page_contents,  Prev: __dpmi_clear_debug_watchpoint,  Up: Alphabetical List

__dpmi_create_alias_descriptor
==============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_create_alias_descriptor(int _selector);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x000a

Create a new selector with the same parameters as the given one.

Return Value
------------

-1 on error, else the new selector.


File: libc,  Node: __dpmi_discard_page_contents,  Next: __dpmi_free_dos_memory,  Prev: __dpmi_create_alias_descriptor,  Up: Alphabetical List

__dpmi_discard_page_contents
============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_discard_page_contents(__dpmi_meminfo *_info);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0703

Advises the server that the given pages are no longer needed and may be
reclaimed.  Fill in address and size (in bytes).

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_free_dos_memory,  Next: __dpmi_free_ldt_descriptor,  Prev: __dpmi_discard_page_contents,  Up: Alphabetical List

__dpmi_free_dos_memory
======================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_free_dos_memory(int _selector);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0101

This function frees the dos memory allocated by *Note
__dpmi_allocate_dos_memory::.  Remember to pass the selector and not
the segment.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_free_ldt_descriptor,  Next: __dpmi_free_memory,  Prev: __dpmi_free_dos_memory,  Up: Alphabetical List

__dpmi_free_ldt_descriptor
==========================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_free_ldt_descriptor(int descriptor);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0001

This function frees a single descriptor, even if it was allocated as
one of many.

Return Value
------------

-1 on error, else zero.

Example
-------

     __dpmi_free_ldt_descriptor(sel);


File: libc,  Node: __dpmi_free_memory,  Next: __dpmi_free_physical_address_mapping,  Prev: __dpmi_free_ldt_descriptor,  Up: Alphabetical List

__dpmi_free_memory
==================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_free_memory(unsigned long _handle);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0502

This frees a block of virtual memory.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_free_physical_address_mapping,  Next: __dpmi_free_real_mode_callback,  Prev: __dpmi_free_memory,  Up: Alphabetical List

__dpmi_free_physical_address_mapping
====================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_free_physical_address_mapping(__dpmi_meminfo *_info);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0801

This function unmaps a physical device mapped with *Note
__dpmi_physical_address_mapping::.  Fill in the linear address.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_free_real_mode_callback,  Next: __dpmi_free_serialization_on_shared_memory,  Prev: __dpmi_free_physical_address_mapping,  Up: Alphabetical List

__dpmi_free_real_mode_callback
==============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_free_real_mode_callback(__dpmi_raddr *_addr);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0303

This function frees the real-mode callback address.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_free_serialization_on_shared_memory,  Next: __dpmi_free_shared_memory,  Prev: __dpmi_free_real_mode_callback,  Up: Alphabetical List

__dpmi_free_serialization_on_shared_memory
==========================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_free_serialization_on_shared_memory(unsigned long _handle, int _flags);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0d03 (DPMI 1.0 only)

See the spec.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_free_shared_memory,  Next: __dpmi_get_and_disable_virtual_interrupt_state,  Prev: __dpmi_free_serialization_on_shared_memory,  Up: Alphabetical List

__dpmi_free_shared_memory
=========================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_free_shared_memory(unsigned long _handle);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0d01 (DPMI 1.0 only)

See the spec.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_get_and_disable_virtual_interrupt_state,  Next: __dpmi_get_and_enable_virtual_interrupt_state,  Prev: __dpmi_free_shared_memory,  Up: Alphabetical List

__dpmi_get_and_disable_virtual_interrupt_state
==============================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_and_disable_virtual_interrupt_state

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0900

This function disables interrupts, and returns the previous setting.

Return Value
------------

The previous setting.


File: libc,  Node: __dpmi_get_and_enable_virtual_interrupt_state,  Next: __dpmi_get_and_set_virtual_interrupt_state,  Prev: __dpmi_get_and_disable_virtual_interrupt_state,  Up: Alphabetical List

__dpmi_get_and_enable_virtual_interrupt_state
=============================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_and_enable_virtual_interrupt_state(void);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0901

This function enables interrupts, and returns the previous setting.

Return Value
------------

The previous setting.


File: libc,  Node: __dpmi_get_and_set_virtual_interrupt_state,  Next: __dpmi_get_capabilities,  Prev: __dpmi_get_and_enable_virtual_interrupt_state,  Up: Alphabetical List

__dpmi_get_and_set_virtual_interrupt_state
==========================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_and_set_virtual_interrupt_state(int _old_state);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AH = 0x09

This function restores the interrupt state from a previous call to
*Note __dpmi_get_and_disable_virtual_interrupt_state:: or *Note
__dpmi_get_and_enable_virtual_interrupt_state::.

Return Value
------------

The previous setting.


File: libc,  Node: __dpmi_get_capabilities,  Next: __dpmi_get_coprocessor_status,  Prev: __dpmi_get_and_set_virtual_interrupt_state,  Up: Alphabetical List

__dpmi_get_capabilities
=======================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_capabilities(int *_flags, char *vendor_info);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0401 (DPMI 1.0 only)

Gets the capabilities of the server.  The flags are as follows:

     ---- ---X = 1="page accessed/dirty" supported
     ---- --X- = 1="exceptions restartble" supported
     ---- -X-- = 1="device mapping" supported
     ---- X--- = 1="map conventional memory" supported
     ---X ---- = 1="demand zero-fill" supported
     --X- ---- = 1="write-protect client" supported
     -X-- ---- = 1="write-protect host" supported

The vendor info is a 128-byte buffer:

     [0] host major number
     [1] host minor number
     [2..127] vendor name

Return Value
------------

!-1 on error, else zero.


File: libc,  Node: __dpmi_get_coprocessor_status,  Next: __dpmi_get_descriptor,  Prev: __dpmi_get_capabilities,  Up: Alphabetical List

__dpmi_get_coprocessor_status
=============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_coprocessor_status(void);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0e00 (DPMI 1.0 only)

Return Value
------------

-1 on error, else returns the processor status flags


File: libc,  Node: __dpmi_get_descriptor,  Next: __dpmi_get_descriptor_access_rights,  Prev: __dpmi_get_coprocessor_status,  Up: Alphabetical List

__dpmi_get_descriptor
=====================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_descriptor(int _selector, void *_buffer);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x000b

This function fills a 8-byte buffer with the parameters of the
descriptor.  The data has the following format:

     [0] XXXX XXXX = segment limit [7:0]
     [1] XXXX XXXX = segment limit [15:8]
     [2] XXXX XXXX = base address [7:0]
     [3] XXXX XXXX = base address [15:8]
     [4] XXXX XXXX = base address [23:16]
     [5] ---- XXXX = type
     [5] ---X ---- = 0=system, 1=application
     [5] -XX- ---- = priviledge level
     [5] X--- ---- = 0=absent, 1=present
     [6] ---- XXXX = segment limit [19:16]
     [6] ---X ---- = available for user
     [6] --0- ---- = must be zero
     [6] -X-- ---- = 0=16-bit 1=32-bit (cs only)
     [6] X--- ---- = 0=byte-granular (small) 1=page-granular (big)
     [7] XXXX XXXX = base address [31:24]

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_get_descriptor_access_rights,  Next: __dpmi_get_extended_exception_handler_vector_pm,  Prev: __dpmi_get_descriptor,  Up: Alphabetical List

__dpmi_get_descriptor_access_rights
===================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_descriptor_access_rights(int _selector);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

This function returns the access rights byte from the `lar' opcode.

Return Value
------------

The access byte.  See an Intel programming manual for the list of
access information.


File: libc,  Node: __dpmi_get_extended_exception_handler_vector_pm,  Next: __dpmi_get_extended_exception_handler_vector_rm,  Prev: __dpmi_get_descriptor_access_rights,  Up: Alphabetical List

__dpmi_get_extended_exception_handler_vector_pm
===============================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_extended_exception_handler_vector_pm(int _vector, __dpmi_paddr *_address);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0210 (DPMI 1.0 only)

This gets the function that handles protected mode exceptions.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_get_extended_exception_handler_vector_rm,  Next: __dpmi_get_free_memory_information,  Prev: __dpmi_get_extended_exception_handler_vector_pm,  Up: Alphabetical List

__dpmi_get_extended_exception_handler_vector_rm
===============================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_extended_exception_handler_vector_rm(int _vector, __dpmi_paddr *_address);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0211 (DPMI 1.0 only)

This function gets the handler for real-mode exceptions.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_get_free_memory_information,  Next: __dpmi_get_memory_block_size_and_base,  Prev: __dpmi_get_extended_exception_handler_vector_rm,  Up: Alphabetical List

__dpmi_get_free_memory_information
==================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_free_memory_information(__dpmi_free_mem_info *_info);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0500

This function returns information about available memory.  Unsupported
fields will have -1 (0xfffffff) in them.

Return Value
------------

Zero.  This always works.


File: libc,  Node: __dpmi_get_memory_block_size_and_base,  Next: __dpmi_get_memory_information,  Prev: __dpmi_get_free_memory_information,  Up: Alphabetical List

__dpmi_get_memory_block_size_and_base
=====================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_memory_block_size_and_base(__dpmi_meminfo *_info);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x050a (DPMI 1.0 only)

Pass the handle.  It fills in the address and size.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_get_memory_information,  Next: __dpmi_get_multiple_descriptors,  Prev: __dpmi_get_memory_block_size_and_base,  Up: Alphabetical List

__dpmi_get_memory_information
=============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_memory_information(__dpmi_memory_info *_buffer);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x050b (DPMI 1.0 only)

This function returns virtual memory information.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_get_multiple_descriptors,  Next: __dpmi_get_page_attributes,  Prev: __dpmi_get_memory_information,  Up: Alphabetical List

__dpmi_get_multiple_descriptors
===============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_multiple_descriptors(int _count, void *_buffer);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x000e (DPMI 1.0 only)

This function gets a list of selectors' parameters.  The buffer must be
prefilled with selector values, and will contain the parameters on
return:

     [0x00:2] selector #1 (pass)
     [0x02:8] parameters #1 (returned)
     [0x0a:2] selector #2 (pass)
     [0x0c:8] parameters #2 (returned)
     ...

Return Value
------------

Returns _count if successful, the negative of # descriptors copied if
failure.


File: libc,  Node: __dpmi_get_page_attributes,  Next: __dpmi_get_page_size,  Prev: __dpmi_get_multiple_descriptors,  Up: Alphabetical List

__dpmi_get_page_attributes
==========================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_page_attributes(__dpmi_meminfo *_info, short *_buffer);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0506 (DPMI 1.0 only)

Pass the handle, offset of first page (relative to start of block) in
.address, and number of pages in .count.  Buffer gets filled in with
the attributes (see spec).

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_get_page_size,  Next: __dpmi_get_processor_exception_handler_vector,  Prev: __dpmi_get_page_attributes,  Up: Alphabetical List

__dpmi_get_page_size
====================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_page_size(unsigned long *_size);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0604

Fills in the page size.

Return Value
------------

-1 on error (16-bit host), else zero.


File: libc,  Node: __dpmi_get_processor_exception_handler_vector,  Next: __dpmi_get_protected_mode_interrupt_vector,  Prev: __dpmi_get_page_size,  Up: Alphabetical List

__dpmi_get_processor_exception_handler_vector
=============================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_processor_exception_handler_vector

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0202

This function gets the current protected-mode exception handler (not
interrupts).  It will return a selector:offset pair.

Return Value
------------

-1 on error (invalid vector), else zero.


File: libc,  Node: __dpmi_get_protected_mode_interrupt_vector,  Next: __dpmi_get_raw_mode_switch_addr,  Prev: __dpmi_get_processor_exception_handler_vector,  Up: Alphabetical List

__dpmi_get_protected_mode_interrupt_vector
==========================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_protected_mode_interrupt_vector(int _vector, __dpmi_paddr *_address);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0204

This function gets the address of the current protected mode interrupt
(not exception) handler.  It returns a selector:offset pair.

Return Value
------------

Zero.  This always works.


File: libc,  Node: __dpmi_get_raw_mode_switch_addr,  Next: __dpmi_get_real_mode_interrupt_vector,  Prev: __dpmi_get_protected_mode_interrupt_vector,  Up: Alphabetical List

__dpmi_get_raw_mode_switch_addr
===============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_raw_mode_switch_addr(__dpmi_raddr *_rm, __dpmi_paddr *_pm);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0306

Read the spec for more info.

Return Value
------------

Zero.  This always works.


File: libc,  Node: __dpmi_get_real_mode_interrupt_vector,  Next: __dpmi_get_segment_base_address,  Prev: __dpmi_get_raw_mode_switch_addr,  Up: Alphabetical List

__dpmi_get_real_mode_interrupt_vector
=====================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_real_mode_interrupt_vector(int _vector, __dpmi_raddr *_address);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0200

This function stores the real-mode interrupt vector address in
_ADDRESS. This is the same as the DOS get vector call, and returns a
real-mode segment:offset pair.

Bits [31:8] in the vector number are silently ignored.

Return Value
------------

Zero.  This function always works.


File: libc,  Node: __dpmi_get_segment_base_address,  Next: __dpmi_get_segment_limit,  Prev: __dpmi_get_real_mode_interrupt_vector,  Up: Alphabetical List

__dpmi_get_segment_base_address
===============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_segment_base_address(int _selector, unsigned long *_addr);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0006

The physical base address of the selector is stored in *ADDR.

Return Value
------------

-1 on error, else zero.

Example
-------

     unsigned long addr;
     if (__dpmi_get_segment_base_address(selector, &addr))
       ...


File: libc,  Node: __dpmi_get_segment_limit,  Next: __dpmi_get_selector_increment_value,  Prev: __dpmi_get_segment_base_address,  Up: Alphabetical List

__dpmi_get_segment_limit
========================

Syntax
------

     #include <dpmi.h>
     
     unsigned __dpmi_get_segment_limit(int _selector);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

Return Value
------------

The limit of the segment, as returned by the `lsl' opcode.


File: libc,  Node: __dpmi_get_selector_increment_value,  Next: __dpmi_get_state_of_debug_watchpoint,  Prev: __dpmi_get_segment_limit,  Up: Alphabetical List

__dpmi_get_selector_increment_value
===================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_selector_increment_value(void);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0003

Return Value
------------

The value to return to each selector allocated by
__dpmi_allocate_ldt_descriptors to get the next one.


File: libc,  Node: __dpmi_get_state_of_debug_watchpoint,  Next: __dpmi_get_state_save_restore_addr,  Prev: __dpmi_get_selector_increment_value,  Up: Alphabetical List

__dpmi_get_state_of_debug_watchpoint
====================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_state_of_debug_watchpoint(unsigned long _handle, int *_status);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0b02

Gets the state of the watchpoint.  Pass handle, fills in status (0=not
encountered, 1=encountered).

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_get_state_save_restore_addr,  Next: __dpmi_get_vendor_specific_api_entry_point,  Prev: __dpmi_get_state_of_debug_watchpoint,  Up: Alphabetical List

__dpmi_get_state_save_restore_addr
==================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_state_save_restore_addr(__dpmi_raddr *_rm, __dpmi_paddr *_pm);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0305

Read the spec for info.

Return Value
------------

The number of bytes required to save state.


File: libc,  Node: __dpmi_get_vendor_specific_api_entry_point,  Next: __dpmi_get_version,  Prev: __dpmi_get_state_save_restore_addr,  Up: Alphabetical List

__dpmi_get_vendor_specific_api_entry_point
==========================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_vendor_specific_api_entry_point(char *_id, __dpmi_paddr *_api);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0a00

Look up a vendor-specific function, given the *name* of the function.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_get_version,  Next: __dpmi_get_virtual_interrupt_state,  Prev: __dpmi_get_vendor_specific_api_entry_point,  Up: Alphabetical List

__dpmi_get_version
==================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_version(__dpmi_version_ret *_ret);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0400

Fills in version information.  The flags are as follows:

     ---- ---X = 0=16-bit host  1=32-bit host
     ---- --X- = 0=V86 used for reflected ints, 1=real mode
     ---- -X-- = 0=no virtual memory, 1=virtual memory supported

The cpu is 2=80286, 3=80386, 4=80486, etc.

DPMI 0.9 returns major=0 and minor=0x5a.

Return Value
------------

Zero.  This always works.


File: libc,  Node: __dpmi_get_virtual_interrupt_state,  Next: __dpmi_install_resident_service_provider_callback,  Prev: __dpmi_get_version,  Up: Alphabetical List

__dpmi_get_virtual_interrupt_state
==================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_get_virtual_interrupt_state(void);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0902

Return Value
------------

This function returns the current interrupt flag (1=enabled).


File: libc,  Node: __dpmi_install_resident_service_provider_callback,  Next: __dpmi_int,  Prev: __dpmi_get_virtual_interrupt_state,  Up: Alphabetical List

__dpmi_install_resident_service_provider_callback
=================================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_install_resident_service_provider_callback(__dpmi_callback_info *_info);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0c00 (DPMI 1.0 only)

See the spec.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_int,  Next: __dpmi_lock_linear_region,  Prev: __dpmi_install_resident_service_provider_callback,  Up: Alphabetical List

__dpmi_int
==========

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_int(int _vector, __dpmi_regs *_regs);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0300

This function performs a software interrupt in real mode after filling
in *most* the registers from the given structure.  %ss, %esp, and
%eflags are automatically taken care of, unlike *Note
__dpmi_simulate_real_mode_interrupt::.

The following variables can be used to tune this function.  By default,
these variables are all zero.

`__dpmi_int_ss'
`__dpmi_int_sp'
`__dpmi_int_flags'
     These hold the values stored in the appropriate field in the
     `__dpmi_regs' structure.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_lock_linear_region,  Next: __dpmi_map_conventional_memory_in_memory_block,  Prev: __dpmi_int,  Up: Alphabetical List

__dpmi_lock_linear_region
=========================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_lock_linear_region(__dpmi_meminfo *_info);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0600

This function locks virtual memory, to prevent page faults during
hardware interrupts.  Pass address and size (in bytes).

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_map_conventional_memory_in_memory_block,  Next: __dpmi_map_device_in_memory_block,  Prev: __dpmi_lock_linear_region,  Up: Alphabetical List

__dpmi_map_conventional_memory_in_memory_block
==============================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_map_conventional_memory_in_memory_block(__dpmi_meminfo *_info, unsigned long _physaddr);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0509 (DPMI 1.0 only)

This function maps conventional memory (even when virtualized) to
virtual memory.  Pass the handle, offset, and number of pages.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_map_device_in_memory_block,  Next: __dpmi_mark_page_as_demand_paging_candidate,  Prev: __dpmi_map_conventional_memory_in_memory_block,  Up: Alphabetical List

__dpmi_map_device_in_memory_block
=================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_map_device_in_memory_block(__dpmi_meminfo *_info, unsigned long *_physaddr);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0508 (DPMI 1.0 only)

This function maps a physical address range to virtual memory.  Pass
the handle, offset relative to the start of the block, and number of
pages to map.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_mark_page_as_demand_paging_candidate,  Next: __dpmi_mark_real_mode_region_as_pageable,  Prev: __dpmi_map_device_in_memory_block,  Up: Alphabetical List

__dpmi_mark_page_as_demand_paging_candidate
===========================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_mark_page_as_demand_paging_candidate(__dpmi_meminfo *_info);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0702

Advises the server that certain pages are unlikely to be used soon.
Set address and size (in bytes).

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_mark_real_mode_region_as_pageable,  Next: __dpmi_physical_address_mapping,  Prev: __dpmi_mark_page_as_demand_paging_candidate,  Up: Alphabetical List

__dpmi_mark_real_mode_region_as_pageable
========================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_mark_real_mode_region_as_pageable(__dpmi_meminfo *_info);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0602

This function advises the host that the given pages are suitable for
page-out.  Pass address and size (in bytes).

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_physical_address_mapping,  Next: __dpmi_relock_real_mode_region,  Prev: __dpmi_mark_real_mode_region_as_pageable,  Up: Alphabetical List

__dpmi_physical_address_mapping
===============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_physical_address_mapping(__dpmi_meminfo *_info);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0800

Maps a physical device (like a graphics buffer) to linear memory.  Fill
in the physical address and size (in bytes).  On return, the address is
the linear address to use.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_relock_real_mode_region,  Next: __dpmi_reset_debug_watchpoint,  Prev: __dpmi_physical_address_mapping,  Up: Alphabetical List

__dpmi_relock_real_mode_region
==============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_relock_real_mode_region(__dpmi_meminfo *_info);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0603

This function relocks the pages unlocked with *Note
__dpmi_mark_real_mode_region_as_pageable::.  Pass address and size (in
bytes).

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_reset_debug_watchpoint,  Next: __dpmi_resize_dos_memory,  Prev: __dpmi_relock_real_mode_region,  Up: Alphabetical List

__dpmi_reset_debug_watchpoint
=============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_reset_debug_watchpoint

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0b03

Resets a watchpoint.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_resize_dos_memory,  Next: __dpmi_resize_linear_memory,  Prev: __dpmi_reset_debug_watchpoint,  Up: Alphabetical List

__dpmi_resize_dos_memory
========================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_resize_dos_memory(int _selector, int _newpara, int *_ret_max);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0102

This function resizes a dos memory block.  Remember to pass the
selector, and not the segment.  If this call fails, _RET_MAX contains
the largest number of paragraphs available.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_resize_linear_memory,  Next: __dpmi_resize_memory,  Prev: __dpmi_resize_dos_memory,  Up: Alphabetical List

__dpmi_resize_linear_memory
===========================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_resize_linear_memory(__dpmi_meminfo *_info, int _commit);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0505 (DPMI 1.0 only)

This function resizes a memory block.  Pass the handle and new size.
Bit 0 of _commit is 1 for committed pages; bit 1 is 1 to automatically
update descriptors.  It returns a new handle and base address.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_resize_memory,  Next: __dpmi_segment_to_descriptor,  Prev: __dpmi_resize_linear_memory,  Up: Alphabetical List

__dpmi_resize_memory
====================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_resize_memory

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0503

This function changes the size of a virtual memory block.  You must
pass the handle and size fields.  It may change the base address also;
beware of debugging breakpoints and locked memory.  It will return a
new handle.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_segment_to_descriptor,  Next: __dpmi_serialize_on_shared_memory,  Prev: __dpmi_resize_memory,  Up: Alphabetical List

__dpmi_segment_to_descriptor
============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_segment_to_descriptor

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0002

This function returns a selector that maps to what the real-mode
segment provided would have referenced.  Warning: this is a scarce
resource.

Return Value
------------

-1 on error, else the selector.

Example
-------

     short video = __dpmi_segment_to_descriptor(0xa000);


File: libc,  Node: __dpmi_serialize_on_shared_memory,  Next: __dpmi_set_coprocessor_emulation,  Prev: __dpmi_segment_to_descriptor,  Up: Alphabetical List

__dpmi_serialize_on_shared_memory
=================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_serialize_on_shared_memory(unsigned long _handle, int _flags);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0d02 (DPMI 1.0 only)

See the spec.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_set_coprocessor_emulation,  Next: __dpmi_set_debug_watchpoint,  Prev: __dpmi_serialize_on_shared_memory,  Up: Alphabetical List

__dpmi_set_coprocessor_emulation
================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_set_coprocessor_emulation(int _flags);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0e01 (DPMI 1.0 only)

Return Value
------------

-1 on errors, else zero.


File: libc,  Node: __dpmi_set_debug_watchpoint,  Next: __dpmi_set_descriptor,  Prev: __dpmi_set_coprocessor_emulation,  Up: Alphabetical List

__dpmi_set_debug_watchpoint
===========================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_set_debug_watchpoint(__dpmi_meminfo *_info, int _type);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0b00

Set a debug breakpoint.  Type is 0 for execute, 1 for write, and 2 for
access.  Fill in address and size (1,2,4 bytes).  Server fills in
handle.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_set_descriptor,  Next: __dpmi_set_descriptor_access_rights,  Prev: __dpmi_set_debug_watchpoint,  Up: Alphabetical List

__dpmi_set_descriptor
=====================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_set_descriptor(int _selector, void *_buffer);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x000c

This function sets the selector's parameters.  *Note
__dpmi_get_descriptor::.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_set_descriptor_access_rights,  Next: __dpmi_set_extended_exception_handler_vector_pm,  Prev: __dpmi_set_descriptor,  Up: Alphabetical List

__dpmi_set_descriptor_access_rights
===================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_set_descriptor_access_rights(int _selector, int _rights);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0009

This sets the rights of _SELECTOR to _RIGHTS.

     ---- ---- ---- ---X = 0=not accessed, 1=accessed
     ---- ---- ---- --X- = data: 0=read, 1=r/w; code: 1=readable
     ---- ---- ---- -X-- = data: 0=expand-up, 1=expand-down; code: 0=non-conforming
     ---- ---- ---- X--- = 0=data, 1=code
     ---- ---- ---1 ---- = must be 1
     ---- ---- -XX- ---- = priviledge level (must equal CPL)
     ---- ---- X--- ---- = 0=absent, 1=present
     ---X ---- ---- ---- = available for the user
     --0- ---- ---- ---- = must be 0
     -X-- ---- ---- ---- = 0=16-bit 1=32-bit
     X--- ---- ---- ---- = 0=byte granular (small) 1=page-granular (big)

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_set_extended_exception_handler_vector_pm,  Next: __dpmi_set_extended_exception_handler_vector_rm,  Prev: __dpmi_set_descriptor_access_rights,  Up: Alphabetical List

__dpmi_set_extended_exception_handler_vector_pm
===============================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_set_extended_exception_handler_vector_pm(int _vector, __dpmi_paddr *_address);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0212 (DPMI 1.0 only)

This function installs a handler for protected-mode exceptions.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_set_extended_exception_handler_vector_rm,  Next: __dpmi_set_multiple_descriptors,  Prev: __dpmi_set_extended_exception_handler_vector_pm,  Up: Alphabetical List

__dpmi_set_extended_exception_handler_vector_rm
===============================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_set_extended_exception_handler_vector_rm(int _vector, __dpmi_paddr *_address);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0213 (DPMI 1.0 only)

This function installs a handler for real-mode exceptions.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_set_multiple_descriptors,  Next: __dpmi_set_page_attributes,  Prev: __dpmi_set_extended_exception_handler_vector_rm,  Up: Alphabetical List

__dpmi_set_multiple_descriptors
===============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_set_multiple_descriptors(int _count, void *_buffer);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x000f (DPMI 1.0 only)

This function sets multiple descriptors.  Buffer usage is like *Note
__dpmi_get_multiple_descriptors::, but the caller fills in everything
before calling.

Return Value
------------

Returns _count if successful, the negative of # descriptors set if
failure.


File: libc,  Node: __dpmi_set_page_attributes,  Next: __dpmi_set_processor_exception_handler_vector,  Prev: __dpmi_set_multiple_descriptors,  Up: Alphabetical List

__dpmi_set_page_attributes
==========================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_set_page_attributes(__dpmi_meminfo *_info, short *_buffer);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0507 (DPMI 1.0 only)

Sets page attributes.  Pass handle, offset within block in .address,
and number of pages in .count.  Buffer points to new attributes (see
spec).

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_set_processor_exception_handler_vector,  Next: __dpmi_set_protected_mode_interrupt_vector,  Prev: __dpmi_set_page_attributes,  Up: Alphabetical List

__dpmi_set_processor_exception_handler_vector
=============================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_set_processor_exception_handler_vector(int _vector, __dpmi_paddr *_address);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0203

This function installs a handler for protected mode exceptions (not
interrupts).  You must pass a selector:offset pair.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_set_protected_mode_interrupt_vector,  Next: __dpmi_set_real_mode_interrupt_vector,  Prev: __dpmi_set_processor_exception_handler_vector,  Up: Alphabetical List

__dpmi_set_protected_mode_interrupt_vector
==========================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_set_protected_mode_interrupt_vector(int _vector, __dpmi_paddr *_address);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0205

This function installs a protected-mode interrupt (not exception)
handler.  You must pass a selector:offset pair.  Hardware interrupts
will always be reflected to protected mode if you install a handler.
You must explicitely `sti' before `iret' because `iret' won't always
restore interrupts in a virtual environment.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_set_real_mode_interrupt_vector,  Next: __dpmi_set_segment_base_address,  Prev: __dpmi_set_protected_mode_interrupt_vector,  Up: Alphabetical List

__dpmi_set_real_mode_interrupt_vector
=====================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_set_real_mode_interrupt_vector(int _vector, __dpmi_raddr *_address);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0201

This function sets a real-mode interrupt vector.  You must pass a
segment:offset pair, not a selector.

Bits [31:8] in the vector number are silently ignored.

Return Value
------------

Zero.  This function always works.


File: libc,  Node: __dpmi_set_segment_base_address,  Next: __dpmi_set_segment_limit,  Prev: __dpmi_set_real_mode_interrupt_vector,  Up: Alphabetical List

__dpmi_set_segment_base_address
===============================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_set_segment_base_address(int _selector, unsigned _address);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0007

This function sets the base address of the _SELECTOR to _ADDRESS.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_set_segment_limit,  Next: __dpmi_simulate_real_mode_interrupt,  Prev: __dpmi_set_segment_base_address,  Up: Alphabetical List

__dpmi_set_segment_limit
========================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_set_segment_limit(int _selector, unsigned _address);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0008

This function sets the highest valid address in the segment referenced
by _SELECTOR.  For example, if you pass 0xfffff, the highest valid
address is 0xfffff.  Note: if you pass a number <= 64K, the segment
changes to "non-big", and may cause unexpected problems.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_simulate_real_mode_interrupt,  Next: __dpmi_simulate_real_mode_procedure_iret,  Prev: __dpmi_set_segment_limit,  Up: Alphabetical List

__dpmi_simulate_real_mode_interrupt
===================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_simulate_real_mode_interrupt(int _vector, __dpmi_regs *_regs);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0300

This function performs a software interrupt in real mode after filling
in *all* the registers from the given structure.  You *must* set %ss,
%esp, and %eflags to valid real-mode values or zero, unlike *Note
__dpmi_int::.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_simulate_real_mode_procedure_iret,  Next: __dpmi_simulate_real_mode_procedure_retf,  Prev: __dpmi_simulate_real_mode_interrupt,  Up: Alphabetical List

__dpmi_simulate_real_mode_procedure_iret
========================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_simulate_real_mode_procedure_iret(__dpmi_regs *_regs);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0303

This function switches to real mode, filling in *all* the registers
from the structure.  ss:sp and flags must be valid or zero.  The called
function must return with an `iret'.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_simulate_real_mode_procedure_retf,  Next: __dpmi_simulate_real_mode_procedure_retf_stack,  Prev: __dpmi_simulate_real_mode_procedure_iret,  Up: Alphabetical List

__dpmi_simulate_real_mode_procedure_retf
========================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_simulate_real_mode_procedure_retf(__dpmi_regs *_regs);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0301

This function switches to real mode with *all* the registers set from
the structure, including cs:ip.  The function called should return with
a `retf'.  ss:sp and flags must be set to valid values or zero.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_simulate_real_mode_procedure_retf_stack,  Next: __dpmi_terminate_and_stay_resident,  Prev: __dpmi_simulate_real_mode_procedure_retf,  Up: Alphabetical List

__dpmi_simulate_real_mode_procedure_retf_stack
==============================================

Syntax
------

     #include <dpmi.h>
     
     int	__dpmi_simulate_real_mode_procedure_retf_stack(__dpmi_regs *_regs, int stack_bytes_to_copy, const void *stack_bytes);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0301

This function switches to real mode with *all* the registers set from
the structure, including cs:ip.  The function called should return with
a `retf'.  ss:sp and flags must be set to valid values or zero.

You may optionally specify bytes to be copied to the real mode stack,
to pass arguments to real-mode procedures with stack-based calling
conventions.  If you don't want to copy bytes to the real mode stack,
pass 0 for stack_bytes_to_copy, and NULL for stack_bytes.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_terminate_and_stay_resident,  Next: __dpmi_unlock_linear_region,  Prev: __dpmi_simulate_real_mode_procedure_retf_stack,  Up: Alphabetical List

__dpmi_terminate_and_stay_resident
==================================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_terminate_and_stay_resident(int return_code, int paragraphs_to_keep);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0c01 (DPMI 1.0 only)

See the spec.

Return Value
------------

This call does not return.


File: libc,  Node: __dpmi_unlock_linear_region,  Next: __dpmi_yield,  Prev: __dpmi_terminate_and_stay_resident,  Up: Alphabetical List

__dpmi_unlock_linear_region
===========================

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_unlock_linear_region(__dpmi_meminfo *_info);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

DPMI function AX = 0x0601

This function unlocks virtual memory.  Pass address and size (in bytes).

Return Value
------------

-1 on error, else zero.


File: libc,  Node: __dpmi_yield,  Next: dup,  Prev: __dpmi_unlock_linear_region,  Up: Alphabetical List

__dpmi_yield
============

Syntax
------

     #include <dpmi.h>
     
     int __dpmi_yield(void);

Description
-----------

Please refer to *Note DPMI Specification:: for details on DPMI function
call operation.  Also see *Note DPMI Overview:: for general information.

INT 0x2f, AX = 0x1680

This function yields the CPU to the next process.  This should be
called in busy-wait loops.

Return Value
------------

None.


File: libc,  Node: dup,  Next: dup2,  Prev: __dpmi_yield,  Up: Alphabetical List

dup
===

Syntax
------

     #include <unistd.h>
     
     int dup(int old_handle);

Description
-----------

This function duplicates the given file handle.  Both handles refer to
the same file and file pointer.

Return Value
------------

The new file handle, or -1 if error.

Example
-------

     do_file(dup(fileno(stdin)));


File: libc,  Node: dup2,  Next: _dxe_load,  Prev: dup,  Up: Alphabetical List

dup2
====

Syntax
------

     #include <unistd.h>
     
     int dup2(int existing_handle, int new_handle);

Description
-----------

This call causes NEW_HANDLE to refer to the same file and file pointer
as EXISTING_HANDLE.  If NEW_HANDLE is an open file, it is closed.

Return Value
------------

The new handle, or -1 on error.

Example
-------

     /* copy new file to stdin stream */
     close(0);
     dup2(new_stdin, 0);
     close(new_stdin);


File: libc,  Node: _dxe_load,  Next: enable,  Prev: dup2,  Up: Alphabetical List

_dxe_load
=========

Syntax
------

     #include <sys/dxe.h>
     
     void *_dxe_load(char *dxe_filename);
     
       static int (*add)(int a, int b);
     
       add = _dxe_load("add.dxe");
       if (add == 0)
         printf("Cannot load add.dxe\n");
       else
         printf("Okay, 3 + 4 = %d\n", add(3,4));

Description
-----------

This function loads a dynamic executable image into memory and returns
the entry point for the symbol associated with the image.  The symbol
may point to a structure or a function.

Return Value
------------

0 on failure, the address of the loaded symbol on success.


File: libc,  Node: enable,  Next: endgrent,  Prev: _dxe_load,  Up: Alphabetical List

enable
======

Syntax
------

     #include <dos.h>
     
     int enable(void);

Description
-----------

This function enables interrupts.

*Note disable::.

Return Value
------------

Returns nonzero if the interrupts were already enabled, zero if they
had been disabled before this call.

Example
-------

     int ints_were_enabled;
     
     ints_were_enabled = enable();
     . . . do some stuff . . .
     if (!ints_were_enabled)
       disable();


File: libc,  Node: endgrent,  Next: endmntent,  Prev: enable,  Up: Alphabetical List

endgrent
========

Syntax
------

     #include <grp.h>
     
     void endgrent(void);

Description
-----------

This function should be called after all calls to `getgrent',
`getgrgid', or `getgrnam'.

Return Value
------------

None.

Example
-------

*Note getgrent::.


File: libc,  Node: endmntent,  Next: endpwent,  Prev: endgrent,  Up: Alphabetical List

endmntent
=========

Syntax
------

     #include <mntent.h>
     
     int endmntent(FILE *filep);

Description
-----------

This function should be called after the last call to getmntent (*note
getmntent::.).

Return Value
------------

This function always returns one.


File: libc,  Node: endpwent,  Next: errno,  Prev: endmntent,  Up: Alphabetical List

endpwent
========

Syntax
------

     #include <pwd.h>
     
     void endpwent(void);

Description
-----------

This function should be called after the last call to getpwent (*note
getpwent::.).

Return Value
------------

None.


File: libc,  Node: errno,  Next: exec*,  Prev: endpwent,  Up: Alphabetical List

errno
=====

Syntax
------

     #include <errno.h>
     
     extern int errno;

Description
-----------

This variable is used to hold the value of the error of the last
function call.  The value might be one of the following:

`0'
     No Error

`1'
     EDOM - Input to function out of range

`2'
     ERANGE - Output of function out of range

`3'
     E2BIG - Argument list too long

`4'
     EACCES - Permission denied

`5'
     EAGAIN - Resource temporarily unavailable

`6'
     EBADF - Bad file descriptor

`7'
     EBUSY - Resource busy

`8'
     ECHILD - No child processes

`9'
     EDEADLK - Resource deadlock avoided

`10'
     EEXIST - File exists

`11'
     EFAULT - Bad address

`12'
     EFBIG - File too large

`13'
     EINTR - Interrupted system call

`14'
     EINVAL - Invalid argument

`15'
     EIO - Input or output

`16'
     EISDIR - Is a directory

`17'
     EMFILE - Too many open files

`18'
     EMLINK - Too many links

`19'
     ENAMETOOLONG - File name too long

`20'
     ENFILE - Too many open files in system

`21'
     ENODEV - No such device

`22'
     ENOENT - No such file or directory

`23'
     ENOEXEC - Unable to execute file

`24'
     ENOLCK - No locks available

`25'
     ENOMEM - Not enough memory

`26'
     ENOSPC - No space left on drive

`27'
     ENOSYS - Function not implemented

`28'
     ENOTDIR - Not a directory

`29'
     ENOTEMPTY - Directory not empty

`30'
     ENOTTY - Inappropriate I/O control operation

`31'
     ENXIO - No such device or address

`32'
     EPERM - Operation not permitted

`33'
     EPIPE - Broken pipe

`34'
     EROFS - Read-only file system

`35'
     ESPIPE - Invalid seek

`36'
     ESRCH - No such process

`37'
     EXDEV - Improper link

`38'
     ENMFILE - No more files

*Note perror::.


File: libc,  Node: exec*,  Next: _exit,  Prev: errno,  Up: Alphabetical List

exec*
=====

Syntax
------

     #include <unistd.h>
     
     int execl(const char *path, const char *argv0, ...);
     int execle(const char *path, const char *argv0, ... /*, char *const envp[] */);
     int execlp(const char *path, const char *argv0, ...);
     int execlpe(const char *path, const char *argv0, ... /*, char *const envp[] */);
     
     int execv(const char *path, char *const argv[]);
     int execve(const char *path, char *const argv[], char *const envp[]);
     int execvp(const char *path, char *const argv[]);
     int execvpe(const char *path, char *const argv[], char *const envp[]);

Description
-----------

These functions operate by calling `spawn*' with a type of `P_OVERLAY'.
Refer to *Note spawn*:: for a full description.

Return Value
------------

If successful, these functions do not return.  If there is an error,
these functions return -1 and set `errno' to indicate the error.

Example
-------

     execlp("gcc", "gcc", "-v", "hello.c", 0);


File: libc,  Node: _exit,  Next: exit,  Prev: exec*,  Up: Alphabetical List

_exit
=====

Syntax
------

     #include <stdlib.h>
     
     void _exit(int exit_code);

Description
-----------

This function exits the program, returning EXIT_CODE to the calling
process.  No additional processing is done, and any `atexit' functions
are not called.  This function is normally called only by `exit'.
Since this does not unhook hardware interrupts, this can cause crashes
after the program exits.

Return Value
------------

This function does not return.


File: libc,  Node: exit,  Next: exp,  Prev: _exit,  Up: Alphabetical List

exit
====

Syntax
------

     #include <stdlib.h>
     
     void exit(int exit_code);

Description
-----------

This function exits the program, returning EXIT_CODE to the calling
process.  Before exiting, all open files are closed and all `atexit'
and `on_exit' requests are processed.

Return Value
------------

This function does not return.

Example
-------

     if (argc < 4)
     {
       print_usage();
       exit(1);
     }


File: libc,  Node: exp,  Next: fabs,  Prev: exit,  Up: Alphabetical List

exp
===

Syntax
------

     #include <math.h>
     
     double exp(double x);

Return Value
------------

e to the X power.


File: libc,  Node: fabs,  Next: _far*,  Prev: exp,  Up: Alphabetical List

fabs
====

Syntax
------

     #include <math.h>
     
     double fabs(double x);

Return Value
------------

X if X is positive, else -X.  Note that in this context, +0.0 is
positive and -0.0 is negative.


File: libc,  Node: _far*,  Next: fclose,  Prev: fabs,  Up: Alphabetical List

_far*
=====

Syntax
------

     #include <sys/farptr.h>
     
     unsigned char _farpeekb(unsigned short selector, unsigned long offset);
     unsigned short _farpeekw(unsigned short selector, unsigned long offset);
     unsigned long _farpeekl(unsigned short selector, unsigned long offset);
     
     void _farpokeb(unsigned short sel, unsigned long off, unsigned char val);
     void _farpokew(unsigned short sel, unsigned long off, unsigned short val);
     void _farpokel(unsigned short sel, unsigned long off, unsigned long val);
     
     void _farsetsel(unsigned short selector);
     
     void _farnspokeb(unsigned long offset, unsigned char value);
     void _farnspokew(unsigned long offset, unsigned short value);
     void _farnspokel(unsigned long offset, unsigned long value);
     
     unsigned char _farnspeekb(unsigned long offset);
     unsigned short _farnspeekw(unsigned long offset);
     unsigned long _farnspeekl(unsigned long offset);

Description
-----------

These functions provide the equivalent functionality of "far pointers"
to peek or poke an absolute memory addresses, even though gcc doesn't
understand the keyword "far".  They come in handy when you need to
access memory-mapped devices (like VGA) or some address in lower memory
returned by a real-mode service.  These functions are provided as
inline assembler functions, so when you optimize your program they
reduce to only a few opcodes (only one more than a regular memory
access), resulting in very optimal code.

The first two groups of functions take a SELECTOR and an OFFSET.  This
selector is *not* a dos segment.  If you want to access dos memory,
pass _go32_info_block.selector_for_linear_memory (or just _dos_ds) as
the selector, and seg*16+ofs as the offset.  For functions which poke
the memory, you should also provide the VALUE to put there.

The last two groups assume that you've used `_farsetsel' to specify the
selector.  You should avoid making any function calls between
`_farsetsel' and using these other functions, unless you're absolutely
sure that they won't modify that selector.  This allows you to optimize
loops by setting the selector once outside the loop, and using the
shorter functions within the loop.

Return Value
------------

Functions which peek the address return the value at given address.


File: libc,  Node: fclose,  Next: fcntl,  Prev: _far*,  Up: Alphabetical List

fclose
======

Syntax
------

     #include <stdio.h>
     
     int fclose(FILE *file);

Description
-----------

This function closes the given FILE.

Return Value
------------

Zero on success, else `EOF'.

Example
-------

     FILE *f = fopen("data", "r");
     fprintf(f, "Hello\n");
     fclose(f);


File: libc,  Node: fcntl,  Next: fdopen,  Prev: fclose,  Up: Alphabetical List

fcntl
=====

Syntax
------

     #include <fcntl.h>
     
     int fcntl(int fd, int cmd, ...);

Description
-----------

This function   currently only  supports CMD  of `F_DUPFD', which acts
like `dup(fd)' (*note dup::.).

Return Value
------------

Varies.


File: libc,  Node: fdopen,  Next: feof,  Prev: fcntl,  Up: Alphabetical List

fdopen
======

Syntax
------

     #include <stdio.h>
     
     FILE *fdopen(int fd, const char *mode);

Description
-----------

This function opens a stream-type file that uses the given FD file,
which must already be open.  The file is opened with the modes
specified by MODE, which is the same as for `fopen'.  *Note fopen::.

Return Value
------------

The newly created `FILE *', or `NULL' on error.

Example
-------

     FILE *stdprn = fdopen(4, "w");


File: libc,  Node: feof,  Next: ferror,  Prev: fdopen,  Up: Alphabetical List

feof
====

Syntax
------

     #include <stdio.h>
     
     int feof(FILE *file);

Description
-----------

This function can be used to indicate if the given FILE is at the
end-of-file or not.

Return Value
------------

Nonzero at end-of-file, zero otherwise.

Example
-------

     while (!feof(stdin))
       gets(line);


File: libc,  Node: ferror,  Next: fflush,  Prev: feof,  Up: Alphabetical List

ferror
======

Syntax
------

     #include <stdio.h>
     
     int ferror(FILE *file);

Description
-----------

This function can be used to indicate if the given FILE has encountered
an error or not.  *Note clearerr::.

Return Value
------------

Nonzero for an error, zero otherwize.

Example
-------

     if (ferror(stdin))
       exit(1);


File: libc,  Node: fflush,  Next: ffs,  Prev: ferror,  Up: Alphabetical List

fflush
======

Syntax
------

     #include <stdio.h>
     
     int fflush(FILE *file);

Description
-----------

This function causes any unwritten buffered data to be written out to
the given FILE.  This is useful in cases where the output is line
buffered and you want to write a partial line.

Return Value
------------

Zero on success, -1 on error.

Example
-------

     printf("Enter value : ");
     fflush(stdout);
     scanf(result);


File: libc,  Node: ffs,  Next: fgetc,  Prev: fflush,  Up: Alphabetical List

ffs
===

Syntax
------

     #include <string.h>
     
     int ffs(int _mask);

Description
-----------

This function find the first (least significant) bit set in the input
value.

Return Value
------------

Bit position (1..32) of the least significant set bit, or zero if the
input value is zero.

Example
-------

     ffs(0) = 0
     ffs(1) = 1
     ffs(5) = 1
     ffs(96) = 6


File: libc,  Node: fgetc,  Next: fgetgrent,  Prev: ffs,  Up: Alphabetical List

fgetc
=====

Syntax
------

     #include <stdio.h>
     
     int fgetc(FILE *file);

Description
-----------

Returns the next character in the given FILE as an unsigned char.

Return Value
------------

The given char (value 0..255) or `EOF' at end-of-file.

Example
-------

     int c;
     while((c=fgetc(stdin)) != EOF)
       fputc(c, stdout);


File: libc,  Node: fgetgrent,  Next: fgetpos,  Prev: fgetc,  Up: Alphabetical List

fgetgrent
=========

Syntax
------

     #include <grp.h>
     
     struct group *fgetgrent(FILE *file);

Description
-----------

This function, in MS-DOS, is exactly the same as `getgrent' (*note
getgrent::.).


File: libc,  Node: fgetpos,  Next: fgets,  Prev: fgetgrent,  Up: Alphabetical List

fgetpos
=======

Syntax
------

     #include <stdio.h>
     
     int fgetpos(FILE *file, fpos_t *offset);

Description
-----------

This function records the current file pointer for FILE, for later use
by `fsetpos'.

*Note fsetpos::.  *Note ftell::.

Return Value
------------

Zero if successful, nonzero if not.


File: libc,  Node: fgets,  Next: File System Extensions,  Prev: fgetpos,  Up: Alphabetical List

fgets
=====

Syntax
------

     #include <stdio.h>
     
     char *fgets(char *buffer, int maxlength, FILE *file);

Description
-----------

This function reads as much of a line from a file as possible, stopping
when the buffer is full (MAXLENGTH-1 characters), an end-of-line is
detected, or `EOF' or an error is detected.  It then stores a `NULL' to
terminate the string.

Return Value
------------

The address of the buffer is returned on success, if `EOF' is
encountered before any characters are stored, or if an error is
detected, `NULL' is returned instead.

Example
-------

     char buf[100];
     while (fgets(buf, 100, stdin))
       fputs(buf, stdout);


File: libc,  Node: File System Extensions,  Next: __file_exists,  Prev: fgets,  Up: Alphabetical List

File System Extensions
======================

Description
-----------

The File System Extensions are a part of the lowest level of I/O
operations in the C runtime library of DJGPP.  These extensions are
provided to allow for cases where Unix uses a file descriptor to access
such items as serial ports, memory, and the network, but DOS does not.
It allows a set of functions (called an extension) to gain control when
one of these low-level functions is called on a file descriptor set up
by the extension.

Each extension must provide one or two handler functions.  All handler
functions take the same arguments:

       int function(__FDEXT_Fnumber func_number, int *rv, va_args *args);

The FUNC_NUMBER identifies which function is to be emulated.  The file
`<sys/fsext.h>' lists the function numbers.  RV points to a temporary
return value pointer.  If the function is emulated, the return value
should be stored here, and the function should return a nonzero value.
If the function returns zero, it is assumed to have not emulated the
call, and the regular DOS I/O function will happen.  The ARGS represent
the arguments passed to the original function; these point to the
actual arguments on the stack, so the emulation may choose to modify
them and return zero to the regular function, which will then act on
the modified arguments.

A normal extension would provide these parts:

   *  Some function to create a connection to the extension.  This may
     be a custom function (such as `socket' for networking) or an
     extension to open (such as for `/dev/null' emulation).

   *  Initialization code that adds the open handler, if any.

   *  Overrides for the basic I/O functions, such as `read' and
     `write'.  This is a single function in the extension that uses the
     function number parameter to select an extension function.

   *  The core functionality of the extension, if any.


File: libc,  Node: __file_exists,  Next: file_tree_walk,  Prev: File System Extensions,  Up: Alphabetical List

__file_exists
=============

Syntax
------

     #include <unistd.h>
     
     int __file_exists(const char *_fn);

Description
-----------

This function provides a fast way to ask if a given file exists.
Unlike access(), this function does not cause other objects to get
linked in with your program, so is used primarily by the startup code
to keep minimum code size small.

Return Value
------------

Zero if the file does not exist, nonzero if it does.  Note that this is
the opposite of what access() returns.

Example
-------


     if (__file_exists(fname))
       process_file(fname);


File: libc,  Node: file_tree_walk,  Next: filelength,  Prev: __file_exists,  Up: Alphabetical List

file_tree_walk
==============

Syntax
------

     #include <dir.h>
     
     int __file_tree_walk(const char *dir,
                        int (*func)(const char *path, const struct ffblk *ff));

Description
-----------

This function recursively descends the directory hierarchy which starts
with DIR.  For each file in the hierarchy, `__file_tree_walk' calls the
user-defined function FUNC which is passed a pointer to a
`NULL'-terminated character array in PATH holding the full pathname of
the file, a pointer to a `ffblk' structure (*note findfirst::.) FFF
with a DOS filesystem information about that file.

This function always visits a directory before any of its siblings.  The
argument DIR must be a directory, or `__file_tree_walk' will fail and
set ERRNO to `ENOTDIR'.  The directory DIR itself is never passed to
FUNC.

The tree traversal continues until one of the following events:

(1)  The tree is exhausted (i.e., all descendants of DIR are
processed).  In this case, `__file_tree_walk' returns 0, meaning a
success.

(2)  An invocation of FUNC returns a non-zero value.  In this case,
`__file_tree_walk' stops the tree traversal and returns whatever FUNC
returned.

(3)  An error is detected within `__file_tree_walk'.  In that case,
`ftw' returns -1 and sets ERRNO (*note errno::.) to a suitable value.

Return Value
------------

Zero in case the entire tree was successfully traversed, -1 if
`__file_tree_walk' detected some error during its operation, or any
other non-zero value which was returned by the user-defined function
FUNC.

Example
-------

     #include <stdlib.h>
     
     int
     ff_walker(const char *path, const struct ffblk *ff)
     {
       printf("%s:\t%lu\t", path, ff->ff_fsize);
       if (ff->ff_attrib & 1)
         printf("R");
       if (ff->ff_attrib & 2)
         printf("H");
       if (ff->ff_attrib & 4)
         printf("S");
       if (ff->ff_attrib & 8)
         printf("V");
       if (ff->ff_attrib & 0x10)
         printf("D");
       if (ff->ff_attrib & 0x20)
         printf("A");
       printf("\n");
     
       if (strcmp(ff->ff_name, "XXXXX") == 0)
         return 42;
       return 0;
     }
     
     int
     main(int argc, char *argv[])
     {
       if (argc > 1)
         {
           char msg[80];
     
           sprintf(msg, "__file_tree_walk: %d",
                        __file_tree_walk(argv[1], ff_walker));
           if (errno)
             perror(msg);
           else
             puts(msg);
         }
       else
         printf("Usage: %s dir\n", argv[0]);
     
       return 0;
     }


File: libc,  Node: filelength,  Next: fileno,  Prev: file_tree_walk,  Up: Alphabetical List

filelength
==========

Syntax
------

     #include <io.h>
     
     long filelength(int fhandle);

Description
-----------

This function returns the size, in bytes, of a file whose handle is
specified in the argument FHANDLE.  To get the handle of a file opened
by *Note fopen:: or *Note freopen::, you can use *Note fileno:: macro.

Return Value
------------

The size of the file in bytes, or (if any error occured) -1L and ERRNO
set to a value describing the cause of the failure.

Example
-------

       printf("Size of file to which STDIN is redirected is %ld\n",
               filelength(0));


File: libc,  Node: fileno,  Next: findfirst,  Prev: filelength,  Up: Alphabetical List

fileno
======

Syntax
------

     #include <stdio.h>
     
     int fileno(FILE *file);

Description
-----------

This function returns the raw file descriptor number that FILE uses for
I/O.

Return Value
------------

The file descriptor number.


File: libc,  Node: findfirst,  Next: findnext,  Prev: fileno,  Up: Alphabetical List

findfirst
=========

Syntax
------

     #include <dir.h>
     
     int findfirst(const char *pathname, struct ffblk *ffblk, int attrib);

Description
-----------

This function and the related `findnext' (*note findnext::.) are used
to scan directories for the list of files therein.  The PATHNAME is a
wildcard that specifies the directory and files to search for (such as
`subdir/*.c'), FFBLK is a structure to hold the results and state of
the search, and ATTRIB is a combination of the following:

`FA_RDONLY'
     Include read-only files in the search

`FA_HIDDEN'
     Include hidden files in the search

`FA_SYSTEM'
     Include system files in the search

`FA_LABEL'
     Include the volume label in the search

`FA_DIREC'
     Include subdirectories in the search

`FA_ARCH'
     Include modified files in the search

Any file that doesn't have any flag bits that aren't specified is
selected for the search.  Thus, if you specified `FA_DIREC' and
`FA_LABEL', you would get all subdirectories, the volume label, and any
file that is neither read-only or modified.

The results of the search are stored in FFBLK:

     struct ffblk {
       char ff_reserved[21];     /* used to hold the state of the search */
       unsigned char ff_attrib;  /* actual attributes of the file found */
       unsigned short ff_ftime;  /* hours:5, minutes:6, (seconds/2):5 */
       unsigned short ff_fdate;  /* (year-1980):7, month:4, day:5 */
       unsigned long ff_fsize;   /* size of file */
       char ff_name[16];         /* name of file as ASCIIZ string */
     }

Return Value
------------

Zero if a match is found, nonzero if none found.

Example
-------

     struct ffblk f;
     int done = findfirst("*.exe", &f, FA_ARCH|FA_RDONLY);
     while (!done)
     {
       printf("%10u %2u:%02u:%02u %2u/%02u/%4u %s\n",
         f.ff_fsize,
         (f.ff_ftime >> 11) & 0x1f,
         (f.ff_ftime >>  5) & 0x3f,
         (f.ff_ftime & 0x1f) * 2,
         (f.ff_fdate >>  5) & 0x0f,
         (f.ff_fdate & 0x1f),
         ((f.ff_fdate >> 9) & 0x7f) + 1980,
         f.ff_name);
       done = findnext(&f);
     }


File: libc,  Node: findnext,  Next: _fixpath,  Prev: findfirst,  Up: Alphabetical List

findnext
========

Syntax
------

     #include <dir.h>
     
     int findnext(struct ffblk *ffblk);

Description
-----------

This finds the next file in the search started by `findfirst'.  *Note
findfirst::.

Return Value
------------

Zero if there was a match, else nonzero.


File: libc,  Node: _fixpath,  Next: floor,  Prev: findnext,  Up: Alphabetical List

_fixpath
========

Syntax
------

     #include <sys/stat.h>
     
     void _fixpath(const char *in_path, char *out_path);

Description
-----------

This function canonacalizes the input path IN_PATH and stores the
result in the buffer pointed to by OUT_PATH.

The path is fixed by removing consecutive and trailing slashes, making
the path absolute if it's relative, removing "." components, collapsing
".." components, adding a drive specifier if needed, and converting all
slashes to '/'.

Return Value
------------

None.

Example
-------

     char oldpath[100], newpath[100];
     scanf(oldpath);
     _fixpath(oldpath, newpath);
     printf("that really is %s\n", newpath);


File: libc,  Node: floor,  Next: fmod,  Prev: _fixpath,  Up: Alphabetical List

floor
=====

Syntax
------

     #include <math.h>
     
     double floor(double x);

Return Value
------------

The largest integer value less than or equal to X.


File: libc,  Node: fmod,  Next: _fmode,  Prev: floor,  Up: Alphabetical List

fmod
====

Syntax
------

     #include <math.h>
     
     double fmod(double x, double y);

Return Value
------------

The remainder of X/Y.


File: libc,  Node: _fmode,  Next: fnmatch,  Prev: fmod,  Up: Alphabetical List

_fmode
======

Syntax
------

     #include <fcntl.h>
     
     extern int _fmode;

Description
-----------

This variable may be set to `O_TEXT' or `O_BINARY' to specify the mode
that newly opened files should be opened in if the open call did not
specify.  *Note open::. *Note fopen::.

The default value is `O_TEXT'.

Example
-------

     _fmode = O_BINARY;


File: libc,  Node: fnmatch,  Next: fnmerge,  Prev: _fmode,  Up: Alphabetical List

fnmatch
=======

Syntax
------

     #include <fnmatch.h>
     
     int fnmatch(const char *pattern, const char *string, int flags);

Description
-----------

This function indicates if STRING matches the PATTERN.  The pattern may
include the following special characters:

`*'
     Matches zero of more characters.

`?'
     Matches exactly one character

`[...]'
     Matches one character if it's in a range of characters.  If the
     first character is `!', matches if the character is not in the
     range.  Between the brackets, the range is specified by listing
     the characters that are in the range, or two characters separated
     by `-' to indicate all characters in that range.  For example,
     `[a-d]' matches `a', `b', `c', or `d'.

`\'
     Causes the next character to not be treated as a wildcard.  For
     example, `\*' matches an asterisk.  This is only available if FLAGS
     includes `FNM_QUOTE'.

The value of FLAGS is a combination of zero of more of the following:

`FNM_PATHNAME'
     This means that the string should be treated as a pathname, in
     that the slash character `/' never matches any of the wildcards.

`FNM_QUOTE'
     This means that the backslash `\\' may be used for quoting special
     characters in the pattern.

Return Value
------------

Zero if the string matches, FNM_NOMATCH if it does not.

Example
-------

     if (fnmatch("*.[ch]", filename, FNM_PATH|FNM_QUOTE))
       do_source_file(filename);


File: libc,  Node: fnmerge,  Next: fnsplit,  Prev: fnmatch,  Up: Alphabetical List

fnmerge
=======

Syntax
------

     #include <dir.h>
     
     void fnmerge (char *path, const char *drive, const char *dir,
     		const char *name, const char *ext);

Description
-----------

This function constructs a file PATH from its components DRIVE, DIR,
NAME, and EXT.  If any of these is a `NULL' pointer, it won't be used.
Usually, the DRIVE string should include the trailing colon ``:'', the
DIR string should include the trailing slash ``/'' or backslash ``\'',
and the EXT string should include the leading dot ``.''.  However, if
any of these isn't present, `fnmerge' will add them.

*Note fnsplit::.

Return Value
------------

None.

Example
-------

     char buf[MAXPATH];
     fnmerge(buf, "d:", "/foo/", "data", ".txt");


File: libc,  Node: fnsplit,  Next: fopen,  Prev: fnmerge,  Up: Alphabetical List

fnsplit
=======

Syntax
------

     #include <dir.h>
     
     int fnsplit (const char *path, char *drive, char *dir,
     		char *name, char *ext);

Description
-----------

This function decomposes a PATH into its components.  It is smart
enough to know that `.' and `..' are directories.  The DRIVE, DIR, NAME
and EXT arguments should all be passed, but some or even all of them
might be `NULL' pointers.  Those of them which are non-`NULL' should
point to buffers which have enough room for the strings they would
hold.  The constants `MAXDRIVE', `MAXDIR', `MAXFILE' and `MAXEXT',
defined on dir.h, define the maximum length of these buffers.

*Note fnmerge::.

Return Value
------------

A flag that indicates which components were found:

`DRIVE'
     The drive letter was found.

`DIRECTORY'
     A directory or subdirectories was found.

`FILENAME'
     A filename was found.

`EXTENSION'
     An extension was found.

`WILDCARDS'
     The path included `*' or `?'.

Example
-------

     char d[MAXDRIVE], p[MAXDIR], f[MAXFILE], e[MAXEXT];
     int which = fnsplit("d:/djgpp/bin/gcc.exe", d, p, f, e);
     d = "d:"
     p = "/djgpp/bin/"
     f = "gcc"
     e = ".exe"


File: libc,  Node: fopen,  Next: fork,  Prev: fnsplit,  Up: Alphabetical List

fopen
=====

Syntax
------

     #include <stdio.h>
     FILE *fopen(const char *filename, const char *mode);

Description
-----------

This function opens a stream corresponding to the named FILENAME with
the given MODE.  The mode can be one of the following:

`r'
     Open an existing file for reading.

`w'
     Create a new file (or truncate an existing file) and open it for
     writing.

`a'
     Open an existing file (or create a new one) for writing.  The file
     pointer is positioned to the end of the file before every write.

Followed by any of these characters:

`b'
     Force the file to be open in binary mode instead of the default
     mode.

`t'
     Force the file to be open in text mode instead of the default mode.

`+'
     Open the file as with `O_RDWR' so that both reads and writes can
     be done to the same file.

If the file is open for both reading and writing, you must call
`fflush', `fseek', or `rewind' before switching from read to write or
from write to read.

The open file is set to line buffered if the underlying object is a
device (stdin, stdout, etc), or is fully buffered if the underlying
object is a disk file (data.c, etc).

If `b' or `t' is not specified in MODE, the file type is chosen by the
value of `fmode' (*note _fmode::.).

Return Value
------------

A pointer to the `FILE' object, or `NULL' if there was an error.

Example
-------

     FILE *f = fopen("foo", "rb+"); /* open existing file for read/write, binary mode */


File: libc,  Node: fork,  Next: fpathconf,  Prev: fopen,  Up: Alphabetical List

fork
====

Description
-----------

This function always returns -1 and sets `errno' to ENOMEM, as MS-DOS
does not support multiple processes.  It exists only to assist in
porting Unix programs.


File: libc,  Node: fpathconf,  Next: _fpreset,  Prev: fork,  Up: Alphabetical List

fpathconf
=========

Syntax
------

     #include <unistd.h>
     
     long fpathconf(int fd, int name);

Description
-----------

Returns configuration information on the filesystem that the open file
resides on.  *Note pathconf::.

Return Value
------------

The configuration value, which are currently independent of the
filesystem that the file is on.


File: libc,  Node: _fpreset,  Next: fprintf,  Prev: fpathconf,  Up: Alphabetical List

_fpreset
========

Syntax
------

     #include <float.h>
     
     void _fpreset(void);

Description
-----------

Resets the FPU completely.


File: libc,  Node: fprintf,  Next: fpurge,  Prev: _fpreset,  Up: Alphabetical List

fprintf
=======

Syntax
------

     #include <stdio.h>
     
     int fprintf(FILE *file, const char *format, ...);

Description
-----------

Prints formatted output to the named file.  *Note printf::.

Return Value
------------

The number of characters written.


File: libc,  Node: fpurge,  Next: fputc,  Prev: fprintf,  Up: Alphabetical List

fpurge
======

Syntax
------

     #include <stdio.h>
     
     int fpurge(FILE *file);

Description
-----------

This function purges the buffer for FILE without writing it to disk.

Return Value
------------

Zero on success, -1 on failure.


File: libc,  Node: fputc,  Next: fputs,  Prev: fpurge,  Up: Alphabetical List

fputc
=====

Syntax
------

     #include <stdio.h>
     
     int fputc(int character, FILE *file);

Description
-----------

This function writes the given CHARACTER to the given `file'.

Return Value
------------

The given character [0..255] or `EOF'.

Example
-------

     fputc('\n', stdout);


File: libc,  Node: fputs,  Next: fread,  Prev: fputc,  Up: Alphabetical List

fputs
=====

Syntax
------

     #include <stdio.h>
     
     int fputs(const char *string, FILE *file);

Description
-----------

This function all the characters of STRING (except the trailing `NULL')
to the given FILE.

Return Value
------------

A nonnegative number on success, `EOF' on error.

Example
-------

     fputs("Hello\n", stdout);


File: libc,  Node: fread,  Next: free,  Prev: fputs,  Up: Alphabetical List

fread
=====

Syntax
------

     #include <stdio.h>
     
     size_t fread(void *buffer, size_t size, size_t number, FILE *file);

Description
-----------

This function reads SIZE*NUMBER characters from FILE to BUFFER.

Return Value
------------

The number of items of size SIZE read, or -1 on error.

Example
-------

     int foo[10];
     fread(foo, sizeof(int), 10, stdin);


File: libc,  Node: free,  Next: freopen,  Prev: fread,  Up: Alphabetical List

free
====

Syntax
------

     #include <stdio.h>
     
     void free(void *ptr);

Description
-----------

Returns the allocated memory to the heap (*note malloc::.).  If the PTR
is `NULL', it does nothing.

Return Value
------------

None.

Example
-------

     char *q = (char *)malloc(20);
     free(q);


File: libc,  Node: freopen,  Next: frexp,  Prev: free,  Up: Alphabetical List

freopen
=======

Syntax
------

     #include <stdio.h>
     
     FILE *freopen(const char *filename, const char *mode, FILE *file);

Description
-----------

This function closes FILE if it was open, then opens a new file like
`fopen(filename, mode)' but it reuses FILE.

This is useful to, for example, associate `stdout' with a new file.

Return Value
------------

The new file, or `NULL' on error.

Example
-------

     freopen("/tmp/stdout.dat", "wb", stdout);


File: libc,  Node: frexp,  Next: fscanf,  Prev: freopen,  Up: Alphabetical List

frexp
=====

Syntax
------

     #include <math.h>
     
     double frexp(double x, int *pexp);

Description
-----------

This function separates the given value X into a mantissa [0.5,1) and
an exponent *PEXP, such that m * 2 ^ e = x.  As an exception, when X is
zero, *PEXP and the return value are also both zero.

Return Value
------------

The mantissa.


File: libc,  Node: fscanf,  Next: fseek,  Prev: frexp,  Up: Alphabetical List

fscanf
======

Syntax
------

     #include <stdio.h>
     
     int fscanf(FILE *file, const char *format, ...);

Description
-----------

This function scans formatted text from FILE and stores it in the
variables pointed to by the arguments.  *Note scanf::.

Return Value
------------

The number of items successfully scanned.


File: libc,  Node: fseek,  Next: fsetpos,  Prev: fscanf,  Up: Alphabetical List

fseek
=====

Syntax
------

     #include <stdio.h>
     
     int fseek(FILE *file, long offset, int mode);

Description
-----------

This function moves the file pointer for FILE according to MODE:

`SEEK_SET'
     The file pointer is moved to the offset specified.

`SEEK_CUR'
     The file pointer is moved relative to its current position.

`SEEK_END'
     The file pointer is moved to a position OFFSET bytes from the end
     of the file.  The offset is usually nonpositive in this case.

*Warning!* The ANSI standard only allows values of zero for OFFSET when
WHENCE is not `SEEK_SET' and the file has been opened as a text file.
Although this restriction is not enforced, beware that there is not a
one-to-one correspondence between file characters and text characters
under MS-DOS, so some `fseek' operations may not do exactly what you
expect.

Return Value
------------

Zero if successful, nonzero if not.

Example
-------

     fseek(stdin, 12, SEEK_CUR); /* skip 12 bytes */


File: libc,  Node: fsetpos,  Next: __FSEXT_add_open_handler,  Prev: fseek,  Up: Alphabetical List

fsetpos
=======

Syntax
------

     #include <stdio.h>
     
     int fsetpos(FILE *file, const fpos_t *offset);

Description
-----------

This function moves the file pointer for FILE to position OFFSET, as
recorded by `fgetpos'.

*Note fgetpos::.  *Note fseek::.

Return Value
------------

Zero if successful, nonzero if not.


File: libc,  Node: __FSEXT_add_open_handler,  Next: __FSEXT_alloc_fd,  Prev: fsetpos,  Up: Alphabetical List

__FSEXT_add_open_handler
========================

Syntax
------

     #include <sys/fsext.h>
     
     int __FSEXT_add_open_handler(__FSEXT_Function *_function);

Description
-----------

This function is part of the *Note File System Extensions::.  It is used
to add a handler for functions that do not get passed descriptors, such
as `open' and `creat'.

Example
-------

     static int
     _my_handler(__FSEXT_Fnumber n, int *rv, va_args args)
     {
       . . .
     }
     
     int main()
     {
       __FSEXT_add_open_handler(_my_handler);
     }


File: libc,  Node: __FSEXT_alloc_fd,  Next: __FSEXT_call_open_handlers,  Prev: __FSEXT_add_open_handler,  Up: Alphabetical List

__FSEXT_alloc_fd
================

Syntax
------

     #include <sys/fsext.h>
     
     int __FSEXT_alloc_fd(__FSEXT_Function *_function);

Description
-----------

This function is part of the *Note File System Extensions::.  It is used
by extensions that fully emulate the I/O functions, and thus don't have
a corresponding DOS file handle.  This function opens DOS's "nul"
device, so as to allocate a handle that DOS won't then reuse.  It also
assigns the handler function for that descriptor.

The module is responsible for calling `_close' on the descriptor after
setting the handler function to zero in the extended close handler.

Example
-------


     int socket()
     {
       int fd = __FSEXT_alloc_fd(socket_handler);
       init_socket(fd);
       return fd;
     }


File: libc,  Node: __FSEXT_call_open_handlers,  Next: __FSEXT_get_function,  Prev: __FSEXT_alloc_fd,  Up: Alphabetical List

__FSEXT_call_open_handlers
==========================

Syntax
------

     #include <sys/fsext.h>
     
     int __FSEXT_call_open_handlers(__FSEXT_Fnumber _function_number,
     			       int *rv, va_list _args);

Description
-----------

This function is part of the *Note File System Extensions::.  It is used
internally to libc.a to allow extensions to get an opportunity to
override the `open' and `creat' functions.


File: libc,  Node: __FSEXT_get_function,  Next: __FSEXT_set_function,  Prev: __FSEXT_call_open_handlers,  Up: Alphabetical List

__FSEXT_get_function
====================

Syntax
------

     #include <sys/fsext.h>
     
     __FSEXT_Function *__FSEXT_get_function(int _fd);

This function is part of the *Note File System Extensions::.  It is used
internal to libc.a to redirect I/O requests to the appropriate
extensions.

Example
-------

     _read(int fd, void *buf, int len)
     {
       __FSEXT_Function *func = __FSEXT_get_function(fd);
       if (func)
       {
         int rv;
         if (func(__FSEXT_read, &rv, &fd))
           return rv;
       }
       /* rest of read() */
     }


File: libc,  Node: __FSEXT_set_function,  Next: fstat,  Prev: __FSEXT_get_function,  Up: Alphabetical List

__FSEXT_set_function
====================

Syntax
------

     #include <sys/fsext.h>
     
     int __FSEXT_set_function(int _fd, __FSEXT_Function *_function);

Description
-----------

This function is part of the *Note File System Extensions::.  It is used
to set the handler function for those extensions that use DOS files for
I/O.  I can't think of any examples where you'd want to do this, but
it's here in case you do.


File: libc,  Node: fstat,  Next: fsync,  Prev: __FSEXT_set_function,  Up: Alphabetical List

fstat
=====

Syntax
------

     #include <sys/stat.h>
     
     int fstat(int file, struct stat *sbuf);

Description
-----------

This function obtains the status of the open file FILE and stores it in
SBUF.  *Note stat:: for the description of `struct stat' fields.

Return Value
------------

Zero on success, nonzero on failure (and ERRNO set).

Example
-------

     struct stat s;
     fstat(fileno(stdin), &s);
     if (S_ISREG(s.st_mode))
       puts("STDIN is a redirected disk file");
     else if (S_ISCHR(s.st_mode))
       puts("STDIN is a character device");

Bugs
----

If a file was open in write-only mode, its execute mode bits might be
incorrectly reported as if the file were non-executable.  This is
because some executables are only recognized by reading their first two
bytes, which cannot be done for files open in write-only mode.

For `fstat()' to return valid info, you should make sure that all the
data written to the file has been delivered to the operating system,
e.g. by calling `fflush()'.  Otherwise, the buffering of the library
I/O functions might cause stale info to be returned.

Implementation Notes
--------------------

Supplying a 100% Unix-compatible `f?stat()' functions under DOS is an
implementation nightmare.  The following notes describe some of the
obscure points specific to their behavior in DJGPP.

1. The `drive' for character devices (like `con', `/dev/nul' and others
is returned as -1.  For drives networked by Novell Netware, it is
returned as -2.

2. The starting cluster number of a file serves as its inode number.
For files whose starting cluster number is inaccessible (empty files,
files on networked drives, etc.) the `st_inode' field will be `invented'
in a way which guarantees that no two different files will get the same
inode number (thus it is unique).  This invented inode will also be
different from any real cluster number of any local file.  However, only
for local, non-empty files/directories the inode is guaranteed to be
consistent between `stat()' and `fstat()' function calls.

3. The WRITE access mode bit is set only for the user (unless the file
is read-only, hidden or system).  EXECUTE bit is set for directories,
files which can be executed from the DOS prompt (batch files, .com,
.dll and .exe executables) or run by go32 extender.  For files which
reside on networked drives under Novell Netware, this can sometimes
fail, in which case only the read access bit is set.

4. Size of directories is reported as the number of its files (sans `.'
and `..' entries) multiplied by 32 bytes (the size of directory entry).

5. Time stamp for root directories is taken from the volume label entry,
if that's available; otherwise, it is reported as 1-Jan-1980.

6. The variable *Note _djstat_flags:: controls what hard-to-get fields
of `struct stat' are needed by the application.


File: libc,  Node: fsync,  Next: ftell,  Prev: fstat,  Up: Alphabetical List

fsync
=====

Syntax
------

     #include <unistd.h>
     
     int fsync(int file);

Description
-----------

Forces all information about the file to be synchronized with the disk
image.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     fsync(fileno(stdout));


File: libc,  Node: ftell,  Next: ftime,  Prev: fsync,  Up: Alphabetical List

ftell
=====

Syntax
------

     #include <stdio.h>
     
     long ftell(FILE *file);

Description
-----------

Returns the current file position for `file'.  This is suitable for a
future call to `fseek'.

Return Value
------------

The file position, or -1 on error.

Example
-------

     long p = ftell(stdout);


File: libc,  Node: ftime,  Next: ftruncate,  Prev: ftell,  Up: Alphabetical List

ftime
=====

Syntax
------

     #include <sys/timeb.h>
     
     int ftime(struct timeb *buf);

Description
-----------

This function stores the current time in the structure BUF.  The format
of `struct timeb' is:

     struct timeb {
       time_t         time;     /* seconds since 00:00:00 GMT 1/1/1970 */
       unsigned short millitm;  /* milliseconds */
       short          timezone; /* difference between GMT and local, minutes */
       short          dstflag;  /* set if daylight savings time in affect */
     };

Return Value
------------

Zero on success, nonzero on error.

Example
-------

     struct timeb t;
     ftime(&t);


File: libc,  Node: ftruncate,  Next: ftw,  Prev: ftime,  Up: Alphabetical List

ftruncate
=========

Syntax
------

     #include <unistd.h>
     
     int ftruncate(int file, off_t where);

Description
-----------

This function truncates FILE at WHERE length.  This only works if the
file is closed right after this call.

Return Value
------------

Zero for success, nonzero for failure.

Example
-------

     int x = open("data", O_WRONLY);
     ftruncate(x, 1000);
     close(x);


File: libc,  Node: ftw,  Next: _fwalk,  Prev: ftruncate,  Up: Alphabetical List

ftw
===

Syntax
------

     #include <ftw.h>
     
     int ftw(const char *dir,
             int (*func)(const char *path, struct stat *stbuf, int flag),
             int depth);

Description
-----------

This function recursively descends the directory hierarchy which starts
with DIR.  For each file in the hierarchy, `ftw' calls the user-defined
function FUNC which is passed a pointer to a `NULL'-terminated
character array in PATH holding the full pathname of the file, a
pointer to a `stat' structure (*note stat::.) STBUF with a filesystem
information about that file, and an integer FLAG.  Possible values of
FLAG are:

`FTW_F'
     This is a regular file.

`FTW_D'
     This is a directory.

`FTW_VL'
     This is a volume label.

`FTW_DNR'
     This is a directory which cannot be read with `readdir()'.  (This
     will never happen in DJGPP.)

`FTW_NS'
     This file exists, but `stat' fails for it.

If FLAG is `FTW_DNR', the descendants of that directory won't be
processed.  If FLAG is `FTW_NS', then STBUF will be garbled.

This function always visits a directory before any of its siblings.  The
argument DIR must be a directory, or `ftw' will fail and set ERRNO to
`ENOTDIR'.  The function FUNC is called with DIR as its argument before
the recursive descent begins.

The DEPTH argument has no meaning in the DJGPP implementation and is
always ignored.

The tree traversal continues until one of the following events:

(1)  The tree is exhausted (i.e., all descendants of DIR are
processed).  In this case, `ftw' returns 0, meaning a success.

(2)  An invocation of FUNC returns a non-zero value.  In this case,
`ftw' stops the tree traversal and returns whatever FUNC returned.

(3)  An error is detected within `ftw'.  In that case, `ftw' returns -1
and sets ERRNO (*note errno::.) to a suitable value.

Return Value
------------

Zero in case the entire tree was successfully traversed, -1 if `ftw'
detected some error during its operation, or any other non-zero value
which was returned by the user-defined function FUNC.

Implementation Notes
--------------------

This function uses `malloc' (*note malloc::.) for dynamic memory
allocation during its operation.  If FUNC disrupts the normal flow of
code execution by e.g. calling `longjump' or if an interrupt handler
which never returns is executed, this memory will remain permanently
allocated.

This function calls `opendir()' and `readdir()' functions to read the
directory entries.  Therefore, you can control what files will your
FUNC get by setting the appropriate bits in the external variable
__OPENDIR_FLAGS.  *Note opendir::, for description of these bits.

This function also calls `stat' for every directory entry it passes to
FUNC.  If your application only needs some part of the information
returned in the `stat' structure, you can make your application
significantly faster by setting bits in the external variable
_DJSTAT_FLAGS (*note _djstat_flags::. for details).  The most expensive
`stat' features are `_STAT_EXEC_MAGIC' and `_STAT_DIRSIZE'.

Example
-------

     #include <stdlib.h>
     
     int
     file_walker(const char *path, struct stat *sb, int flag)
     {
       char *base;
     
       printf("%s:\t%u\t", path, sb->st_size);
       if (S_ISLABEL(sb->st_mode))
         printf("V");
       if (S_ISDIR(sb->st_mode))
         printf("D");
       if (S_ISCHR(sb->st_mode))
         printf("C");
       if (sb->st_mode & S_IRUSR)
         printf("r");
       if (sb->st_mode & S_IWUSR)
         printf("w");
       if (sb->st_mode & S_IXUSR)
         printf("x");
     
       if (flag == FTW_NS)
         printf("  !!no_stat!!");
       printf("\n");
     
       base = strrchr(path, '/');
       if (base == 0)
         base = strrchr(path, '\\');
       if (base == 0)
         base = strrchr(path, ':');
       if (strcmp(base == 0 ? path : base + 1, "xxxxx") == 0)
         return 42;
       return 0;
     }
     
     int
     main(int argc, char *argv[])
     {
       if (argc > 1)
         {
           char msg[80];
     
           sprintf(msg, "file_tree_walk: %d",
                        ftw(argv[1], file_walker, 0));
           if (errno)
             perror(msg);
           else
             puts(msg);
         }
       else
         printf("Usage: %s dir\n", argv[0]);
     
       return 0;
     }


File: libc,  Node: _fwalk,  Next: fwrite,  Prev: ftw,  Up: Alphabetical List

_fwalk
======

Syntax
------

     void _fwalk(void (*function)(FILE *file));

Description
-----------

For each open file in the system, the given FUNCTION is called, passing
the file pointer as it's only argument

Return Value
------------

None.

Example
-------

     void pfile(FILE *x)
     { printf("FILE at %p\n", x); }
     
     _fwalk(pfile);


File: libc,  Node: fwrite,  Next: _get_dev_info,  Prev: _fwalk,  Up: Alphabetical List

fwrite
======

Syntax
------

     #include <stdio.h>
     
     size_t fwrite(void *buffer, size_t size, size_t number, FILE *file);

Description
-----------

This function writes SIZE*NUMBER characters from BUFFER to FILE.

Return Value
------------

The number of items of size SIZE written, or -1 on error.

Example
-------

     int foo[10];
     fwrite(foo, sizeof(int), 10, stdin);


File: libc,  Node: _get_dev_info,  Next: _get_dos_version,  Prev: fwrite,  Up: Alphabetical List

_get_dev_info
=============

Syntax
------

     #include <io.h>
     
     short _get_dev_info(int arg);

Description
-----------

Given drive_number (A: = 0, B: = 1, etc.) or a file handle in ARG, this
function returns the device info word which is returned by DOS IOCTL
function 0 (Int 21h/AX=4400h).  In case of error, -1 is returned and
ERRNO is set.


File: libc,  Node: _get_dos_version,  Next: getc,  Prev: _get_dev_info,  Up: Alphabetical List

_get_dos_version
================

Syntax
------

     #include <dos.h>
     
     extern unsigned short   _osmajor, _osminor;
     extern const    char  * _os_flavor;
     
     unsigned short _get_dos_version(int true_version);

Description
-----------

This function gets the host OS version and flavor.  If the argument
TRUE_VERSION is non-zero, it will return a `true' version number, which
is unaffected by possible tinkering with SETVER TSR program.  (This is
only available in DOS 5.0 or later.)

The external variables `_osmajor' and `_osminor' will always be set to
the major and minor parts of the `advertised' version number, possibly
changed by SETVER, even if TRUE_VERSION is non-zero.  You typically
need the true version when you need an intimate knowledge of the host
OS internals, like when using undocumented features.  Note that some
DOS clones (notably, DR-DOS) do not support DOS function required to
report the true DOS version; for these, the version reported might be
affected by SETVER even if TRUE_VERSION is non-zero.

The external variable `_os_flavor' will point to a string which
describes the OEM name of the host OS variety.

Return Value
------------

`_get_dos_version()' returns the version number (true version number,
if TRUE_VERSION is non-zero) as a 16-bit number: the major part of the
version in the upper 8 bits, the minor part in the lower 8 bits.  For
instance, DOS version 6.20 will be returned as 0x0614.

Example
-------

       unsigned short true_dos_version = _get_dos_version(1);
     
       if (true_dos_version < 0x0614)   /* require DOS 6.20 or later */
         puts("This program needs DOS 6.20 or later to run");
       else
         printf("You are running %s variety of DOS\n", _os_flavor);


File: libc,  Node: getc,  Next: getcbrk,  Prev: _get_dos_version,  Up: Alphabetical List

getc
====

Syntax
------

     #include <stdio.h>
     
     int getc(FILE *file);

Description
-----------

Get one character from FILE.

Return Value
------------

The character ([0..255]) or `EOF' if eof or error.

Example
-------

     int c;
     while ((c=getc(stdin)) != EOF)
       putc(c, stdout);


File: libc,  Node: getcbrk,  Next: getch,  Prev: getc,  Up: Alphabetical List

getcbrk
=======

Syntax
------

     #include <dos.h>
     
     int getcbrk(void);

Description
-----------

Get the setting of the Ctrl-C checking flag in MS-DOS.

*Note setcbrk::.

Return Value
------------

0 if not checking, 1 if checking.


File: libc,  Node: getch,  Next: getchar,  Prev: getcbrk,  Up: Alphabetical List

getch
=====

Syntax
------

     #include <conio.h>
     
     int     getch(void);

Description
-----------

A single character from the console (stdin) is returned.  The input is
not line-buffered.  If there is a character pending from *Note
ungetch::, it is returned instead.  The character is not echoed to the
screen.

Return Value
------------

The character.


File: libc,  Node: getchar,  Next: getche,  Prev: getch,  Up: Alphabetical List

getchar
=======

Syntax
------

     #include <stdio.h>
     
     int getchar(void);

Description
-----------

The same as `fgetc(stdin)' (*note fgetc::.).

Return Value
------------

The character, or `EOF'.


File: libc,  Node: getche,  Next: getcwd,  Prev: getchar,  Up: Alphabetical List

getche
======

Syntax
------

     #include <conio.h>
     
     int getche(void);

Description
-----------

A single character from the console (stdin) is returned.  The input is
not line-buffered.  If there is a character pending from *Note
ungetch::, it is returned instead.  The character is echoed to the
screen.

Return Value
------------

The character.


File: libc,  Node: getcwd,  Next: getdate,  Prev: getche,  Up: Alphabetical List

getcwd
======

Syntax
------

     #include <unistd.h>
     
     char *getcwd(char *buffer, int max);

Description
-----------

Get the current directory.  The return value includes the drive
specifier.  If BUFFER is `NULL', `getcwd' allocates memory with
`malloc'.  This call fails if more than MAX characters are required to
specify the current directory.

Return Value
------------

The buffer, either BUFFER or a newly-allocated buffer, or `NULL' on
error.

Example
-------

     char *buf = (char *)malloc(PATH_MAX);
     if (buf && getcwd(buf, PATH_MAX))
     {
       printf("cwd is %s\n", buf);
       free(buf);
     }


File: libc,  Node: getdate,  Next: getdfree,  Prev: getcwd,  Up: Alphabetical List

getdate
=======

Syntax
------

     #include <dos.h>
     
     void getdate(struct date *);

Description
-----------

This function gets the current date.  The return structure is as
follows:

     struct date {
       short da_year;
       char  da_day;
       char  da_mon;
     };

*Note setdate::. *Note gettime::.

Return Value
------------

None.

Example
-------

     struct date d;
     getdate(&d);


File: libc,  Node: getdfree,  Next: getdisk,  Prev: getdate,  Up: Alphabetical List

getdfree
========

Syntax
------

     #include <dos.h>
     
     void getdfree(unsigned char drive, struct dfree *ptr);

Description
-----------

This function gets information about the size and fullness of the given
drive (0=default, 1=A:, etc).  The return structure is as follows:

     struct dfree {
       unsigned df_avail; /* number of available clusters */
       unsigned df_total; /* total number of clusters */
       unsigned df_bsec;  /* bytes per sector */
       unsigned df_sclus; /* sectors per cluster */
     };

Return Value
------------

None.

Example
-------

     struct dfree d;
     getdfree(3, &d); /* drive C: */


File: libc,  Node: getdisk,  Next: getdtablesize,  Prev: getdfree,  Up: Alphabetical List

getdisk
=======

Syntax
------

     #include <dir.h>
     
     int getdisk(void);

Description
-----------

Gets the current disk (0=A).

*Note setdisk::.

Return Value
------------

The current disk number.

Example
-------

     printf("This drive is %c:\n", getdisk() + 'A');


File: libc,  Node: getdtablesize,  Next: getegid,  Prev: getdisk,  Up: Alphabetical List

getdtablesize
=============

Syntax
------

     #include <unistd.h>
     
     int getdtablesize(void);

Description
-----------

Get the maximum number of open file descriptors the system supports.

Return Value
------------

255


File: libc,  Node: getegid,  Next: getenv,  Prev: getdtablesize,  Up: Alphabetical List

getegid
=======

Syntax
------

     #include <unistd.h>
     
     int getegid(void);

Description
-----------

Get the effective group id.

Return Value
------------

42


File: libc,  Node: getenv,  Next: geteuid,  Prev: getegid,  Up: Alphabetical List

getenv
======

Syntax
------

     #include <stdlib.h>
     
     char *getenv(const char *name);

Description
-----------

Get the setting of the environment variable NAME.  Do not alter or free
the returned value.

Return Value
------------

The value, or `NULL' if that variable does not exist.

Example
-------

     char *term = getenv("TERM");


File: libc,  Node: geteuid,  Next: getftime,  Prev: getenv,  Up: Alphabetical List

geteuid
=======

Syntax
------

     #include <unistd.h>
     
     int geteuid(void);

Description
-----------

Gets the effective UID.

Return Value
------------

42


File: libc,  Node: getftime,  Next: getgid,  Prev: geteuid,  Up: Alphabetical List

getftime
========

Syntax
------

     #include <dos.h>
     
     int getftime(int handle, struct ftime *ptr);

Description
-----------

Get the timestamp for the given file handle.  The return structure is as
follows:

     struct ftime {
       unsigned ft_tsec:5;	/* 0-29, double to get real seconds */
       unsigned ft_min:6;	/* 0-59 */
       unsigned ft_hour:5;	/* 0-23 */
       unsigned ft_day:5;	/* 1-31 */
       unsigned ft_month:4;	/* 1-12 */
       unsigned ft_year:7;	/* since 1980 */
     }

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     struct ftime t;
     getftime(fd, &t);


File: libc,  Node: getgid,  Next: getgrent,  Prev: getftime,  Up: Alphabetical List

getgid
======

Syntax
------

     #include <unistd.h>
     
     int getgid(void);

Description
-----------

Get the current group id.

Return Value
------------

42


File: libc,  Node: getgrent,  Next: getgrgid,  Prev: getgid,  Up: Alphabetical List

getgrent
========

Syntax
------

     #include <grp.h>
     
     struct group *getgrent(void);

Description
-----------

This function returns the next available group entry.  Note that for
MS-DOS, this is simulated.  If the environment variable GROUP is set,
that is the name of the only group returned, else the only group is
"dos".  Thus, under DOS, `getgrent' will always fail on the second and
subsequent calls.

The return type of this and related function is as follows:

     struct group {
       gid_t    gr_gid;    /* result of getgid() */
       char  ** gr_mem;    /* gr_mem[0] points to
                               getenv("USER"/"LOGNAME") or "user" */
       char  *  gr_name;   /* getenv("GROUP") or "dos" */
     };

Return Value
------------

The next structure, or `NULL' at the end of the list.

Example
-------


     struct group *g;
     setgrent();
     while ((g = getgrent()) != NULL)
     {
       printf("group %s gid %d\n", g->gr_name, g->gr_gid);
     }
     endgrent();


File: libc,  Node: getgrgid,  Next: getgrnam,  Prev: getgrent,  Up: Alphabetical List

getgrgid
========

Syntax
------

     #include <grp.h>
     
     extern struct group *getgrgid(int gid);

Description
-----------

This function returns the group entry that matches GID.  *Note
getgrent::, for the description of `struct group'.

Return Value
------------

The matching group, or `NULL' if none match.


File: libc,  Node: getgrnam,  Next: gethostname,  Prev: getgrgid,  Up: Alphabetical List

getgrnam
========

Syntax
------

     #include <grp.h>
     
     struct group *getgrnam(char *name);

Description
-----------

This function returns the group entry for the group named NAME.  *Note
getgrent:: for the description of `struct group'.

Return Value
------------

The matching group, or `NULL' if none match.


File: libc,  Node: gethostname,  Next: getitimer,  Prev: getgrnam,  Up: Alphabetical List

gethostname
===========

Syntax
------

     #include <unistd.h>
     #include <sys/param.h>
     
     int gethostname (char *buf, int size);

Description
-----------

Get the name of the host the program is executing on.  This name is
obtained from the network software, if present, otherwise from the
`"HOSTNAME"' environment variable, if present, finally defaulting to
`"pc"'.

The call fails if more than SIZE characters are required to specify the
host name.  A buffer size of `MAXGETHOSTNAME' is guaranteed to be
enough.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     char *buf = (char *) malloc (MAXGETHOSTNAME);
     if (buf && 0 == gethostname (buf, MAXGETHOSTNAME))
       printf ("We're on %s\n", buf);
     if (buf) free(buf);


File: libc,  Node: getitimer,  Next: getkey,  Prev: gethostname,  Up: Alphabetical List

getitimer
=========

Syntax
------

     #include <sys/time.h>
     
     int getitimer(int which, struct itimerval *value);

Description
-----------

This function gets the current value of the interval timer specified by
WHICH into structure VALUE.  Variable WHICH can have the value of
ITIMER_REAL or ITIMER_PROF. *Note setitimer::.

Return Value
------------

Returns 0 on success, -1 on failure (and sets errno).


File: libc,  Node: getkey,  Next: getlogin,  Prev: getitimer,  Up: Alphabetical List

getkey
======

Syntax
------

     #include <pc.h>
     #include <keys.h>
     
     int getkey(void);

Description
-----------

Waits for the user to press one key, then returns that key.  Alt-key
combinations have 0x100 added to them.  Extended keys return their
non-extended codes.

The file `keys.h' has symbolic names for many of the keys.

*Note getxkey::.

Return Value
------------

The key pressed.

Example
-------

     while (getkey() != K_Alt_3)
       do_something();


File: libc,  Node: getlogin,  Next: getlongpass,  Prev: getkey,  Up: Alphabetical List

getlogin
========

Syntax
------

     #include <unistd.h>
     
     char *getlogin(void);

Description
-----------

Get the login ID of the user.

Return Value
------------

Returns the value of the `USER' environment variable, else the
`LOGNAME' environment variable, else `"dosuser"'.

Example
-------

     printf("I am %s\n", getlogin());


File: libc,  Node: getlongpass,  Next: getmntent,  Prev: getlogin,  Up: Alphabetical List

getlongpass
===========

Syntax
------

     #include <stdlib.h>
     
     int  getlongpass(const char *prompt, char *password, int max_length)

Description
-----------

This function reads up to a Newline (CR or LF) or EOF (Ctrl-D or Ctrl-Z)
from the standard input, without an echo, after prompting with a
null-terminated string PROMPT.  It puts a null-terminated string of at
most MAX_LENGTH - 1 first characters typed by the user into a buffer
pointed to by PASSWORD.  Pressing Ctrl-C or Ctrl-Break will cause the
calling program to `exit(1)'.

Return Value
------------

Zero if successfull, -1 on error (and ERRNO is set to and appropriate
value.

Example
-------

     char password[MAX_PASS];
     
     (void)getlongpass("Password: ", password, MAX_PASS);


File: libc,  Node: getmntent,  Next: getpagesize,  Prev: getlongpass,  Up: Alphabetical List

getmntent
=========

Syntax
------

     #include <mntent.h>
     
     struct mntent *getmntent(FILE *filep);

Description
-----------

This function returns information about the various drives that are
available to your program.  Beginning with drive `A:', information is
retrieved for successive drives with successive calls to `getmntent'.
Note that drives `A:' and `B:' will only be returned if there is an
MS-DOS formatted disk in the drive; empty drives are skipped.  For
systems with a single floppy drive, it is returned as if it were
mounted on A:/ or B:/, depending on how it was last referenced (and if
there is a disk in the drive).

For each drive scanned, a pointer to a static structure of the following
type is returned:

     struct mntent
     {
         char * mnt_fsname;  /* The name of this file system */
         char * mnt_dir;     /* The root directory of this file system */
         char * mnt_type;	/* Filesystem type */
         char * mnt_opts;    /* Options, see below */
         int    mnt_freq;    /* -1 */
         int    mnt_passno;  /* -1 */
         long   mnt_time;    /* -1 */
     };

DJGPP implementation returns the following in the first 4 fields of
`struct mntent':

`mnt_fsname'
     For networked and CD-ROM drives, the name of root directory in the
     form "\\HOST\PATH" (this is called a UNC name).

     For drives compressed with DoubleSpace, the string
     "X:\DBLSPACE.NNN", where "X" is the drive letter of the host drive
     and "NNN" is the sequence number of the Compressed Volume File.

     For drives compressed with Stacker, the string "X:\STACVOL.NNN",
     where "X" and "NNN" are as for DoubleSpace drives.

     For SUBSTed drives, the actual directory name that that was
     SUBSTed to emulate a drive.

     JOINed drives get their name as if they were NOT JOINed (i.e.,
     either the label name or the default "Drive X:").

     For drives with a volume label, the name of the label; otherwise
     the string "Drive X:", where "X" is the drive letter.

`mnt_dir'
     For most drives, the name of its root directory "X:/" (where "X" is
     the drive letter), except that JOINed drives get this as the name
     of the directory to which they were JOINed.

     For systems with a single floppy drive (which can be referenced as
     either "a:/" or "b:/"), the mount directory will be returned as
     one of these, depending on which drive letter was last used to
     reference that drive.

`mnt_type'
           "fd"     for floppy disks
           "hd"     for hard disks
           "dblsp"  for disks compressed with DoubleSpace
           "stac"   for disks compressed with Stacker
           "cdrom"  for CD-ROM drives
           "ram"    for RAM disks
           "subst"  for SUBSTed directories
           "join"   for JOINed disks
           "net"    for networked drives

`mnt_opts'
     The string "ro,dev=XX" for CD-ROM drives, "rw,dev=XX" for all the
     others, where "XX" is the hexadecimal drive number of the REAL
     drive on which this filesystem resides.  That is, if you call
     `stat' on MNT_FSNAME, you will get the numeric equivalent of XX in
     `st_dev' field of `struct stat'.  E.g., for drive C: you will get
     "rw,dev=02".  Note that SUBSTed and JOINed drives get the drive
     numbers as if SUBST and JOIN were NOT in effect.

Return Value
------------

This function returns a pointer to an `struct' `mntent', or NULL if
there are no more drives to report on.

Example
-------

     struct mntent *m;
     FILE *f;
     f = setmntent("", "");
     while ((m = getmntent(f)))
       printf("Drive %s, name %s\n", m->mnt_dir, m->mnt_fsname);
     endmntent(f);


File: libc,  Node: getpagesize,  Next: getpass,  Prev: getmntent,  Up: Alphabetical List

getpagesize
===========

Syntax
------

     #include <unistd.h>
     
     int getpagesize(void);

Description
-----------

Return the size of the native virtual memory page size.

Return Value
------------

4096 for the i386 and higher processors.


File: libc,  Node: getpass,  Next: getpgrp,  Prev: getpagesize,  Up: Alphabetical List

getpass
=======

Syntax
------

     #include <stdlib.h>
     
     char * getpass(const char *prompt)

Description
-----------

This function reads up to a Newline (CR or LF) or EOF (Ctrl-D or Ctrl-Z)
from the standard input, without an echo, after prompting with a
null-terminated string PROMPT.  It returns the string of at most 8
characters typed by the user.  Pressing Ctrl-C or Ctrl-Break will cause
the calling program to `exit(1)'.

Return Value
------------

A pointer to a static buffer which holds the user's response.  The
buffer will be overwritten by each new call.  In case of any error in
the lower I/O routines, a NULL pointer will be returned.

Example
-------

     char *password = getpass("Password: ");


File: libc,  Node: getpgrp,  Next: getpid,  Prev: getpass,  Up: Alphabetical List

getpgrp
=======

Syntax
------

     #include <unistd.h>
     
     int getpgrp(void);

Description
-----------

Gets the process group, which is currently the same as the pid.

Return Value
------------

The process group.


File: libc,  Node: getpid,  Next: getpwent,  Prev: getpgrp,  Up: Alphabetical List

getpid
======

Syntax
------

     #include <unistd.h>
     
     int getpid(void);

Description
-----------

Get the process ID, which uniquely identifies each program running on
the system.

Return Value
------------

The process ID.


File: libc,  Node: getpwent,  Next: getpwnam,  Prev: getpid,  Up: Alphabetical List

getpwent
========

Syntax
------

     #include <pwd.h>
     
     struct passwd *getpwent(void);

Description
-----------

This function retrieves the next available password file entry.  For
MS-DOS, this is simulated by providing exactly one entry:

     struct passwd {
       char * pw_name;    /* getlogin() */
       int    pw_uid;     /* getuid() */
       int    pw_gid;     /* getgid() */
       char * pw_dir;     /* "/" or getenv("HOME") */
       char * pw_shell;   /* "/bin/sh" or getenv("SHELL") */
     };

Return Value
------------

The next passwd entry, or `NULL' if there are no more.

Example
-------

     struct passwd *p;
     setpwent();
     while ((p = getpwent()) != NULL)
     {
       printf("user %s name %s\n", p->pw_name, p->pw_gecos);
     }
     endpwent();


File: libc,  Node: getpwnam,  Next: getpwuid,  Prev: getpwent,  Up: Alphabetical List

getpwnam
========

Syntax
------

     #include <pwd.h>
     
     struct passwd *getpwnam(const char *name);

Description
-----------

This function gets the password file entry matching NAME.  *Note
getpwent::.

Return Value
------------

The matching record, or `NULL' if none match.


File: libc,  Node: getpwuid,  Next: getrusage,  Prev: getpwnam,  Up: Alphabetical List

getpwuid
========

Syntax
------

     #include <pwd.h>
     
     struct passwd *getpwuid(uid_t uid);

Description
-----------

This function gets the password file entry matching UID.  *Note
getpwent::.

Return Value
------------

The matching record, or `NULL' if none match.


File: libc,  Node: getrusage,  Next: gets,  Prev: getpwuid,  Up: Alphabetical List

getrusage
=========

Syntax
------

     #include <sys/time.h>
     #include <sys/resource.h
     
     int getrusage(int who, struct rusage *rusage);

Description
-----------

This function returns information about the running process.  Currently,
the only field that is computed is this:

     struct rusage {
       struct timeval ru_utime;  /* total time used by process */
     };

The remainder of the fields are set to zero.

The WHO parameter must be `RUSAGE_SELF' or `RUSAGE_CHILDREN'.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     struct rusage r;
     getrusage(RUSAGE_SELF, &r);


File: libc,  Node: gets,  Next: gettext,  Prev: getrusage,  Up: Alphabetical List

gets
====

Syntax
------

     #include <stdio.h>
     
     char *gets(char *buffer);

Description
-----------

Reads characters from `stdin', storing them in BUFFER, until either end
of file or a newline is encountered.  If any characters were stored,
the BUFFER is then `NULL' terminated and its address is returned, else
`NULL' is returned.

Return Value
------------

The address of the buffer, or `NULL'.

Example
-------

     char buf[1000];
     while (gets(buf))
       puts(buf);


File: libc,  Node: gettext,  Next: gettextinfo,  Prev: gets,  Up: Alphabetical List

gettext
=======

Syntax
------

     #include <conio.h>
     
     int     gettext(int _left, int _top, int _right, int _bottom, void *_destin);

Description
-----------

Retrieve a block of screen characters into a buffer.

Return Value
------------

1


File: libc,  Node: gettextinfo,  Next: gettime,  Prev: gettext,  Up: Alphabetical List

gettextinfo
===========

Syntax
------

     #include <conio.h>
     
     void    gettextinfo(struct text_info *_r);

Description
-----------

This function returns the parameters of the current window on the
screen.  The return structure is this:

     struct text_info {
         unsigned char winleft;
         unsigned char wintop;
         unsigned char winright;
         unsigned char winbottom;
         unsigned char attribute;
         unsigned char normattr;
         unsigned char currmode;
         unsigned char screenheight;
         unsigned char screenwidth;
         unsigned char curx;
         unsigned char cury;
     };

The `normattr' field is the text attribute which was in effect before
the program started.


File: libc,  Node: gettime,  Next: gettimeofday,  Prev: gettextinfo,  Up: Alphabetical List

gettime
=======

Syntax
------

     #include <dos.h>
     
     void gettime(struct time *);

Description
-----------

This function gets the current time.  The return structure is as
follows:

     struct time {
       unsigned char ti_min;
       unsigned char ti_hour;
       unsigned char ti_hund;
       unsigned char ti_sec;
     };

*Note settime::. *Note getdate::.

Return Value
------------

None.

Example
-------

     struct time t;
     gettime(&t);


File: libc,  Node: gettimeofday,  Next: getuid,  Prev: gettime,  Up: Alphabetical List

gettimeofday
============

Syntax
------

     #include <sys/time.h>
     
     int gettimeofday(struct timeval *tp, struct timezone *tzp);

Description
-----------

Gets the current GMT time and the local timezone information.  The
return structures are as follows:

     struct timeval {
       long tv_sec;  /* seconds since 00:00:00 GMT 1/1/1970 */
       long tv_usec; /* microseconds */
     };
     struct timezone {
       int tz_minuteswest; /* west of GMT */
       int tz_dsttime;     /* set if daylight saving time in affect */
     };

If either TP or TZP are `NULL', that information is not provided.

*Note settimeofday::.

Return Value
------------

Zero on success, nonzero on failure.


File: libc,  Node: getuid,  Next: getw,  Prev: gettimeofday,  Up: Alphabetical List

getuid
======

Syntax
------

     #include <unistd.h>
     
     int getuid(void);

Description
-----------

Returns the user ID.

Return Value
------------

42


File: libc,  Node: getw,  Next: getwd,  Prev: getuid,  Up: Alphabetical List

getw
====

Syntax
------

     #include <stdio.h>
     
     int getw(FILE *file);

Description
-----------

Reads a single binary word in native format from FILE.

*Note putw::.

Return Value
------------

The value read, or `EOF' for end-of-file or error.  Since `EOF' is a
valid integer, you should use `feof' or `ferror' to detect this
situation.

Example
-------

     int i = getw(stdin);


File: libc,  Node: getwd,  Next: getxkey,  Prev: getw,  Up: Alphabetical List

getwd
=====

Syntax
------

     #include <unistd.h>
     
     char *getwd(char *buffer);

Description
-----------

Get the current directory and put it in BUFFER.  The return value
includes the drive specifier.

Return Value
------------

BUFFER is returned.

Example
-------

     char buf[PATH_MAX];
     getwd(buf);


File: libc,  Node: getxkey,  Next: glob,  Prev: getwd,  Up: Alphabetical List

getxkey
=======

Syntax
------

     #include <pc.h>
     #include <keys.h>
     
     int getxkey(void);

Description
-----------

Waits for the user to press one key, then returns that key.  Alt-key
combinations have 0x100 added to them, and extended keys have 0x200
added to them.

The file `keys.h' has symbolic names for many of the keys.

*Note getkey::.

Return Value
------------

The key pressed.

Example
-------

     while (getxkey() != K_EEnd)
       do_something();


File: libc,  Node: glob,  Next: globfree,  Prev: getxkey,  Up: Alphabetical List

glob
====

Syntax
------

     #include <glob.h>
     
     int  glob(const char *_pattern, int _flags,
               int (*_errfunc)(const char *_epath, int _eerrno), glob_t *_pglob);

Description
-----------

This function performs command-line wildcard expansion.  The pattern to
be expanded is passed as PATTERN, and a pointer to a structure is
passed via _PGLOB.  This structure is like this:

     typedef struct {
       size_t gl_pathc;
       char **gl_pathv;
       size_t gl_offs;
     } glob_t;

The `gl_pathc' and `gl_pathv' fields define a list of matches.  The
`gl_offs' field indicates that the list should be offset.

The structure is filled in with information about the files that
matched the wildcard.  Values for _FLAGS are as follows:

`GLOB_APPEND'
     Append matches to a pre-existing structure.

`GLOB_DOOFFS'
     Skip _pglob->gl_offs entries in gl_pathv.

`GLOB_ERR'
     Stop when an unreadable directory is encountered.

`GLOB_MARK'
     Append a slash to each pathname that is a directory.

`GLOB_NOCHECK'
     If no matches are found, return the pattern itself as the only
     match.

`GLOB_NOESCAPE'
     Disable blackslash as an escape character.

`GLOB_NOSORT'
     Do not sort the returned list.

Return Value
------------

Zero on success.


File: libc,  Node: globfree,  Next: gmtime,  Prev: glob,  Up: Alphabetical List

globfree
========

Syntax
------

     #include <glob.h>
     
     void globfree(glob_t *_pglob);

Description
-----------

Frees the memory associated with `_pglob'.


File: libc,  Node: gmtime,  Next: _go32_conventional_mem_selector,  Prev: globfree,  Up: Alphabetical List

gmtime
======

Syntax
------

     #include <time.h>
     
     struct tm *gmtime(const time_t *tod);

Description
-----------

Converts the time represented by TOD into a structure.

The return structure has this format:

     struct tm {
       int    tm_sec;    /* seconds after the minute [0-60] */
       int    tm_min;    /* minutes after the hour [0-59] */
       int    tm_hour;   /* hours since midnight [0-23] */
       int    tm_mday;   /* day of the month [1-31] */
       int    tm_mon;    /* months since January [0-11] */
       int    tm_year;   /* years since 1900 */
       int    tm_wday;   /* days since Sunday [0-6] */
       int    tm_yday;   /* days since January 1 [0-365] */
       int    tm_isdst;  /* Daylight Savings Time flag */
       long   tm_gmtoff; /* offset from GMT in seconds */
       char * tm_zone;   /* timezone abbreviation */
     };

Return Value
------------

A pointer to a static structure which is overridden with each call.

Example
-------

     time_t x;
     struct tm *t;
     time(&x);
     t = gmtime(&t);


File: libc,  Node: _go32_conventional_mem_selector,  Next: _go32_dpmi_allocate_dos_memory,  Prev: gmtime,  Up: Alphabetical List

_go32_conventional_mem_selector
===============================

Syntax
------

     #include <go32.h>
     
     u_short _go32_conventional_mem_selector();

Description
-----------

This function returns a selector which has a physical base address
corresponding to the beginning of conventional memory.  This selector
can be used as a parameter to `movedata' (*note movedata::.) to
manipulate memory in the conventional address space.

Return Value
------------

The selector.

Example
-------

     short blank_row_buf[ScreenCols()];
     /* scroll screen */
     movedata(_go32_conventional_mem_selector(), 0xb8000 + ScreenCols()*2,
              _go32_conventional_mem_selector(), 0xb8000,
              ScreenCols() * (ScreenRows()-1) * 2);
     /* fill last row */
     movedata(_go32_my_ds, (int)blank_row_buf,
              _go32_conventional_mem_selector(),
                 0xb8000 + ScreenCols()*(ScreenRows()-1)*2,
               ScreenCols() * 2);


File: libc,  Node: _go32_dpmi_allocate_dos_memory,  Next: _go32_dpmi_allocate_iret_wrapper,  Prev: _go32_conventional_mem_selector,  Up: Alphabetical List

_go32_dpmi_allocate_dos_memory
==============================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_allocate_dos_memory(_go32_dpmi_seginfo *info);

Description
-----------

*Note DPMI Overview::

Allocate a part of the conventional memory area (the first 640K).  Set
the `size' field of INFO to the number of paragraphs requested (this is
(size in bytes + 15)/16), then call.  The `rm_segment' field of INFO
contains the segment of the allocated memory.

The memory may be resized with `_go32_dpmi_resize_dos_memory' and must
be freed with `_go32_dpmi_free_dos_memory'.

If there isn't enough memory in the system, the `size' field of INFO
has the largest available size, and an error is returned.

*Note dosmemput:: *Note dosmemget::

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     _go32_dpmi_seginfo info;
     info.size = (want_size+15) / 16;
     _go32_dpmi_allocate_dos_memory(&info);
     dosmemput(buffer, want_size, info.rm_segment*16);
     _go32_dpmi_free_dos_memory(&info);


File: libc,  Node: _go32_dpmi_allocate_iret_wrapper,  Next: _go32_dpmi_allocate_real_mode_callback_iret,  Prev: _go32_dpmi_allocate_dos_memory,  Up: Alphabetical List

_go32_dpmi_allocate_iret_wrapper
================================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_allocate_iret_wrapper(_go32_dpmi_seginfo *info);

Description
-----------

*Note DPMI Overview::

This function creates a small assembler function that handles the
overhead of servicing an interrupt.  To use, put the address of your
servicing function in the `pm_offset' field of INFO and call this
function.  The `pm_field' will get replaced with the address of the
wrapper function, which you pass to both
`_go32_dpmi_set_protected_mode_interrupt_vector' and
`_go32_dpmi_free_iret_wrapper'.

*Note _go32_dpmi_set_protected_mode_interrupt_vector:: *Note
_go32_dpmi_free_iret_wrapper::

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     _go32_dpmi_seginfo info;
     info.pm_offset = my_handler;
     _go32_dpmi_allocate_iret_wrapper(&info);
     _go32_dpmi_set_protected_mode_interrupt_handler(0x75, &info);
     ...
     _go32_dpmi_free_iret_wrapper(&info);


File: libc,  Node: _go32_dpmi_allocate_real_mode_callback_iret,  Next: _go32_dpmi_allocate_real_mode_callback_retf,  Prev: _go32_dpmi_allocate_iret_wrapper,  Up: Alphabetical List

_go32_dpmi_allocate_real_mode_callback_iret
===========================================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_allocate_real_mode_callback_iret(_go32_dpmi_seginfo *info, _go32_dpmi_registers *regs);

Description
-----------

*Note DPMI Overview::

This function allocates a "real-mode callback".  Fill in the
`pm_offset' field of INFO and call this function.  It will fill in the
`rm_segment' and `rm_offset' fields.  Any time a real-mode program
calls the real-mode address, your function gets called.  The registers
in affect will be stored in REGS, which should be a global, and will be
passed to your function.  Any changes in REGS will be reflected back
into real mode.  A wrapper will be added to your function to simulate
the effects of an `iret' instruction, so this function is useful for
trapping real-mode software interrupts (like 0x1b - `Ctrl-Break' hit).

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     _go32_dpmi_registers regs;
     
     my_handler(_go32_dpmi_registers *r)
     {
       r.d.eax = 4;
     }
     
     setup()
     {
       _go32_dpmi_seginfo info;
       _go32_dpmi_seginfo old_vector;
       _go32_dpmi_get_real_mode_interrupt_vector(0x84, &old_vector);
       info.pm_offset = my_handler;
       _go32_dpmi_allocate_real_mode_callback_iret(&info, &regs);
       _go32_dpmi_set_real_mode_interrupt_vector(0x84, &info);
       do_stuff();
       _go32_dpmi_set_real_mode_interrupt_vector(0x84, &old_vector);
       _go32_dpmi_free_real_mode_callback(&info);
     }


File: libc,  Node: _go32_dpmi_allocate_real_mode_callback_retf,  Next: _go32_dpmi_chain_protected_mode_interrupt_vector,  Prev: _go32_dpmi_allocate_real_mode_callback_iret,  Up: Alphabetical List

_go32_dpmi_allocate_real_mode_callback_retf
===========================================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_allocate_real_mode_callback_retf(_go32_dpmi_seginfo *info, _go32_dpmi_registers *regs);

Description
-----------

*Note DPMI Overview::

This function allocates a "real-mode callback".  Fill in the
`pm_offset' field of INFO and call this function.  It will fill in the
`rm_segment' and `rm_offset' fields.  Any time a real-mode program
calls the real-mode address, your function gets called.  The registers
in affect will be stored in REGS, which should be a global, and will be
passed to your function.  Any changes in REGS will be reflected back
into real mode.  A wrapper will be added to your function to simulate
the effects of a far return, such as the callback for the packet driver
receiver.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

*Note _go32_dpmi_allocate_real_mode_callback_iret::


File: libc,  Node: _go32_dpmi_chain_protected_mode_interrupt_vector,  Next: _go32_dpmi_free_dos_memory,  Prev: _go32_dpmi_allocate_real_mode_callback_retf,  Up: Alphabetical List

_go32_dpmi_chain_protected_mode_interrupt_vector
================================================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_chain_protected_mode_interrupt_vector(int vector, _go32_dpmi_seginfo *info);

Description
-----------

*Note DPMI Overview::

This function is used to chain a protected mode interrupt.  It will
build a suitable wrapper that will call your function and then jump to
the next handler.  Your function need not perform any special handling.

*Warning!* Because of the way DPMI works, you may *not* `longjmp' out
of an interrupt handler or perform any system calls (such as `printf')
from within an interrupt handler.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

*Note _go32_dpmi_set_protected_mode_interrupt_vector::


File: libc,  Node: _go32_dpmi_free_dos_memory,  Next: _go32_dpmi_free_iret_wrapper,  Prev: _go32_dpmi_chain_protected_mode_interrupt_vector,  Up: Alphabetical List

_go32_dpmi_free_dos_memory
==========================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_free_dos_memory(_go32_dpmi_seginfo *info);

Description
-----------

*Note DPMI Overview::

This function frees the conventional memory allocated by
`_go32_dpmi_allocate_real_mode_memory'.  You should pass it the same
structure as was used to allocate it.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     _go32_dpmi_seginfo info;
     info.size = 100;
     _go32_dpmi_allocate_dos_memory(&info);
     _go32_dpmi_free_dos_memory(&info);


File: libc,  Node: _go32_dpmi_free_iret_wrapper,  Next: _go32_dpmi_free_real_mode_callback,  Prev: _go32_dpmi_free_dos_memory,  Up: Alphabetical List

_go32_dpmi_free_iret_wrapper
============================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_free_iret_wrapper(_go32_dpmi_seginfo *info);

Description
-----------

*Note DPMI Overview::

This function frees the memory used by the wrapper created by
`_go32_dpmi_allocate_iret_wrapper'.  You should not free a wrapper that
is still in use.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

*Note _go32_dpmi_allocate_iret_wrapper::


File: libc,  Node: _go32_dpmi_free_real_mode_callback,  Next: _go32_dpmi_get_free_memory_information,  Prev: _go32_dpmi_free_iret_wrapper,  Up: Alphabetical List

_go32_dpmi_free_real_mode_callback
==================================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_free_real_mode_callback(_go32_dpmi_seginfo *info);

Description
-----------

*Note DPMI Overview::

This function frees the real-mode callbacks and wrappers allocated by
`_go32_dpmi_allocate_real_mode_callback_iret' and
`_go32_dpmi_allocate_real_mode_callback_retf'.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

*Note _go32_dpmi_allocate_real_mode_callback_iret::


File: libc,  Node: _go32_dpmi_get_free_memory_information,  Next: _go32_dpmi_get_protected_mode_interrupt_vector,  Prev: _go32_dpmi_free_real_mode_callback,  Up: Alphabetical List

_go32_dpmi_get_free_memory_information
======================================

Syntax
------

     #include <dpmi.h
     
     int _go32_dpmi_get_free_memory_information(_go32_dpmi_meminfo *info);

Description
-----------

This function fills in the following structure:

     typedef struct {
       u_long available_memory;
       u_long available_pages;
       u_long available_lockable_pages;
       u_long linear_space;
       u_long unlocked_pages;
       u_long available_physical_pages;
       u_long total_physical_pages;
       u_long free_linear_space;
       u_long max_pages_in_paging_file;
       u_long reserved[3];
     } _go32_dpmi_meminfo;

The only field that is guaranteed to have useful data is
`available_memory'.  Any unavailable field has -1 in it.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     int phys_mem_left()
     {
       _go32_dpmi_meminfo info;
       _go32_dpmi_get_free_memory_information(&info);
       if (info.available_physical_pages != -1)
         return info.available_physical_pages * 4096;
       return info.available_memory;
     }


File: libc,  Node: _go32_dpmi_get_protected_mode_interrupt_vector,  Next: _go32_dpmi_get_real_mode_interrupt_vector,  Prev: _go32_dpmi_get_free_memory_information,  Up: Alphabetical List

_go32_dpmi_get_protected_mode_interrupt_vector
==============================================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_get_protected_mode_interrupt_vector(int vector, _go32_dpmi_seginfo *info);

Description
-----------

*Note DPMI Overview::

This function puts the selector and offset of the specified interrupt
vector into the `pm_selector' and `pm_offset' fields of INFO.  This
structure can be saved and later passed to
`_go32_dpmi_get_protected_mode_interrupt_vector' to restore a vector.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

*Note _go32_dpmi_set_protected_mode_interrupt_vector::


File: libc,  Node: _go32_dpmi_get_real_mode_interrupt_vector,  Next: _go32_dpmi_lock_code,  Prev: _go32_dpmi_get_protected_mode_interrupt_vector,  Up: Alphabetical List

_go32_dpmi_get_real_mode_interrupt_vector
=========================================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_get_real_mode_interrupt_vector(int vector, _go32_dpmi_seginfo *info);

Description
-----------

*Note DPMI Overview::

This function gets the real-mode interrupt vector specified into the
address in the `rm_segment' and `rm_offset' fields in INFO.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

*Note _go32_dpmi_allocate_real_mode_callback_iret::


File: libc,  Node: _go32_dpmi_lock_code,  Next: _go32_dpmi_lock_data,  Prev: _go32_dpmi_get_real_mode_interrupt_vector,  Up: Alphabetical List

_go32_dpmi_lock_code
====================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_lock_code( void *lockaddr, unsigned long locksize);

Description
-----------

Locks the given region of code, starting at LOCKADDR for LOCKSIZE
bytes.  LOCKADDR is a regular pointer in your program, such as the
address of a function.

Example
-------


     void my_handler()
     {
     }
     
     void lock_my_handler()
     {
       _go32_dpmi_lock_code(my_handler, (unsigned long)(lock_my_handler - my_handler));
     }


File: libc,  Node: _go32_dpmi_lock_data,  Next: _go32_dpmi_remaining_physical_memory,  Prev: _go32_dpmi_lock_code,  Up: Alphabetical List

_go32_dpmi_lock_data
====================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_lock_data( void *lockaddr, unsigned long locksize);

Description
-----------

Locks the given region of code, starting at LOCKADDR for LOCKSIZE
bytes.  LOCKADDR is a regular pointer in your program, such as the
address of a variable.

Example
-------


     int semaphore=0;
     
     void lock_my_handler()
     {
       _go32_dpmi_lock_data(&semaphore, 4);
     }


File: libc,  Node: _go32_dpmi_remaining_physical_memory,  Next: _go32_dpmi_remaining_virtual_memory,  Prev: _go32_dpmi_lock_data,  Up: Alphabetical List

_go32_dpmi_remaining_physical_memory
====================================

Syntax
------

     #include <dpmi.h>
     
     unsigned long _go32_dpmi_remaining_physical_memory(void);

Description
-----------

Returns the amount of physical memory that is still available in the
system.

Return Value
------------

The amount in bytes.


File: libc,  Node: _go32_dpmi_remaining_virtual_memory,  Next: _go32_dpmi_resize_dos_memory,  Prev: _go32_dpmi_remaining_physical_memory,  Up: Alphabetical List

_go32_dpmi_remaining_virtual_memory
===================================

Syntax
------

     #include <dpmi.h>
     
     unsigned long _go32_dpmi_remaining_virtual_memory(void);

Description
-----------

Returns the amount of virtual memory that is still available in the
system.

Return Value
------------

The amount in bytes.


File: libc,  Node: _go32_dpmi_resize_dos_memory,  Next: _go32_dpmi_set_protected_mode_interrupt_vector,  Prev: _go32_dpmi_remaining_virtual_memory,  Up: Alphabetical List

_go32_dpmi_resize_dos_memory
============================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_resize_dos_memory(_go32_dpmi_seginfo *info);

Description
-----------

*Note DPMI Overview::

The INFO structure is the same one used to allocate the memory.  Fill
in a new value for `size' and call this function.  If there is not
enough memory to satisfy the request, the largest size is filled in to
the `size' field, the memory is not resized, and this function fails.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     _go32_dpmi_seginfo info;
     info.size = 10;
     _go32_dpmi_allocate_dos_memory(&info);
     info.size = 20;
     _go32_dpmi_resize_dos_memory(&info);
     _go32_dpmi_free_dos_memory(&info);


File: libc,  Node: _go32_dpmi_set_protected_mode_interrupt_vector,  Next: _go32_dpmi_set_real_mode_interrupt_vector,  Prev: _go32_dpmi_resize_dos_memory,  Up: Alphabetical List

_go32_dpmi_set_protected_mode_interrupt_vector
==============================================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_set_protected_mode_interrupt_vector(int vector, _go32_dpmi_seginfo *info);

Description
-----------

*Note DPMI Overview::

This function sets the protected mode interrupt vector specified to
point to the given function.  The `pm_offset' and `pm_selector' fields
of INFO must be filled in (*note _go32_my_cs::.).  The following should
be noted:

   *  You may not `longjmp' out of an interrupt handler.

   *  You may not make any function calls that require system calls,
     such as `printf'.

   *  This function will not wrap the handler for you.  The
     `_go32_dpmi_allocate_iret_wrapper' and
     `_go32_dpmi_chain_protected_mode_interrupt_vector' functions can
     wrap your function if you want.

   *  You must set the pm_selector field of INFO.  Use `_go32_my_cs' to
     get a selector valid for your functions.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     volatile int tics = 0;
     
     timer_handler()
     {
       tics++;
     }
     
     int main()
     {
       _go32_dpmi_seginfo old_handler, new_handler;
     
       printf("grabbing timer interrupt\n");
       _go32_dpmi_get_protected_mode_interrupt_vector(8, &old_handler);
     
       new_handler.pm_offset = (int)tic_handler;
       new_handler.pm_selector = _go32_my_cs();
       _go32_dpmi_chain_protected_mode_interrupt_vector(8, &new_handler);
     
       getkey();
     
       printf("releasing timer interrupt\n");
       _go32_dpmi_set_protected_mode_interrupt_vector(8, &old_handler);
     
       return 0;
     }


File: libc,  Node: _go32_dpmi_set_real_mode_interrupt_vector,  Next: _go32_dpmi_simulate_fcall,  Prev: _go32_dpmi_set_protected_mode_interrupt_vector,  Up: Alphabetical List

_go32_dpmi_set_real_mode_interrupt_vector
=========================================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_set_real_mode_interrupt_vector(int vector, _go32_dpmi_seginfo *info);

Description
-----------

*Note DPMI Overview::

This function sets the real-mode interrupt vector specified to point to
the address in the `rm_segment' and `rm_offset' fields in INFO.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

*Note _go32_dpmi_allocate_real_mode_callback_iret::


File: libc,  Node: _go32_dpmi_simulate_fcall,  Next: _go32_dpmi_simulate_fcall_iret,  Prev: _go32_dpmi_set_real_mode_interrupt_vector,  Up: Alphabetical List

_go32_dpmi_simulate_fcall
=========================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_simulate_fcall(_go32_dpmi_registers *regs);

Description
-----------

*Note DPMI Overview::

This function simulates a real-mode far call to a function that returns
with a far return.  The registers are set up from REGS, including `CS'
and `IP', which indicate the address of the call.  Any registers the
function modifies are reflected in REGS on return.

If `SS' and `SP' are both zero, a small temporary stack is used when in
real mode.  If not, they are used AS IS.  It's a good idea to use
`memset' to initialize the register structure before using it.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     _go32_dpmi_registers r;
     r.x.ax = 47;
     r.x.cs = some_segment;
     r.x.ip = some_offset;
     r.x.ss = r.x.sp = 0;
     _go32_dpmi_simulate_fcall(&r);
     printf("returns %d\n", r.x.ax);


File: libc,  Node: _go32_dpmi_simulate_fcall_iret,  Next: _go32_dpmi_simulate_int,  Prev: _go32_dpmi_simulate_fcall,  Up: Alphabetical List

_go32_dpmi_simulate_fcall_iret
==============================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_simulate_fcall_iret(_go32_dpmi_registers *regs);

Description
-----------

*Note DPMI Overview::

This function simulates a real-mode far call to a function that returns
with an `iret' instruction.  The registers are set up from REGS,
including `CS' and `IP', which indicate the address of the call.  Any
registers the function modifies are reflected in REGS on return.

If `SS' and `SP' are both zero, a small temporary stack is used when in
real mode.  If not, they are used AS IS.  It's a good idea to use
`memset' to initialize the register structure before using it.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     _go32_dpmi_registers r;
     r.x.ax = 47;
     r.x.cs = some_segment;
     r.x.ip = some_offset;
     r.x.ss = r.x.sp = 0;
     _go32_dpmi_simulate_fcall_iret(&r);
     printf("returns %d\n", r.x.ax);


File: libc,  Node: _go32_dpmi_simulate_int,  Next: _go32_info_block,  Prev: _go32_dpmi_simulate_fcall_iret,  Up: Alphabetical List

_go32_dpmi_simulate_int
=======================

Syntax
------

     #include <dpmi.h>
     
     int _go32_dpmi_simulate_int(int vector, _go32_dpmi_registers *regs);

Description
-----------

*Note DPMI Overview::

This function simulates a real-mode interrup.  The registers are set up
from REGS, including `CS' and `IP', which indicate the address of the
call.  Any registers the function modifies are reflected in REGS on
return.

If `SS' and `SP' are both zero, a small temporary stack is used when in
real mode.  If not, they are used AS IS.  It's a good idea to use
`memset' to initialize the register structure before using it.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     _go32_dpmi_registers r;
     r.h.ah = 0x08;
     r.h.dl = 0x80; /* drive C: */
     r.x.ss = r.x.sp = 0;
     _go32_dpmi_simulate_int(0x13, &r);
     printf("disk is %d cyl, %d head, %d sect\n",
            r.h.ch | ((r.x.cl<<2)&0x300),
            r.h.dh, r.h.cl & 0x3f));


File: libc,  Node: _go32_info_block,  Next: _go32_interrupt_stack_size,  Prev: _go32_dpmi_simulate_int,  Up: Alphabetical List

_go32_info_block
================

Syntax
------

     #include <go32.h>
     
     extern __Go32_Info_Block _go32_info_block;

Description
-----------

The go32 information block is a mechanism for `go32' to pass
information to the application.  Some of this information is generally
useful, such as the pid or the transfer buffer, while some is used
internally to `libc.a' only.

The structure has this format:

     typedef struct {
       unsigned long  size_of_this_structure_in_bytes;
       unsigned long  linear_address_of_primary_screen;
       unsigned long  linear_address_of_secondary_screen;
       unsigned long  linear_address_of_transfer_buffer;
       unsigned long  size_of_transfer_buffer;
       unsigned long  pid;
       unsigned char  master_interrupt_controller_base;
       unsigned char  slave_interrupt_controller_base;
       unsigned short selector_for_linear_memory;
       unsigned long  linear_address_of_stub_info_structure;
       unsigned long  linear_address_of_original_psp;
       unsigned short run_mode;
       unsigned short run_mode_info;
     } Go32_Info_Block;

The linear address fields provide values that are suitable for
`dosmemget', `dosmemput', and `movedata'.  The
selector_for_linear_memory is suitable for `<sys/farptr.h>' selector
parameters.

Due to the length of these fields, and their popularity, the following
macros are available:

`_dos_ds'
     This expands to _go32_info_block.selector_for_linear_memory

`__tb'
     This expands to _go32_info_block.linear_address_of_transfer_buffer

The `run_mode' field indicates the mode that the program is running in.
The following modes are defined:

`_GO32_RUN_MODE_UNDEF'
     This indicates that the extender did not (or could not) determine
     or provide the mode information.  The most probable reason is that
     it's an older extender that does not support this field.  The
     program should not assume anything about the run mode if it is
     this value.

`_GO32_RUN_MODE_RAW'
     This indicates that no CPU manager is being used, and no XMS
     manager is present.  The CPU is being managed directly from the
     extender, and memory was allocated from the extended memory pool.

`_GO32_RUN_MODE_XMS'
     This indicates that the extender is managing the CPU, but an XMS
     driver is managing the memory pool.

`_GO32_RUN_MODE_VCPI'
     This indicates that a VCPI server (like `emm386' or `qemm') is
     managing both the CPU and the memory.

`_GO32_RUN_MODE_DPMI'
     This indicates that a DPMI server (like `qdpmi' or Windows) is
     managing both the CPU and memory.  Programs may rely on this value
     to determine if it is safe to use DPMI 0.9 functions.

     If this value is set, the `run_mode_info' field has the DPMI
     specification version, in hex, shifted eight bits.  For example,
     DPMI 0.9 has 0x005A in the `run_mode_info' field.

Note that the program should not assume that the value will be one of
the listed values.  If the program is running with an extender that
provides some other mode (say, a newly released extender) then the
program should be able to handle that case gracefully.

Example
-------

     dosmemget(_go32_info_block.linear_address_of_primary_screen, 80*25*2, buf);


File: libc,  Node: _go32_interrupt_stack_size,  Next: _go32_my_cs,  Prev: _go32_info_block,  Up: Alphabetical List

_go32_interrupt_stack_size
==========================

Syntax
------

     #include <dpmi.h>
     
     extern unsigned long _go32_interrupt_stack_size;

Description
-----------

The default size of the interrupt handler's stack.  Defaults to 32k.


File: libc,  Node: _go32_my_cs,  Next: _go32_my_ds,  Prev: _go32_interrupt_stack_size,  Up: Alphabetical List

_go32_my_cs
===========

Syntax
------

     #include <go32.h>
     
     u_short _go32_my_cs();

Description
-----------

Returns the current `CS'.  This is useful for setting up interrupt
vectors and such.

Return Value
------------

`CS'


File: libc,  Node: _go32_my_ds,  Next: _go32_my_ss,  Prev: _go32_my_cs,  Up: Alphabetical List

_go32_my_ds
===========

Syntax
------

     #include <go32.h>
     
     u_short _go32_my_ds();

Description
-----------

Returns the current `DS'.  This is useful for moving memory and such.

Return Value
------------

`DS'


File: libc,  Node: _go32_my_ss,  Next: _go32_rmcb_stack_size,  Prev: _go32_my_ds,  Up: Alphabetical List

_go32_my_ss
===========

Syntax
------

     #include <go32.h>
     
     u_short _go32_my_ss();

Description
-----------

Returns the current `SS'.  This is useful for moving memory and such.

Return Value
------------

`SS'


File: libc,  Node: _go32_rmcb_stack_size,  Next: _go32_want_ctrl_break,  Prev: _go32_my_ss,  Up: Alphabetical List

_go32_rmcb_stack_size
=====================

Syntax
------

     #include <dpmi.h>
     
     extern unsigned long _go32_rmcb_stack_size;

Description
-----------

The default size of the real mode callback handler's stack.  Defaults
to 32k.


File: libc,  Node: _go32_want_ctrl_break,  Next: _go32_was_ctrl_break_hit,  Prev: _go32_rmcb_stack_size,  Up: Alphabetical List

_go32_want_ctrl_break
=====================

Syntax
------

     #include <go32.h>
     
     void   _go32_want_ctrl_break(int yes);

Description
-----------

This function tells go32 whether or not it wants `Ctrl-Break' to be an
exception or passed to the application.  If you pass a nonzero value
for YES, pressing `Ctrl-Break' will set a flag that can be detected
with `_go32_was_ctrl_break_hit' (*note _go32_was_ctrl_break_hit::.).
If you pass zero for YES, When you press `Ctrl-Break' the program will
be terminated.

Note that if you call `_go32_was_ctrl_break_hit', this function
automatically gets called to ask for `Ctrl-Break' events.

Return Value
------------

None.

Example
-------

     _g32_want_ctrl_break(1);
     do_something_long();
     _g32_want_ctrl_break(0);


File: libc,  Node: _go32_was_ctrl_break_hit,  Next: gotoxy,  Prev: _go32_want_ctrl_break,  Up: Alphabetical List

_go32_was_ctrl_break_hit
========================

Syntax
------

     #include <go32.h>
     
     unsigned _go32_was_ctrl_break_hit(void);

Description
-----------

This function returns the number of times that `Ctrl-Break' was hit
since the last call to this function or `_go32_want_ctrl_break' (*note
_go32_want_ctrl_break::.).

Return Value
------------

Zero if `Ctrl-Break' hasn't been hit, nonzero to indicate how many
times if it has been hit.

Note that `_go32_want_ctrl_break' is automatically called to request
these events, so you don't have to set up for this call.

Example
-------

     while (!_go32_was_ctrl_break_hit())
       do_something();


File: libc,  Node: gotoxy,  Next: gppconio_init,  Prev: _go32_was_ctrl_break_hit,  Up: Alphabetical List

gotoxy
======

Syntax
------

     #include <conio.h>
     
     void gotoxy(int x, int y);

Description
-----------

Move the cursor to row y, column x.  The upper left corner of the
current window is (1,1).


File: libc,  Node: gppconio_init,  Next: hasmntopt,  Prev: gotoxy,  Up: Alphabetical List

gppconio_init
=============

Syntax
------

     #include <conio.h>
     
     void gppconio_init(void);

Description
-----------

Initialize the screen.  This is called automatically at program start-up
if you use any of the `conio' functions, but there may be times when
you need to call it again, typically after calling some video BIOS
function which affects screen parameters.


File: libc,  Node: hasmntopt,  Next: highvideo,  Prev: gppconio_init,  Up: Alphabetical List

hasmntopt
=========

Syntax
------

     #include <mntent.h>
     
     char *hasmntopt(struct mntent *mnt, char *opt);

Description
-----------

This function scans the `mnt_opts' field of the `mntent' structure MNT
for a substring that matches OPT.  *Note getmntent::.

Return Value
------------

This function returns the address of the substring if a match is found,
or `NULL' otherwise.


File: libc,  Node: highvideo,  Next: htonl,  Prev: hasmntopt,  Up: Alphabetical List

highvideo
=========

Syntax
------

     #include <conio.h>
     
     void highvideo(void);

Description
-----------

Causes any new characters put on the screen to be bright.


File: libc,  Node: htonl,  Next: htons,  Prev: highvideo,  Up: Alphabetical List

htonl
=====

Syntax
------

     #include <netinet/in.h>
     
     unsigned long htonl(unsigned long val);

Description
-----------

This function converts from host formatted longs to network formatted
longs.  For the i386 and higher processors, this means that the bytes
are swapped from 1234 order to 4321 order.

Return Value
------------

The network-order value.

Example
-------

     packet.ipaddr = htonl(ip);


File: libc,  Node: htons,  Next: hypot,  Prev: htonl,  Up: Alphabetical List

htons
=====

Syntax
------

     #include <netinet/in.h>
     
     unsigned short htons(unsigned short val);

Description
-----------

This function converts from host formatted shorts to network formatted
shorts.  For the i386 and higher processors, this means that the bytes
are swapped from 12 order to 21 order.

Return Value
------------

The network-order value.

Example
-------

     tcp.port = htons(port);


File: libc,  Node: hypot,  Next: inb,  Prev: htons,  Up: Alphabetical List

hypot
=====

Syntax
------

     #include <math.h>
     
     double hypot(double x, double y);

Return Value
------------

The length of a hypotenuse of a right triangle whose shorter sides are
X and Y.  In other words, the distance between (0,0) and (X,Y).


File: libc,  Node: inb,  Next: index,  Prev: hypot,  Up: Alphabetical List

inb
===

Syntax
------

     #include <pc.h>
     
     unsigned char inb(unsigned short _port);

Description
-----------

Calls *Note inportb::. Provided only for compatibility.


File: libc,  Node: index,  Next: inp,  Prev: inb,  Up: Alphabetical List

index
=====

Syntax
------

     #include <strings.h>
     
     char *index(const char *string, int ch);

Description
-----------

Returns a pointer to the first occurrence of CH in STRING.  Note that
the `NULL' character counts, so if you pass zero as CH you'll get a
pointer to the end of the string back.

Return Value
------------

A pointer to the character, or `NULL' if it wasn't found.

Example
-------

     if (index(path, '*'))
       do_wildcards(path);


File: libc,  Node: inp,  Next: inportb,  Prev: index,  Up: Alphabetical List

inp
===

Syntax
------

     #include <pc.h>
     
     unsigned char inp(unsigned short _port);

Description
-----------

Calls *Note inportb::.  Provided only for compatibility.


File: libc,  Node: inportb,  Next: inportl,  Prev: inp,  Up: Alphabetical List

inportb
=======

Syntax
------

     #include <pc.h>
     
     unsigned char inportb(unsigned short _port);

Description
-----------

Read a single 8-bit I/O port.

This function is provided as an inline assembler macro, and will be
optimized down to a single opcode when you optimize your program.

Return Value
------------

The value returned through the port.


File: libc,  Node: inportl,  Next: inportsb,  Prev: inportb,  Up: Alphabetical List

inportl
=======

Syntax
------

     #include <pc.h>
     
     unsigned long inportl(unsigned short _port);

Description
-----------

This function reads a single 32-bit I/O port.

This function is provided as an inline assembler macro, and will be
optimized down to a single opcode when you optimize your program.

Return Value
------------

The value returned from the port.


File: libc,  Node: inportsb,  Next: inportsl,  Prev: inportl,  Up: Alphabetical List

inportsb
========

Syntax
------

     #include <pc.h>
     
     void inportsb(unsigned short _port, unsigned char *_buf, unsigned _len);

Description
-----------

Reads the 8-bit _PORT _LEN times, and stores the bytes in BUF.


File: libc,  Node: inportsl,  Next: inportsw,  Prev: inportsb,  Up: Alphabetical List

inportsl
========

Syntax
------

     #include <pc.h>
     
     void inportsl(unsigned short _port, unsigned long *_buf, unsigned _len);

Description
-----------

Reads the 32-bit _PORT _LEN times, and stores the bytes in BUF.


File: libc,  Node: inportsw,  Next: inportw,  Prev: inportsl,  Up: Alphabetical List

inportsw
========

Syntax
------

     #include <pc.h>
     
     void inportsw(unsigned short _port, unsigned short *_buf, unsigned _len);

Description
-----------

Reads the 16-bit _PORT _LEN times, and stores the bytes in BUF.


File: libc,  Node: inportw,  Next: inpw,  Prev: inportsw,  Up: Alphabetical List

inportw
=======

Syntax
------

     #include <pc.h>
     
     unsigned short inportw(unsigned short _port);

Description
-----------

Read a single 16-bit I/O port.

This function is provided as an inline assembler macro, and will be
optimized down to a single opcode when you optimize your program.

Return Value
------------

The value returned through the port.


File: libc,  Node: inpw,  Next: insline,  Prev: inportw,  Up: Alphabetical List

inpw
====

Syntax
------

     #include <pc.h>
     
     unsigned short inpw(unsigned short _port);

Description
-----------

Calls *Note inportw::.  Provided only for compatibility.


File: libc,  Node: insline,  Next: insque,  Prev: inpw,  Up: Alphabetical List

insline
=======

Syntax
------

     #include <conio.h>
     
     void insline(void);

Description
-----------

A blank line is inserted at the current cursor position.  The previous
line and lines below it scroll down.


File: libc,  Node: insque,  Next: int386,  Prev: insline,  Up: Alphabetical List

insque
======

Syntax
------

     #include <search.h>
     
     void insque(struct qelem *elem, struct qelem *pred);

Description
-----------

This function manipulates queues built from doubly linked lists.  Each
element in the queue must be in the form of `struct qelem' which is
defined thus:

     struct qelem {
       struct qelem *q_forw;
       struct qelem *q_back;
       char q_data[0];
     }

This function inserts ELEM in a queue immediately after PRED.

Return Value
------------

None.


File: libc,  Node: int386,  Next: int386x,  Prev: insque,  Up: Alphabetical List

int386
======

Syntax
------

     #include <dos.h>
     
     int int386(int ivec, union REGS *in, union REGS *out);

Description
-----------

This function is equal to `int86' function.  See *Note int86:: for
further description.

Return Value
------------

The returned value of `EAX'.


File: libc,  Node: int386x,  Next: int86,  Prev: int386,  Up: Alphabetical List

int386x
=======

Syntax
------

     #include <dos.h>
     
     int int386x(int ivec, union REGS *in, union REGS *out, struct SREGS *seg);

Description
-----------

This function is equal to `int86x'.  See *Note int86:: for further
description.

Return Value
------------

The value of `EAX' is returned.


File: libc,  Node: int86,  Next: int86x,  Prev: int386x,  Up: Alphabetical List

int86
=====

Syntax
------

     #include <dos.h>
     
     int int86(int ivec, union REGS *in, union REGS *out);

Description
-----------

Note: The `.x.' branch is a problem generator.  Most code expects the
`.x.' branch to have e.g. "`.x.ax'" members, and that they are 16-bit.
If you know you want 32-bit values, use the `.d.eax' members.  If you
know you want 16-bit values, use the `.w.ax' members.  The `.x.'
members behave according to `#defines', as follows:

`default'
     If you specify no `#define', the `.x.' branch has "`ax'" members
     and is 32-bit.  This is compatible with previous versions of djgpp.

`_NAIVE_DOS_REGS'
     This define gives you `.x.ax', but they are 16-bit.  This is
     probably what most programs ported from 16-bit dos compilers will
     want.

`_BORLAND_DOS_REGS'
     This define gives you `.x.eax' which are 32-bit.  This is
     compatible with Borland's 32-bit compilers.

This function simulates a software interrupt.  Note that, unlike the
`__dpmi_int' function, requests that go through `int86' and similar
functions are specially processed to make them suitable for invoking
real-mode interrupts from protected-mode programs.  For example, if a
particular routine takes a pointer in `BX', `int86' expects you to put
a (protected-mode) pointer in `EBX'.  Therefore, `int86' should have
specific support for every interrupt and function you invoke this way.
Currently, it supports only a subset of all available interrupts and
functions:

1) All functions of any interrupt which expects only scalar arguments
registers (i.e., no pointers to buffers).

2) In addition, the following functions of interrupt 21h are supported:
9, 39h, 3Ah, 3Bh, 3Ch, 3Dh, 3Fh, 40h, 41h, 43h, 47h, 56h.

When the interrupt is invoked, the CPU registers are copied from IN.
After the interrupt, the CPU registers are copied to OUT.

This function is just like `int86x' (*note int86x::.) except that
suitable default values are used for the segment registers.

*Note int86x::. *Note intdos::. *Note bdos::.

Return Value
------------

The returned value of `EAX'.

Example
-------

     union REGS r;
     r.x.ax = 0x0100;
     r.h.dl = 'c';
     int86(0x21, &r, &r);


File: libc,  Node: int86x,  Next: intdos,  Prev: int86,  Up: Alphabetical List

int86x
======

Syntax
------

     #include <dos.h>
     
     int int86x(int ivec, union REGS *in, union REGS *out, struct SREGS *seg);

Description
-----------

This function is just like `int86' (*note int86::.) except that values
you pass in SREGS are used for the segment registers instead of the
defaults.

*Note int86::. *Note intdos::. *Note bdos::.

Return Value
------------

The value of `EAX' is returned.

Example
-------

     union REGS r;
     struct SREGS s;
     r.h.ah = 0x31;
     r.h.dl = 'c';
     r.x.si = si_val;
     s.ds = ds_val;
     int86x(0x21, &r, &r, &s);


File: libc,  Node: intdos,  Next: intdosx,  Prev: int86x,  Up: Alphabetical List

intdos
======

Syntax
------

     #include <dos.h>
     
     int intdos(union REGS *in, union REGS *out);

Description
-----------

This function is just like `int86' (*note int86x::.) except that the
interrupt vector is 0x21.

Return Value
------------

`EAX'


File: libc,  Node: intdosx,  Next: _is_executable,  Prev: intdos,  Up: Alphabetical List

intdosx
=======

Syntax
------

     #include <dos.h>
     
     int intdosx(union REGS *in, union REGS *out, struct SREGS *s);

Description
-----------

This function is just like `int86x' (*note int86x::.) except that the
interrupt vector is 0x21.

Return Value
------------

`EAX'


File: libc,  Node: _is_executable,  Next: isalnum,  Prev: intdosx,  Up: Alphabetical List

_is_executable
==============

Syntax
------

     #include <sys/stat.h>
     
     int _is_executable(const char *path, int fhandle, const char *extension);

Description
-----------

This function determines if a file is executable under DOS/DJGPP
environment.  The file may be given either by its PATH or its file
handle FHANDLE.  If EXTENSION is non-NULL and non-empty, it is used
first to look up in a list of known extensions which determine whether
the file is executable.  (If the _STAT_EXEC_EXT bit of the *Note
_djstat_flags:: global variable is not set, this step is skipped.) If
EXTENSION is unavailable or not enough to determine the result, the
first 2 bytes of the file are checked to contain one of the known
`magic numbers' identifying the file as executable.  If the file's 2
first bytes need to be read but the read fails, 0 is returned and errno
is set.  (The file is only searched for magic number if the
_STAT_EXEC_MAGIC bit of the *Note _djstat_flags:: variable is set.)

Note that if _STAT_EXEC_MAGIC is set, but _STAT_EXEC_EXT is not, some
files which shouldn't be flagged as executables (e.g., COFF *.o object
files) will have their execute bit set, because they have the magic
number signature at their beginning.  Therefore, only use the above
combination if you want to debug the list of extensions provided in
is_exec.c file.

If the file passed by its handle was open as write-only, and the
extension alone isn't enough to determine whether the file is
executable, then this function returns 0, because it cannot look at the
`magic number'.

This function is used internally by `f?stat()'; you are not supposed to
call it directly.

Return Value
------------

1 for executable file, 0 otherwise (including in case of errors in
accessing the file).


File: libc,  Node: isalnum,  Next: isalpha,  Prev: _is_executable,  Up: Alphabetical List

isalnum
=======

Syntax
------

     #include <ctype.h>
     
     int isalnum(int c);

Description
-----------

Tells if C is any letter or digit.

Return Value
------------

Nonzero if C is a letter or digit, else zero.

Example
-------


File: libc,  Node: isalpha,  Next: isascii,  Prev: isalnum,  Up: Alphabetical List

isalpha
=======

Syntax
------

     #include <ctype.h>
     
     int isalpha(int c);

Description
-----------

Tells if C is a letter.

Return Value
------------

Nonzero if C is a letter, else zero.


File: libc,  Node: isascii,  Next: isatty,  Prev: isalpha,  Up: Alphabetical List

isascii
=======

Syntax
------

     #include <ctype.h>
     
     int isascii(int c);

Description
-----------

Tells if C is an ASCII character (0x00 to 0x7f).

Return Value
------------

Nonzero if C is ASCII, else zero.


File: libc,  Node: isatty,  Next: iscntrl,  Prev: isascii,  Up: Alphabetical List

isatty
======

Syntax
------

     #include <unistd.h>
     
     int isatty(int fd);

Description
-----------

Tells if the file descriptor refers to a terminal device or not.

Return Value
------------

Nonzero if FD is a terminal device, zero  otherwise.

Example
-------

     if (isatty(1))
       fflush(stdout);


File: libc,  Node: iscntrl,  Next: isdigit,  Prev: isatty,  Up: Alphabetical List

iscntrl
=======

Syntax
------

     #include <ctype.h>
     
     int iscntrl(int c);

Description
-----------

Tells if C is a control character.

Return Value
------------

Nonzero if C is a control character, else zero.


File: libc,  Node: isdigit,  Next: isgraph,  Prev: iscntrl,  Up: Alphabetical List

isdigit
=======

Syntax
------

     #include <ctype.h>
     
     int isdigit(int c);

Description
-----------

Tells if C is a digit.

Return Value
------------

Nonzero if C is a digit, else zero.


File: libc,  Node: isgraph,  Next: islower,  Prev: isdigit,  Up: Alphabetical List

isgraph
=======

Syntax
------

     #include <ctype.h>
     
     int isgraph(int c);

Description
-----------

Tells if C is a visible printing character.  Space is not included.

Return Value
------------

Nonzero if C is a visible printing character, else zero.


File: libc,  Node: islower,  Next: isprint,  Prev: isgraph,  Up: Alphabetical List

islower
=======

Syntax
------

     #include <ctype.h>
     
     int islower(int c);

Description
-----------

Tells if C is lower case or not.

Return Value
------------

Nonzero if C is lower case, else zero.


File: libc,  Node: isprint,  Next: ispunct,  Prev: islower,  Up: Alphabetical List

isprint
=======

Syntax
------

     #include <ctype.h>
     
     int isprint(int c);

Description
-----------

Tells if C is a printing character, which includes the space character.

Return Value
------------

Nonzero if C is a printing character, else zero.


File: libc,  Node: ispunct,  Next: isspace,  Prev: isprint,  Up: Alphabetical List

ispunct
=======

Syntax
------

     #include <ctype.h>
     
     int ispunct(int c);

Description
-----------

Tells if C is any printing character except space and those indicated
by `isalnum'.

Return Value
------------

Nonzero if C is punctuation, else zero.


File: libc,  Node: isspace,  Next: isupper,  Prev: ispunct,  Up: Alphabetical List

isspace
=======

Syntax
------

     #include <ctype.h>
     
     int isspace(int c);

Description
-----------

Tells if C is whitespace, that is, carriage return, newline, form feed,
tab, vertical tab, or space.

Return Value
------------

Nonzero if C is whitespace, else zero.


File: libc,  Node: isupper,  Next: isxdigit,  Prev: isspace,  Up: Alphabetical List

isupper
=======

Syntax
------

     #include <ctype.h>
     
     int isupper(int c);

Description
-----------

Tells if C is an upper case character or not.

Return Value
------------

Nonzero if C is upper case, else zero.


File: libc,  Node: isxdigit,  Next: itoa,  Prev: isupper,  Up: Alphabetical List

isxdigit
========

Syntax
------

     #include <ctype.h>
     
     int isxdigit(int c);

Description
-----------

Tells if C is a valid hexidecimal digit or not.  This includes
`[0-9a-fA-F]'.

Return Value
------------

Nonzero if C is a hex digit, else zero.


File: libc,  Node: itoa,  Next: kbhit,  Prev: isxdigit,  Up: Alphabetical List

itoa
====

Syntax
------

     #include <stdlib.h>
     
     char * itoa(int value, char *string, int radix)

Description
-----------

This function converts its argument VALUE into a null-terminated
character string using RADIX as the base of the number system.  The
resulting string with a length of upto 33 bytes (including the optional
sign and the terminating `NULL' is put into the buffer whose address is
given by STRING.  For radixes other than 10, VALUE is treated as an
unsigned int (i.e., the sign bit is not interpreted as such).  The
argument RADIX should specify the base, between 2 and 36, in which the
string reprsentation of VALUE is requested.

Return Value
------------

A pointer to STRING.

Example
-------

     char binary_str[33];
     
     (void)itoa(num, binary_str, 2);


File: libc,  Node: kbhit,  Next: kill,  Prev: itoa,  Up: Alphabetical List

kbhit
=====

Syntax
------

     #include <pc.h>
     
     int kbhit(void);

Description
-----------

If the user has hit a key, this function will detect it.  This function
is very fast when there is no key waiting, so it may be used inside
loops as needed.

If you test shift/alt/ctrl status with bios calls (e.g., using `bioskey
(2)' or `bioskey (0x12)') then you should also use bios calls for
testing for keys.  This can be done with by `bioskey (1)' or `bioskey
(0x11)'.  Failing to do so can cause trouble in multitasking
environments like DESQview/X.

Return Value
------------

Nonzero if a key has been hit, else zero.

Example
-------

     while (!kbhit())
       do_stuff();


File: libc,  Node: kill,  Next: labs,  Prev: kbhit,  Up: Alphabetical List

kill
====

     #include <signal.h>
     
     int	kill(pid_t _pid, int _sig);

Description
-----------

If _PID is the current `getpid()', the given _SIG is raised with *Note
raise::.

Return Value
------------

-1 on error, else zero.


File: libc,  Node: labs,  Next: ldexp,  Prev: kill,  Up: Alphabetical List

labs
====

Syntax
------

     #include <stdlib.h>
     
     long labs(long x);

Description
-----------

This function takes the absolute value of X.  *Note abs::.

Return Value
------------

|X|


File: libc,  Node: ldexp,  Next: ldiv,  Prev: labs,  Up: Alphabetical List

ldexp
=====

Syntax
------

     #include <math.h>
     
     double ldexp(double val, int exp);

Return Value
------------

This function returns VAL * 2 ** EXP.

Example
-------

     ldexp(3.5,4) == 3.5 * 16 == 56.0


File: libc,  Node: ldiv,  Next: link,  Prev: ldexp,  Up: Alphabetical List

ldiv
====

Syntax
------

     #include <stdlib.h>
     
     ldiv_t ldiv(long numerator, long denomonator);

Description
-----------

Returns the quotient and remainder of the division NUMBERATOR divided
by DENOMONATOR.  The return type is as follows:

     typedef struct {
       long quot;
       long rem;
     } ldiv_t;

Return Value
------------

The results of the division are returned.

Example
-------

     ldiv_t l = ldiv(42, 3);
     printf("42 = %ld x 3 + %ld\n", l.quot, l.rem);
     
     ldiv(+40, +3) = { +13, +1 }
     ldiv(+40, -3) = { -13, -1 }
     ldiv(-40, +3) = { -13, -1 }
     ldiv(-40, -3) = { +13, -1 }


File: libc,  Node: link,  Next: localeconv,  Prev: ldiv,  Up: Alphabetical List

link
====

Syntax
------

     #include <unistd.h>
     
     int link(const char *exists, const char *new);

Description
-----------

Because of limitations of MS-DOS, this function doesn't really link two
files together.  However, it simulates a real `link' by copying the
file at EXISTS to NEW.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     link("foo.c", "foo.bak");


File: libc,  Node: localeconv,  Next: localtime,  Prev: link,  Up: Alphabetical List

localeconv
==========

Syntax
------

     #include <locale.h>
     
     struct lconv *localeconv(void);

Description
-----------

This function returns a pointer to a static structure that contains
information about the current locale.  The structure contains these
fields:

`char *currency_symbol'
     A string that should be used when printing local currency.

`char *decimal_point'
     A string that is used to separate the integer and fractional
     portions of real numbers in `printf'.  Currently, only the first
     character is significant.

`char *grouping'
     An array of numbers indicating the size of groupings for
     non-monetary values to the left of the decimal point.  The first
     number is the size of the grouping just before the decimal point.
     A number of zero means to repeat the previous number indefinitely.
     A number of `CHAR_MAX' means to group the remainder of the digits
     together.

`char *int_curr_symbol'
     A string that should be used when formatting monetary values for
     local currency when the result will be used internationally.

`char *mon_decimal_point'
     A string that separates the interger and fractional parts of
     monetary values.

`char *mon_grouping'
     Same as grouping, but for monetary values.

`char *negative_sign'
     A string that is used to represent negative monetary values.

`char *positive_sign'
     A string that is used to represent positive monetary values.

`char *thousands_sep'
     The grouping separator for non-monetary values.

`char frac_digits'
     The number of digits to the right of the decimal point for monetary
     values.

`char int_frac_digits'
     Like frac_digits, but when formatting for international use.

`char n_cs_precedes'
     If nonzero, the currency string should precede the monetary value
     if the monetary value is negative.

`char n_sep_by_space'
     If nonzero, the currency string and the monetary value should be
     separated by a space if the monetary value is negative.

`char n_sign_posn'
     Determines the placement of the negative indication string if the
     monetary value is negative.

    0
          ($value), (value$)

    1
          -$value, -value$

    2
          $value-, value$-

    3
          -$value, value-$

    4
          $-value, value$-

`char p_cs_precedes'
`char p_sep_by_space'
`char p_sign_posn'
     These are the same as n_*, but for when the monetary value is
     positive.

Note that any numeric field may have a value of `CHAR_MAX', which
indicates that no information is available.

Return Value
------------

A pointer to the `struct lconv' structure.

Example
-------

     struct lconv *l = localeconv;
     printf("%s%d\n", l->negative_sign, value);


File: libc,  Node: localtime,  Next: lock,  Prev: localeconv,  Up: Alphabetical List

localtime
=========

Syntax
------

     #include <time.h>
     
     struct tm *localtime(const time_t *tod);

Description
-----------

Converts the time represented by TOD into a structure, correcting for
the local timezone.  *Note gmtime::.

Return Value
------------

A pointer to a static structure which is overridden with each call.


File: libc,  Node: lock,  Next: log,  Prev: localtime,  Up: Alphabetical List

lock
====

Syntax
------

     #include <io.h>
     
     int lock(int fd, long offset, long length);

Description
-----------

Locks a region in file FD using MS-DOS file sharing interface.  The
region of LENGTH bytes, starting from OFFSET, will become entirely
inaccessible to other processes. If multiple locks are used on a single
file they must be non-overlapping. The lock must be removed before the
file is closed.

This function will fail unless SHARE, or a network software providing
similar interface, is installed. This function is compatible with
Borland C++ function of the same name.

*Note unlock::.

Return Value
------------

Zero if successful, nonzero if not.


File: libc,  Node: log,  Next: log10,  Prev: lock,  Up: Alphabetical List

log
===

Syntax
------

     #include <math.h>
     
     double log(double x);

Return Value
------------

The natural logarithm of X.


File: libc,  Node: log10,  Next: log2,  Prev: log,  Up: Alphabetical List

log10
=====

Syntax
------

     #include <math.h>
     
     double log10(double x);

Return Value
------------

The logarithm base 10 of X.


File: libc,  Node: log2,  Next: longjmp,  Prev: log10,  Up: Alphabetical List

log2
====

Syntax
------

     #include <math.h>
     
     double log2(double x);

Return Value
------------

The logarithm base 2 of X.


File: libc,  Node: longjmp,  Next: lowvideo,  Prev: log2,  Up: Alphabetical List

longjmp
=======

Syntax
------

     #include <setjmp.h>
     
     void longjmp(jmp_buf env, int val);

Description
-----------

This function reverts back to a CPU state that was stored in ENV by
`setjmp' (*note setjmp::.).  The state includes all CPU registers, so
any variable in a register when `setjmp' was called will be preserved,
and all else will be indeterminate.

The value passed as VAL will be the return value of `setjmp' when it
resumes processing there.  If VAL is zero, the return value will be one.

Return Value
------------

This function does not return.

Example
-------

     jmp_buf j;
     if (setjmp(j))
       return;
     do_something();
     longjmp(j);


File: libc,  Node: lowvideo,  Next: lseek,  Prev: longjmp,  Up: Alphabetical List

lowvideo
========

Syntax
------

     #include <conio.h>
     
     void    lowvideo(void);

Description
-----------

Causes any new characters put on the screen to be dim.


File: libc,  Node: lseek,  Next: malloc,  Prev: lowvideo,  Up: Alphabetical List

lseek
=====

Syntax
------

     #include <unistd.h>
     
     off_t lseek(int fd, off_t offset, int whence);

Description
-----------

This function moves the file pointer for FD according to MODE:

`SEEK_SET'
     The file pointer is moved to the offset specified.

`SEEK_CUR'
     The file pointer is moved relative to its current position.

`SEEK_END'
     The file pointer is moved to a position OFFSET bytes from the end
     of the file.  The offset is usually nonpositive in this case.

Return Value
------------

The new offset is returned.

Example
-------

     lseek(fd, 12, SEEK_CUR); /* skip 12 bytes */


File: libc,  Node: malloc,  Next: mblen,  Prev: lseek,  Up: Alphabetical List

malloc
======

Syntax
------

     #include <stdlib.h>
     
     void *malloc(size_t size);

Description
-----------

This function allocates a chunk of memory from the heap large enough to
hold any object that is SIZE bytes in length.  This memory must be
returned to the heap with `free' (*note free::.).

Return Value
------------

A pointer to the allocated memory, or `NULL' if there isn't enough free
memory to satisfy the request.

Example
-------

     char *c = (char *)malloc(100);


File: libc,  Node: mblen,  Next: mbstowcs,  Prev: malloc,  Up: Alphabetical List

mblen
=====

Syntax
------

     #include <stdlib.h>
     
     int mblen(const char *s, size_t n);

Description
-----------

This function returns the number of characters of string S that make up
the next multibyte character.  No more than N characters are checked.

If S is `NULL', the internal shift state is reset.

Return Value
------------

The number of characters that comprise the next multibyte character.

Example
-------

     int n = mblen(string, INT_MAX);
     string += n;


File: libc,  Node: mbstowcs,  Next: mbtowc,  Prev: mblen,  Up: Alphabetical List

mbstowcs
========

Syntax
------

     #include <stdlib.h>
     
     size_t mbstowcs(wchar_t *wcs, const char *s, size_t n);

Description
-----------

Converts a multibyte string to a wide character string.  The result
will be no more than N wide characters.

Return Value
------------

The number of wide characters stored.

Example
-------

     int wlen = mbtowcs(wbuf, string, sizeof(wbuf)/sizeof(wchar_t));


File: libc,  Node: mbtowc,  Next: memccpy,  Prev: mbstowcs,  Up: Alphabetical List

mbtowc
======

Syntax
------

     #include <stdlib.h>
     
     int mbtowc(wchar_t *pwc, const char *s, size_t n);

Description
-----------

Convert the first multibyte sequence in S to a wide character.  At most
N characters are checked.  If PWC is not `NULL', the result is stored
there.  If S is null, the internal shift state is reset.

Return Value
------------

The number of characters used by the multibyte sequence.

Example
-------

     string += mbtowc(&wc, string, strlen(string));


File: libc,  Node: memccpy,  Next: memchr,  Prev: mbtowc,  Up: Alphabetical List

memccpy
=======

Syntax
------

     #include <string.h>
     
     void * memccpy(void *to, const void *from, int ch, size_t nbytes)

Description
-----------

This function copies characters from memory area FROM into TO, stopping
after the first occurrence of character CH has been copied, or after
NBYTES characters have been copied, whichever comes first.  The buffers
should not overlap.

Return Value
------------

A pointer to the character after the copy of CH in TO, or a `NULL'
pointer if CH was not found in the first NBYTES characters of FROM.

Example
-------

     char inpbuf[256], dest[81];
     
     printf("Enter a path: ");
     fflush(stdout);
     gets(inpbuf);
     memset(dest, 0, sizeof(dest));
     if (memccpy(dest, inpbuf, '\\', 80))
       printf("The first directory in path is %s\n", dest);
     else
       printf("No explicit directory in path\n");


File: libc,  Node: memchr,  Next: memcmp,  Prev: memccpy,  Up: Alphabetical List

memchr
======

Syntax
------

     #include <string.h>
     
     void *memchr(const void *string, int ch, size_t num);

Description
-----------

This function searches NUM bytes starting at STRING, looking for the
first occurence of CH.

Return Value
------------

A pointer to the first match, or `NULL' if it wasn't found.

Example
-------

     if (memchr(path, '/', strlen(path))
       do_slash();


File: libc,  Node: memcmp,  Next: memcpy,  Prev: memchr,  Up: Alphabetical List

memcmp
======

Syntax
------

     #include <string.h>
     
     int memcmp(const void *s1, const void *s2, size_t num);

Description
-----------

This function compares two regions of memory, at S1 and S2, for NUM
bytes.

Return Value
------------

zero
     s1 == s2

positive
     s1 > s2

negative
     s1 < s2


File: libc,  Node: memcpy,  Next: memmove,  Prev: memcmp,  Up: Alphabetical List

memcpy
======

Syntax
------

     #include <string.h>
     
     void *memcpy(void *dest, const void *src, int num);

Description
-----------

This function copies NUM bytes from SOURCE to DEST.

Return Value
------------

DEST

Example
-------

     memcpy(buffer, temp_buffer, BUF_MAX);


File: libc,  Node: memmove,  Next: memset,  Prev: memcpy,  Up: Alphabetical List

memmove
=======

Syntax
------

     #include <string.h>
     
     void *memmove(void *dest, const void *source, int num);

Description
-----------

This function copies NUM bytes from SOURCE to DEST.  The copy is done
in such a way that if the two regions overlap, the source is always
read before that byte is changed by writing to the destination.

Return Value
------------

DEST

Example
-------

     memmove(buf+1, buf, 99);
     memmove(buf, buf+1, 99);


File: libc,  Node: memset,  Next: mkdir,  Prev: memmove,  Up: Alphabetical List

memset
======

Syntax
------

     #include <string.h>
     
     void *memset(void *buffer, int ch, size_t num);

Description
-----------

This function stores NUM copies of CH, starting at BUFFER.  This is
often used to initialize objects to a known value.

Return Value
------------

BUFFER

Example
-------

     struct tm t;
     memset(&t, 0, sizeof(t));


File: libc,  Node: mkdir,  Next: mkfifo,  Prev: memset,  Up: Alphabetical List

mkdir
=====

Syntax
------

     #include <sys/stat.h>
     
     int mkdir(const char *path, mode_t mode);

Description
-----------

This function creates a subdirectory.  The MODE field is ignored under
MS-DOS.

Return Value
------------

Zero if the subdirectory was created, nonzero on failure.

Example
-------

     mkdir("/usr/tmp", S_IWUSR);


File: libc,  Node: mkfifo,  Next: mknod,  Prev: mkdir,  Up: Alphabetical List

mkfifo
======

Description
-----------

This function is provided only to assist in porting from Unix.  It
always returns an error condition.


File: libc,  Node: mknod,  Next: mkstemp,  Prev: mkfifo,  Up: Alphabetical List

mknod
=====

Description
-----------

This function is provided only to assist in porting from Unix.  It
always returns an error condition.


File: libc,  Node: mkstemp,  Next: mktemp,  Prev: mknod,  Up: Alphabetical List

mkstemp
=======

Syntax
------

     #include <stdio.h>
     
     int mkstemp(char *template);

Description
-----------

TEMPLATE is a file specification that ends with six trailing `X'
characters.  This function replaces the `XXXXXX' with a set of
characters such that the resulting file name names a nonexisting file.
It then creates and opens the file.

Note that since MS-DOS is limited to eight characters for the file name,
and since none of the `X''s get replaced by a dot, you can only have
two additional characters before the `X''s.

Return Value
------------

The open file descriptor.

Example
-------

     int fd = mkstemp("/tmp/ccXXXXXX");


File: libc,  Node: mktemp,  Next: mktime,  Prev: mkstemp,  Up: Alphabetical List

mktemp
======

Syntax
------

     #include <stdio.h>
     
     char *mktemp(char *template);

Description
-----------

TEMPLATE is a file specification that ends with six trailing `X'
characters.  This function replaces the `XXXXXX' with a set of
characters such that the resulting file name names a nonexisting file.

Note that since MS-DOS is limited to eight characters for the file name,
and since none of the `X''s get replaced by a dot, you can only have
two additional characters before the `X''s.

Return Value
------------

The resulting filename.

Example
-------

     char template[] = "/tmp/ccXXXXXX";
     mktemp(template);
     FILE *q = fopen(template, "w");


File: libc,  Node: mktime,  Next: modf,  Prev: mktemp,  Up: Alphabetical List

mktime
======

Syntax
------

     #include <time.h>
     
     time_t mktime(struct tm *tptr);

Description
-----------

This function converts a time structure into the number of seconds since
00:00:00 GMT 1/1/1970.  It also attempts to normalize the fields of
TPTR.

Return Value
------------

The resulting time, or -1 if the time in TPTR cannot be described in
that format.


File: libc,  Node: modf,  Next: modfl,  Prev: mktime,  Up: Alphabetical List

modf
====

Syntax
------

     #include <math.h>
     
     double modf(double x, double *pint);

Description
-----------

`modf' breaks down X into its integer portion (which it stores in
*PINT) and the remaining fractional portion, which it returns.

Return Value
------------

The fractional portion.


File: libc,  Node: modfl,  Next: _mono_clear,  Prev: modf,  Up: Alphabetical List

modfl
=====

Syntax
------

     #include <math.h>
     
     long double modf(long double x, long double *pint);

Description
-----------

`modfl' breaks down X into its integer portion (which it stores in
*PINT) and the remaining fractional portion, which it returns.

Return Value
------------

The fractional portion.


File: libc,  Node: _mono_clear,  Next: _mono_printf,  Prev: modfl,  Up: Alphabetical List

_mono_clear
===========

Syntax
------

     #include <sys/mono.h>
     
     void _mono_clear(void);

Description
-----------

Clears the monochrome monitor.


File: libc,  Node: _mono_printf,  Next: _mono_putc,  Prev: _mono_clear,  Up: Alphabetical List

_mono_printf
============

Syntax
------

     #include <sys/mono.h>
     
     void _mono_printf(const char *fmt, ...);

Description
-----------

Like *Note printf::, but prints to the monochrome monitor.


File: libc,  Node: _mono_putc,  Next: movedata,  Prev: _mono_printf,  Up: Alphabetical List

_mono_putc
==========

Syntax
------

     #include <mono.h>
     
     void _mono_putc(int c);

Description
-----------

Prints a single character to the monochrome monitor.


File: libc,  Node: movedata,  Next: movedatab,  Prev: _mono_putc,  Up: Alphabetical List

movedata
========

Syntax
------

     #include <sys/movedata.h>
     
     void movedata(unsigned source_selector, unsigned source_offset,
                   unsigned dest_selector, unsigned dest_offset,
                   size_t length);

Description
-----------

This function allows the caller to directly transfer information
between conventional and linear memory, and among each as well.  The
selectors passed are *not* segment values like in DOS.  They are
protected mode selectors that can be obtained by the `_my_ds' and
`_go32_info_block.selector_for_linear_memory' (or just `_dos_ds')
functions (*Note _my_ds::, *Note _go32_info_block::).  The offsets are
linear offsets.  If the selector is for the program's data area, this
offset corresponds to the address of a buffer (like `(int)&something').
If the selector is for the conventional memory area, the offset is the
physical address of the memory, which can be computed from a
traditional segment/offset pair as `segment'*16+`offset'.  For example,
the color text screen buffer is at offset 0xb8000.

Return Value
------------

None.

Example
-------

     short blank_row_buf[ScreenCols()];
     /* scroll screen */
     movedata(_dos_ds, 0xb8000 + ScreenCols()*2,
              _dos_ds, 0xb8000,
              ScreenCols() * (ScreenRows()-1) * 2);
     /* fill last row */
     movedata(_my_ds, (int)blank_row_buf,
              _dos_ds, 0xb8000 + ScreenCols()*(ScreenRows()-1)*2,
               ScreenCols() * 2);


File: libc,  Node: movedatab,  Next: movedatal,  Prev: movedata,  Up: Alphabetical List

movedatab
=========

Syntax
------

     #include <sys/movedata.h>
     
     void _movedatab(unsigned, unsigned, unsigned, unsigned, size_t);

Description
-----------

Just like *Note movedata::, but all transfers are always 8-bit
transfers.


File: libc,  Node: movedatal,  Next: movedataw,  Prev: movedatab,  Up: Alphabetical List

movedatal
=========

Syntax
------

     #include <sys/movedata.h>
     
     void _movedatal(unsigned, unsigned, unsigned, unsigned, size_t);

Description
-----------

Just like *Note movedata::, but all transfers are always 32-bit
transfers, and the count is a count of transfers, not bytes.


File: libc,  Node: movedataw,  Next: movetext,  Prev: movedatal,  Up: Alphabetical List

movedataw
=========

Syntax
------

     #include <sys/movedata.h>
     
     void _movedataw(unsigned, unsigned, unsigned, unsigned, size_t);

Description
-----------

Just like *Note movedata::, but all transfers are always 16-bit
transfers, and the count is a count of transfers, not bytes.


File: libc,  Node: movetext,  Next: mprotect,  Prev: movedataw,  Up: Alphabetical List

movetext
========

Syntax
------

     #include <conio.h>
     
     int movetext(int _left, int _top, int _right, int _bottom,
                  int _destleft, int _desttop);

Description
-----------

Moves a block of text on the screen.

Return Value
------------

1 on success, zero on error.


File: libc,  Node: mprotect,  Next: _my_cs,  Prev: movetext,  Up: Alphabetical List

mprotect
========

Syntax
------

     #include <sys/types.h>
     #include <sys/mman.h>
     
     int mprotect(void *addr, size_t len, int prot);

Description
-----------

This function modifies the access protection of a memory region.
Protection occurs in 4Kbyte regions (pages) aligned on 4Kbyte
boundaries.  All pages in the region will be changed, so ADDR and LEN
should be multiples of 4096.

The protection PROT for each page is specified with the values:
PROT_NONE  Region can not be touched (if or'ed is ignored).
PROT_READ  Region can be read (can be or'ed with PROT_WRITE).
PROT_WRITE Region can be written (implies read access).

This function is only supported on DPMI hosts which provide some V1.0
extensions on V0.9 memory blocks.

Return Value
------------

The function returns 0 if successful and the value -1 if all the pages
could not be set.

Example
-------

     mprotect(readonly_buffer,8192,PROT_READ);
     mprotect(guard_area,4096,PROT_NONE);
     mprotect(NULL,4096,PROT_WRITE);	/* Let NULL pointers not generate exceptions */


File: libc,  Node: _my_cs,  Next: _my_ds,  Prev: mprotect,  Up: Alphabetical List

_my_cs
======

Syntax
------

     #include <sys/segments.h>
     
     unsigned short _my_cs();

Description
-----------

Returns the current `CS'.  This is useful for setting up interrupt
vectors and such.

Return Value
------------

`CS'


File: libc,  Node: _my_ds,  Next: _my_ss,  Prev: _my_cs,  Up: Alphabetical List

_my_ds
======

Syntax
------

     #include <sys/segments.h>
     
     unsigned short _my_ds();

Description
-----------

Returns the current `DS'.  This is useful for setting up interrupt
vectors and such.

Return Value
------------

`DS'


File: libc,  Node: _my_ss,  Next: nice,  Prev: _my_ds,  Up: Alphabetical List

_my_ss
======

Syntax
------

     #include <sys/segments.h>
     
     unsigned short _my_ss();

Description
-----------

Returns the current `SS'.  This is useful for setting up interrupt
vectors and such.

Return Value
------------

`SS'


File: libc,  Node: nice,  Next: normvideo,  Prev: _my_ss,  Up: Alphabetical List

nice
====

Syntax
------

     #include <unistd.h>
     
     int nice(int _increment);

Description
-----------

Adjusts the priority of the process.  Provided for Unix compatibility
only.

Return Value
------------

The new nice value.


File: libc,  Node: normvideo,  Next: nosound,  Prev: nice,  Up: Alphabetical List

normvideo
=========

Syntax
------

     #include <conio.h>
     
     void normvideo(void);

Description
-----------

Resets the text attribute to what it was before the program started.


File: libc,  Node: nosound,  Next: ntohl,  Prev: normvideo,  Up: Alphabetical List

nosound
=======

Syntax
------

     #include <pc.h>
     
     void nosound(void);

Description
-----------

Disable the PC speaker.


File: libc,  Node: ntohl,  Next: ntohs,  Prev: nosound,  Up: Alphabetical List

ntohl
=====

Syntax
------

     #include <netinet/in.h>
     
     unsigned long ntohl(unsigned long val);

Description
-----------

This function converts from network formatted longs to host formatted
longs.  For the i386 and higher processors, this means that the bytes
are swapped from 1234 order to 4321 order.

Return Value
------------

The host-order value.

Example
-------

     ip = htonl(packet.ipaddr);


File: libc,  Node: ntohs,  Next: open,  Prev: ntohl,  Up: Alphabetical List

ntohs
=====

Syntax
------

     #include <netinet/in.h>
     
     unsigned short ntohs(unsigned short val);

Description
-----------

This function converts from network formatted shorts to host formatted
shorts.  For the i386 and higher processors, this means that the bytes
are swapped from 12 order to 21 order.

Return Value
------------

The host-order value.

Example
-------

     port = htons(tcp.port);


File: libc,  Node: open,  Next: _open,  Prev: ntohs,  Up: Alphabetical List

open
====

Syntax
------

     #include <fcntl.h>
     #include <sys/stat.h> /* for mode definitions */
     
     int open(const char *file, int mode /*, int permissions */);

Description
-----------

This function opens the named FILE in the given MODE, which is any
combination of the following:

`O_RDONLY'
     The file is opened for reading.

`O_WRONLY'
     The file is opened for writing.

`O_RDWR'
     The file is opened for both reading and writing.

`O_CREAT'
     If the file does not exist, it is created. *Note creat::.

`O_TRUNC'
     If the file does exist, it is truncated to zero bytes.

`O_EXCL'
     If the file exists, and `O_CREAT' is also specified, the `open'
     call will fail.

`O_APPEND'
     The file pointer is positioned at the end of the file before each
     write.

`O_TEXT'
     The file is opened in text mode, meaning that Ctrl-M characters are
     stripped on reading and added on writing as needed.  The default
     mode is specified by the `_fmode' variable *Note _fmode::.

`O_BINARY'
     The file is opened in binary mode.

If the file is created by this call, it will be given the read/write
permissions specified by PERMISSIONS, which may be any combination of
these values:

`S_IRUSR'
     The file is readable.  This is always true for MS-DOS

`S_IWUSR'
     The file is writable.

Other `S_I*' values may be included, but they will be ignored.

Return Value
------------

If successful, the file descriptor is returned.  On error, a negative
number is returned and `errno' is set to indicate the error.

Example
-------

     int q = open("/tmp/foo.dat", O_RDONLY|O_BINARY);


File: libc,  Node: _open,  Next: opendir,  Prev: open,  Up: Alphabetical List

_open
=====

Syntax
------

     #include <io.h>
     
     int _open(const char *path, int attrib);

Description
-----------

This is a direct connection to the MS-DOS open function call, int 0x21,
%ah = 0x3d.  The file is set to binary mode.

Return Value
------------

The new file descriptor, else -1 on error.


File: libc,  Node: opendir,  Next: outb,  Prev: _open,  Up: Alphabetical List

opendir
=======

Syntax
------

     #include <dirent.h>
     
     extern int __opendir_flags;
     
     DIR *opendir(char *name);

Description
-----------

This function "opens" a directory so that you can read the list of file
names in it.  The pointer returned must be passed to `closedir' when
you are done with it.  *Note readdir::.

The global variable `__opendir_flags' can be set to include the
following values to control the operation of `opendir':

`__OPENDIR_PRESERVE_CASE'
     Do not change the case of files to lower case.  Just in case
     Micros*ft decides to support case-sensitive file systems some day.

`__OPENDIR_FIND_HIDDEN'
     Include hidden files and directories in the search.  By default,
     these are skipped.

You can simply put "int __opendir_flags = ...;" in your code.  The
default is to let it get set to zero as an uninitialized variable.

Return Value
------------

The open directory structure, or `NULL' on error.

Example
-------

     DIR *d = opendir(".");
     closedir(d);


File: libc,  Node: outb,  Next: outp,  Prev: opendir,  Up: Alphabetical List

outb
====

Syntax
------

     #include <pc.h>
     
     void outb(unsigned short _port, unsigned char _data);

Description
-----------

Calls *Note outportb::. Provided only for compatibility.


File: libc,  Node: outp,  Next: outportb,  Prev: outb,  Up: Alphabetical List

outp
====

Syntax
------

     #include <pc.h>
     
     void outp(unsigned short _port, unsigned char  _data);

Description
-----------

Calls *Note outportb::. Provided only for compatibility.


File: libc,  Node: outportb,  Next: outportl,  Prev: outp,  Up: Alphabetical List

outportb
========

Syntax
------

     #include <pc.h>
     
     void outportb(unsigned short _port, unsigned char  _data);

Description
-----------

Write a single byte to an 8-bit port.

This function is provided as an inline assembler macro, and will be
optimized down to a single opcode when you optimize your program.


File: libc,  Node: outportl,  Next: outportsb,  Prev: outportb,  Up: Alphabetical List

outportl
========

Syntax
------

     #include <pc.h>
     
     void outportl(unsigned short _port, unsigned long _data);

Description
-----------

Write a single long to an 32-bit port.

This function is provided as an inline assembler macro, and will be
optimized down to a single opcode when you optimize your program.


File: libc,  Node: outportsb,  Next: outportsl,  Prev: outportl,  Up: Alphabetical List

outportsb
=========

Syntax
------

     #include <pc.h>
     
     void outportsb(unsigned short _port, unsigned char *_buf, unsigned _len);

Description
-----------

Writes the _LEN bytes in _BUF to the 8-bit _PORT.


File: libc,  Node: outportsl,  Next: outportsw,  Prev: outportsb,  Up: Alphabetical List

outportsl
=========

Syntax
------

     #include <pc.h>
     
     void outportsl(unsigned short _port, unsigned long *_buf, unsigned _len);

Description
-----------

Writes the _LEN longs in _BUF to the 32-bit _PORT.


File: libc,  Node: outportsw,  Next: outportw,  Prev: outportsl,  Up: Alphabetical List

outportsw
=========

Syntax
------

     #include <pc.h>
     
     void outportsw(unsigned short _port, unsigned short *_buf, unsigned _len);

Description
-----------

Writes the _LEN shorts in _BUF to the 16-bit _PORT.


File: libc,  Node: outportw,  Next: outpw,  Prev: outportsw,  Up: Alphabetical List

outportw
========

Syntax
------

     #include <pc.h>
     
     void outportw(unsigned short _port, unsigned short _data);

Description
-----------

Write a single short to an 16-bit port.

This function is provided as an inline assembler macro, and will be
optimized down to a single opcode when you optimize your program.


File: libc,  Node: outpw,  Next: pathconf,  Prev: outportw,  Up: Alphabetical List

outpw
=====

Syntax
------

     #include <pc.h>
     
     void outpw(unsigned short _port, unsigned short _data);

Description
-----------

Calls *Note outportw::. Provided only for compatibility.


File: libc,  Node: pathconf,  Next: pause,  Prev: outpw,  Up: Alphabetical List

pathconf
========

Syntax
------

     #include <unistd.h>
     
     long pathconf(const char *filename, int name);

Description
-----------

This function returns various system-dependent configuration values.
The NAME is one of the following:

`_PC_LINK_MAX'
     The maximum number of directory entries that can refer to a single
     real file.

`_PC_MAX_CANON'
     The maximum number of bytes in an editable input line.

`_PC_MAX_INPUT'
     The maximum number of bytes in a non-editable input line.

`_PC_NAME_MAX'
     The maximum length of an individual file name.

`_PC_PATH_MAX'
     The maximum length of a complete path name.

`_PC_PIPE_BUF'
     The size of a pipe's internal buffer.

`_PC_CHOWN_RESTRICTED'
     If non-zero, only privileged user can chown() files, otherwise
     anyone may give away files.

`_PC_NO_TRUNC'
     If false filenames longer than `_PC_NAME_MAX' are truncated,
     otherwise an error occurs if you use longer names.

`_PC_VDISABLE'
     A character to use to disable tty special characters.

Return Value
------------

The selected configuration value is returned.

Example
-------

     char *buf = malloc(pathconf("c:/", _PC_MAX_PATH)+1);


File: libc,  Node: pause,  Next: pclose,  Prev: pathconf,  Up: Alphabetical List

pause
=====

Syntax
------

     #include <unistd.h>
     
     int pause(void);

Description
-----------

This function just calls `__dpmi_yield()' (*note __dpmi_yield::.) to
give up a slice of the CPU.

Return Value
------------

Zero.


File: libc,  Node: pclose,  Next: perror,  Prev: pause,  Up: Alphabetical List

pclose
======

Syntax
------

     #include <stdio.h>
     
     int pclose(FILE *pipe);

Description
-----------

This function closes a pipe opened with `popen' (*note popen::.).  Note
that since MS-DOS is not multitasking, this function will actually run
the program specified in `popen' if the pipe was opened for writing.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     FILE *f = popen("sort", "w");
     write_to_pipe(f);
     pclose(f);


File: libc,  Node: perror,  Next: pipe,  Prev: pclose,  Up: Alphabetical List

perror
======

Syntax
------

     #include <stdio.h>
     
     void perror(const char *string);

Description
-----------

This function formats an error message and prints it to `stderr'.  The
message is the STRING, a colon, and a message suitable for the error
condition indicated by `errno'.

Return Value
------------

None.

Example
-------

     int x = open("foo", O_RDONLY);
     if (x < 0)
     {
       perror("foo");
       exit(1);
     }


File: libc,  Node: pipe,  Next: popen,  Prev: perror,  Up: Alphabetical List

pipe
====

Description
-----------

This function is provided only to assist in porting from Unix.  It
always returns an error condition.


File: libc,  Node: popen,  Next: pow,  Prev: pipe,  Up: Alphabetical List

popen
=====

Syntax
------

     #include <stdio.h>
     
     FILE *popen(const char *program, const char *mode);

Description
-----------

This function executes the named `program' and attaches either its
input stream or its output stream to the returned file.  While the file
is open, the calling program can write to the program (if the program
was open for writing) or read the program's output (if the program was
opened for reading).  When the program is done, or if you have no more
input for it, pass the file pointer to `pclose' (*note pclose::.),
which terminates the program.

Since MS-DOS does not support multitasking, this function actually runs
the entire program when the program is opened for reading, and stores
the output in a temporary file.  `pclose' then removes that file.
Similarly, when you open a program for writing, a temp file holds the
data and `pclose' runs the entire program.

The MODE is the same as for `fopen' (*note fopen::.).

Return Value
------------

An open file which can be used to read the program's output or write to
the program's input.

Example
-------

     FILE *p = popen("dir", "r");
     read_program(p);
     pclose(p);


File: libc,  Node: pow,  Next: pow10,  Prev: popen,  Up: Alphabetical List

pow
===

Syntax
------

     #include <math.h>
     
     double pow(double x, double y);

Return Value
------------

X raised to the Y power.


File: libc,  Node: pow10,  Next: pow2,  Prev: pow,  Up: Alphabetical List

pow10
=====

Syntax
------

     #include <math.h>
     
     double pow10(double x);

Return Value
------------

10 raised to the X power.


File: libc,  Node: pow2,  Next: printf,  Prev: pow10,  Up: Alphabetical List

pow2
====

Syntax
------

     #include <math.h>
     
     double pow2(double x);

Return Value
------------

2 raised to the X power.


File: libc,  Node: printf,  Next: putc,  Prev: pow2,  Up: Alphabetical List

printf
======

Syntax
------

     #include <stdio.h>
     
     int printf(const char *format, ...);

Description
-----------

Sends formatted output from the arguments (...) to `stdout'.

The format string contains regular characters to print, as well as
conversion specifiers, which begin with a percent symbol.  Each
conversion speficier contains the following fields:

   *  an optional flag, which may alter the conversion:

    `-'
          left-justify the field.

    `+'
          Force a `+' sign on positive numbers.

    `space'
          To leave a blank space where a plus or minus sign would have
          been.

    `#'
          Alternate conversion - prefix octal numbers with `0',
          hexadecimal numbers with `0x' or `0X', or force a trailing
          decimal point if a floating point conversion would have
          omitted it.

    `0'
          To pad numbers with leading zeros.

   *  A field width specifier, which specifies the minimum width of the
     field.  This may also be an asterisk (`*'), which means that the
     actual width will be obtained from the next argument.  If the
     argument is negative, it supplies a `-' flag and a positive width.

   *  An optional decimal point and a precision.  This may also be an
     asterisk, but a negative argument for it indicates a precision of
     zero.  The precision specifies the minimum number of digits to
     print for an integer, the number of fraction digits for a floating
     point number (max for `g' or `G', actual for others), or the
     maximum number of characters for a string.

   *  An optional conversion qualifier, which may be `h' to specify
     `short', `l' to specify long ints, or `L' to specify long doubles.

   *  The conversion type specifier:

    `c'
          A single character

    `d'
          A signed integer

    `D'
          A signed long integer

    `e'
    `E'
          A floating point number (double or long double).  The
          exponent case matches the specifier case.  The representation
          always has an exponent.

    `f'
          A floating point number (double or long double).  The
          representation never has an exponent.

    `g'
    `G'
          A floating point number (double or long double).  The
          exponent case matches the specifier case.  The representation
          has an exponent if it needs one.

    `i'
          A signed integer.

    `n'
          The next argument is a pointer to an integer, and the number
          of characters generated so far is stored in that integer.

    `o'
          A unsigned integer, printed in base 8 instead of base 10.

    `p'
          A pointer.  This is printed with an `x' specifier.

    `s'
          A `NULL'-terminated string.

    `u'
          An unsigned integer.

    `U'
          An unsigned long integer.

    `x'
    `X'
          An unsigned integer, printed in base 16 instead of base 10.
          The case of the letters used matches the specifier case.

    `%'
          A single percent symbol is printed.

Return Value
------------

The number of characters written.

Example
-------

     printf("%-3d %10.2f%% Percent of %s\n", index, per[index], name[index]);


File: libc,  Node: putc,  Next: putch,  Prev: printf,  Up: Alphabetical List

putc
====

Syntax
------

     #include <stdio.h>
     
     int putc(int c, FILE *file);

Description
-----------

This function writes one character to the given FILE.

Return Value
------------

The character written.

Example
-------

     while ((c=getc(stdin)) != EOF)
       putc(c, stdout);


File: libc,  Node: putch,  Next: putchar,  Prev: putc,  Up: Alphabetical List

putch
=====

Syntax
------

     #include <conio.h>
     
     int putch(int _c);

Description
-----------

Put the character _C on the screen at the current cursor position.  The
special characters return, linefeed, bell, and backspace are handled
properly, as is line wrap and scrolling.  The cursor position is
updated.

Return Value
------------

The character is returned.


File: libc,  Node: putchar,  Next: putenv,  Prev: putch,  Up: Alphabetical List

putchar
=======

Syntax
------

     #include <stdio.h>
     
     int putchar(int c);

Description
-----------

This is the same as `fputc(c, stdout)'.  *Note fputc::.

Return Value
------------

The character written.

Example
-------

     while ((c = getchar()) != EOF)
       putchar(c);


File: libc,  Node: putenv,  Next: puts,  Prev: putchar,  Up: Alphabetical List

putenv
======

Syntax
------

     #include <stdlib.h>
     
     int putenv(const char *env);

Description
-----------

This function adds an entry to the program's environment.  The string
passed must be of the form `NAME'=`VALUE'.  Any existing value for the
environment variable is gone.

`putenv' will copy the string passed to it, and will automatically free
any existing string already in the environment.  Keep this in mind if
you alter the environment yourself.  The string you pass is still your
responsibility to free.  Note that most implementations will not let
you free the string you pass, resulting in memory leaks.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     putenv("SHELL=ksh.exe");


File: libc,  Node: puts,  Next: puttext,  Prev: putenv,  Up: Alphabetical List

puts
====

Syntax
------

     #include <stdio.h>
     
     int puts(const char *string);

Description
-----------

This function writes STRING to `stdout', and then writes a newline
character.

Return Value
------------

Nonnegative for success, or `EOF' on error.

Example
-------

     puts("Hello, there");


File: libc,  Node: puttext,  Next: putw,  Prev: puts,  Up: Alphabetical List

puttext
=======

Syntax
------

     #include <conio.h>
     
     int puttext(int _left, int _top, int _right, int _bottom, void *_source);

Description
-----------

The opposite of *Note gettext::.

Return Value
------------

1 on success, zero on error.


File: libc,  Node: putw,  Next: qsort,  Prev: puttext,  Up: Alphabetical List

putw
====

Syntax
------

     #include <stdio.h>
     
     int putw(int x, FILE *file);

Description
-----------

Writes a single binary word in native format to FILE.

Return Value
------------

The value written, or `EOF' for end-of-file or error.  Since `EOF' is a
valid integer, you should use `feof' or `ferror' to detect this
situation.

Example
-------

     putw(12, stdout);


File: libc,  Node: qsort,  Next: raise,  Prev: putw,  Up: Alphabetical List

qsort
=====

Syntax
------

     #include <stdlib.h>
     
     void qsort(void *base, size_t numelem, size_t size,
                int (*cmp)(const void *e1, const void *e2));

Description
-----------

This function sorts the given array in place.  BASE is the address of
the first of NUMELEM array entries, each of size SIZE bytes.  `qsort'
uses the supplied function CMP to determine the sort order for any two
elements by passing the address of the two elements and using the
function's return address.

The return address of the function indicates the sort order:

Negative
     Element E1 should come before element E2 in the resulting array.

Positive
     Element E1 should come after element E2 in the resulting array.

Zero
     It doesn't matter which element comes first in the resulting array.

Return Value
------------

None.

Example
-------

     typedef struct {
       int size;
       int sequence;
     } Item;
     
     int qsort_helper_by_size(void *e1, void *e2)
     {
       return ((Item *)e2)->size - ((Item *)e1)->size;
     }
     
     Item list[100];
     
     qsort(list, 100, sizeof(Item), qsort_helper_by_size);
     
     int qsort_stringlist(void *e1, void *e2)
     {
       return strcmp(*(char **)e1, *(char **)e2);
     }
     
     char *slist[10];
     
     /* alphabetical order */
     qsort(slist, 10, sizeof(char *), qsort_stringlist);


File: libc,  Node: raise,  Next: rand,  Prev: qsort,  Up: Alphabetical List

raise
=====

Syntax
------

     #include <signal.h>
     
     int	raise(int _sig);

Description
-----------

This function raises the given signal (see `<signal.h>' for a list).
*Note signal::.

Return Value
------------

0 on success.


File: libc,  Node: rand,  Next: random,  Prev: raise,  Up: Alphabetical List

rand
====

Syntax
------

     #include <stdlib.h>
     
     int rand(void);

Description
-----------

Returns a pseudo-random number from zero to `RAND_MAX'.

Return Value
------------

The number.

Example
-------

     /* random pause */
     for (i=rand(); i; i--);


File: libc,  Node: random,  Next: rawclock,  Prev: rand,  Up: Alphabetical List

random
======

Syntax
------

     #include <stdlib.h>
     
     long random(void);

Description
-----------

Returns a random number in the range 0..MAXINT.

Return Value
------------

0 .. MAXINT


File: libc,  Node: rawclock,  Next: read,  Prev: random,  Up: Alphabetical List

rawclock
========

Syntax
------

     #include <time.h>
     
     unsigned long rawclock(void);

Description
-----------

Returns the number of clock tics (18.2 per second) since midnight.

Return Value
------------

The number of tics.

Example
-------

     /* wait 1/4 second */
     int i = rawclock()+5;
     while (rawclock()<i);


File: libc,  Node: read,  Next: _read,  Prev: rawclock,  Up: Alphabetical List

read
====

Syntax
------

     #include <unistd.h>
     
     ssize_t read(int fd, void *buffer, size_t length);

Description
-----------

This function reads at most LENGTH bytes from file FD into BUFFER.
Note that in some cases, such as end-of-file conditions and text files,
it may read less than the requested number of bytes.  At end-of-file,
`read' will read exactly zero bytes.

Return Value
------------

The number of bytes read, zero meaning end-of-file, or -1 for an error.

Example
-------

     char buf[10];
     int r = read(0, buf, 10);


File: libc,  Node: _read,  Next: readdir,  Prev: read,  Up: Alphabetical List

_read
=====

Syntax
------

     #include <io.h>
     
     ssize_t _read(int fildes, void *buf, size_t nbyte);

Description
-----------

This is a direct connection to the MS-DOS read function call, int 0x21,
%ah = 0x3f.  No conversion is done on the data; it is read as raw
binary data.

Return Value
------------

The number of bytes read.


File: libc,  Node: readdir,  Next: realloc,  Prev: _read,  Up: Alphabetical List

readdir
=======

Syntax
------

     #include <dirent.h>
     
     struct dirent *readdir(DIR *dir);

Description
-----------

This function reads entries from a directory opened by `opendir' (*note
opendir::.).  It returns the information in a static buffer with this
format:

     struct dirent {
       unsigned short d_namlen;  /* The length of the name (like strlen) */
       char d_name[MAXNAMLEN+1]; /* The name */
     };

Return Value
------------

A pointer to a static buffer that is overridden with each call.

Example
-------

     DIR *d = opendir(".");
     struct dirent *de;
     while (de = readdir(d))
       puts(de->d_name);
     closedir(d);


File: libc,  Node: realloc,  Next: remove,  Prev: readdir,  Up: Alphabetical List

realloc
=======

Syntax
------

     #include <stdlib.h>
     
     void *realloc(void *ptr, size_t size);

Description
-----------

This function changes the size of the region pointed to by PTR.  If it
can, it will reuse the same memory space, but it may have to allocate a
new memory space to satisfy the request.  In either case, it will
return the pointer that you should use to refer to the (possibly new)
memory area.  The pointer passed may be `NULL', in which case this
function acts just like `malloc' (*note malloc::.).

Return Value
------------

A pointer to the memory you should now refer to.

Example
-------

     if (now+new > max)
     {
       max = now+new;
       p = realloc(p, max);
     }


File: libc,  Node: remove,  Next: remque,  Prev: realloc,  Up: Alphabetical List

remove
======

Syntax
------

     #include <stdio.h>
     
     int remove(const char *file);

Description
-----------

This function removes the named FILE from the file system.  Unless you
have an un-erase program, the file and its contents are gone for good.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     remove("/tmp/data.tmp");


File: libc,  Node: remque,  Next: rename,  Prev: remove,  Up: Alphabetical List

remque
======

Syntax
------

     #include <search.h>
     
     void putenv(struct qelem *elem);

Description
-----------

This function manipulates queues built from doubly linked lists.  Each
element in the queue must be in the form of `struct qelem' which is
defined thus:

     struct qelem {
       struct qelem *q_forw;
       struct qelem *q_back;
       char q_data[0];
     }

This function removes the entry ELEM from a queue.

Return Value
------------

None.


File: libc,  Node: rename,  Next: rewind,  Prev: remque,  Up: Alphabetical List

rename
======

Syntax
------

     #include <stdio.h>
     
     int rename(const char *oldname, const char *newname);

Description
-----------

This function renames an existing file or directory OLDNAME to NEWNAME.
If NEWNAME exists, then it is first removed.  If NEWNAME is a
directory, it must be empty (or else ERRNO will be set to `ENOTEMPTY'),
and must not include OLDNAME in its path prefix (otherwise, ERRNO will
be set to `EINVAL').  If NEWNAME exists, both OLDNAME and NEWNAME must
be of the same type (both directories or both regular files) (or else
ERRNO will be set to `ENOTDIR' or `EISDIR'), and must reside on the
same logical device (otherwise, ERRNO will be set to `EXDEV').
Wildcards are not allowed in either OLDNAME or NEWNAME.  DOS won't
allow renaming a current directory even on a non-default drive (you
will get the `EBUSY' or `EINVAL' in ERRNO).  `ENAMETOOLONG' will be
returned for pathnames which are longer than the limit imposed by DOS.
If OLDNAME doesn't exist, ERRNO will be set to `ENOENT'.  For most of
the other calamities, DOS will usually set ERRNO to `EACCES'.

If anything goes wrong during the operation of `rename()', the function
tries very hard to leave the things as ther were before it was invoked,
but it might not always succeed.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     rename("c:/mydir/some.doc", "c:/yourdir/some.sav");
     rename("c:/path1/mydir", "c:/path2");


File: libc,  Node: rewind,  Next: rewinddir,  Prev: rename,  Up: Alphabetical List

rewind
======

Syntax
------

     #include <stdio.h>
     
     void rewind(FILE *file);

Description
-----------

This function repositions the file pointer to the beginning of the file
and clears the error indicator.

Return Value
------------

None.

Example
-------

     rewind(stdin);


File: libc,  Node: rewinddir,  Next: rindex,  Prev: rewind,  Up: Alphabetical List

rewinddir
=========

Syntax
------

     #include <dirent.h>
     
     void rewinddir(DIR *dir);

Description
-----------

This function resets the position of the DIR so that the next call to
`readdir' (*note readdir::.) starts at the beginning again.

Return Value
------------

None.

Example
-------

     DIR *d = opendir(".");
     rewinddir(d);


File: libc,  Node: rindex,  Next: rmdir,  Prev: rewinddir,  Up: Alphabetical List

rindex
======

Syntax
------

     #include <strings.h>
     
     char *rindex(const char *string, int ch);

Description
-----------

Returns a pointer to the last occurrence of CH in STRING.  Note that
the `NULL' character counts, so if you pass zero as CH you'll get a
pointer to the end of the string back.

Return Value
------------

A pointer to the character, or `NULL' if it wasn't found.

Example
-------

     char *last_slash = rindex(filename, '/');


File: libc,  Node: rmdir,  Next: sbrk,  Prev: rindex,  Up: Alphabetical List

rmdir
=====

Syntax
------

     #include <unistd.h>
     
     int rmdir(const char *dirname);

Description
-----------

This function removes directory DIRNAME.  The directory must be empty.

Return Value
------------

Zero if the directory was removed, nonzero on failure.

Example
-------

     rmdir("/tmp/datadir");


File: libc,  Node: sbrk,  Next: scanf,  Prev: rmdir,  Up: Alphabetical List

sbrk
====

Syntax
------

     #include <osfcn.h>
     
     void *sbrk(int delta)

Description
-----------

This function changes the "break" of the program by adding DELTA to it.
This is the highest address that your program can access without
causing a violation.  Since the heap is the region under the break, you
can expand the heap (where `malloc' gets memory from) by increasing the
break.

This function is normally accessed only bu `malloc' (*note malloc::.).

Return Value
------------

The address of the first byte outside of the previous valid address
range, or -1 if no more memory could be accessed.  In other words, a
pointer to the chunk of heap you just allocated, if you had passed a
positive number.

Example
-------

     char *buf;
     buf = sbrk(1000); /* allocate space */


File: libc,  Node: scanf,  Next: Screen Variables,  Prev: sbrk,  Up: Alphabetical List

scanf
=====

Syntax
------

     #include <stdio.h>
     
     int scanf(const char *format, ...);

Description
-----------

This function scans formatted text from `stdin' and stores it in the
variables pointed to by the arguments.  *Note scanf::.

The format string contains regular characters which much match the input
exactly as well as a conversion specifiers, which begin with a percent
symbol.  Any whitespace in the format string matches zero or more of any
whitespace characters in the input.  Thus, a single space may match a
newline and two tabs in the input.  All conversions except `c' and `['
also skip leading whitespace automatically.  Each conversion specifier
contains the following fields:

   *  An asterisk (`*') which indicates that the input should be
     converted according to the conversion spec, but not stored
     anywhere.

   *  A width specifier, which specifies the maximum number of input
     characters to use in the conversion.

   *  An optional conversion qualifier, which may be `h' to specify
     `short', `l' to specify long ints, or `L' to specify long doubles.

   *  The conversion type specifier:

    `c'
          Copy the next character (or WIDTH characters) to the given
          buffer.

    `d'
          Convert the input to a signed integer.

    `e'
    `E'
    `f'
    `g'
    `G'
          Convert the input to a floating point number.

    `i'
          Convert the input, determining base automatically by the
          presence of `0x' or `0' prefixes.  *Note strtol::.

    `n'
          Store the number of characters scanned so far into the
          integer pointed to.

    `o'
          Convert the input to a signed integer, using base 8.

    `p'
          Convert the input to a pointer.  This is like using the `x'
          format.

    `s'
          Copy the input to the given string, skipping leading
          whitespace and copying non-whitespace characters up to the
          next whitespace.  The string stored is then `NULL'-terminated.

    `u'
          Convert the input to an unsigned integer.

    `x'
    `X'
          Convert the input to an unsigned integer, using base 16.

    `[...]'
          Like the `c' format, except only certain characters are
          copied.  The characters between the brackets determine which
          characters are allowed, and thus when the copying stops.
          These characters may be regular characters (example:
          `[abcd]') or a range of characters (example: `[a-d]').  If
          the first character is a caret (`^'), then the set specifies
          the set of characters that do not get copied (i.e.  the set
          is negated).  To specify that the set contains a
          close-bracket (`]'), list that as the first regular character.

    `%'
          This must match a percent character in the input.

Most conversions make use of `strtol' or `strtoul' to perform the
actual conversions.

Return Value
------------

The number of items successfully scanned.

Example
-------

     int x, y;
     char buf[100];
     scanf("%d %d %s", &x, &y, buf);
     
     /* read to end-of-line */
     scanf("%d %[^\n]\n", &x, buf);
     /* read letters only */
     scanf("[a-zA-Z]", buf);


File: libc,  Node: Screen Variables,  Next: ScreenClear,  Prev: scanf,  Up: Alphabetical List

Screen Variables
================

Syntax
------

     #include <go32.h>
     #include <pc.h>
     
     unsigned long ScreenPrimary;
     unsigned long ScreenSecondary;
     extern unsigned char ScreenAttrib;

Description
-----------

The first two variables (actually, they are #define'd aliases to fields
in the _GO32_INFO_BLOCK structure *note _go32_info_block::.) allow
access to the video memory of the primary and secondary screens as if
they were arrays.  To reference them, you must use
dosmemget()/dosmemput() functions (*Note dosmemget::, *Note
dosmemput::) or any one of the far pointer functions (*note _far*::.),
as the video memory is *not* mapped into your default address space.

The variable ScreenAttrib holds the current attribute which is in use by
the text screen writes.  The attribute is constructed as follows:

bits 0-3  - foreground color;

bits 4-6  - background color;

bit  7    - blink on (1) or off (0).

Example
-------

_farpokew(_dos_ds, ScreenPrimary, ( ((unsigned short) attr) << 8) +
char ));



File: libc,  Node: ScreenClear,  Next: ScreenCols,  Prev: Screen Variables,  Up: Alphabetical List

ScreenClear
===========

Syntax
------

     #include <pc.h>
     
     void  ScreenClear(void);

Description
-----------

This function clears the text screen.  It overwrites it by blanks with
the current background and foreground as specified by ScreenAttrib
(*note Screen Variables::.).

Return Value
------------

None.

Example
-------

     ScreenClear();


File: libc,  Node: ScreenCols,  Next: ScreenGetCursor,  Prev: ScreenClear,  Up: Alphabetical List

ScreenCols
==========

Syntax
------

     #include <pc.h>
     
     int ScreenCols(void);

Description
-----------

This function returns the number of columns of the screen.  It does so
by looking at the byte at the absolute address 40:4Ah in the BIOS area.
In text modes, the meaning of number of columns is obvious; in graphics
modes, this value is the number of columns of text available when using
the video BIOS functions to write text.

Return Value
------------

The number of columns.

Example
-------


     int available_columns = ScreenCols();


File: libc,  Node: ScreenGetCursor,  Next: ScreenMode,  Prev: ScreenCols,  Up: Alphabetical List

ScreenGetCursor
===============

Syntax
------

     #include <pc.h>
     
     void  ScreenGetCursor(int *row, int *column);

Description
-----------

This function retrieves the current cursor position of the default video
page by calling function 3 of the interrupt 10h, and stores it in the
variables pointed by ROW and COLUMN.

Return Value
------------

None.

Example
-------

     ScreenGetCursor(&wherex, &wherey);


File: libc,  Node: ScreenMode,  Next: ScreenPutChar,  Prev: ScreenGetCursor,  Up: Alphabetical List

ScreenMode
==========

Syntax
------

     #include <pc.h>
     
     int  ScreenMode(void);

Description
-----------

This function reports the current video mode as known to the system
BIOS.  It does so by accessing the byte at absolute address 40:49h.

Return Value
------------

The video mode.

Example
-------

     video_mode = ScreenMode();


File: libc,  Node: ScreenPutChar,  Next: ScreenPutString,  Prev: ScreenMode,  Up: Alphabetical List

ScreenPutChar
=============

Syntax
------

     #include <pc.h>
     
     void  ScreenPutChar(int ch, int attr, int col, int row);

Description
-----------

This function writes the character whose value is specified in CH with
an attribute ATTR at row given by ROW and column given by COL, which
are zero-based.  It does so by directly accessing the video memory, so
it will only work when the screen is in text mode.

Return Value
------------

None.

Example
-------

     ScreenPutChar('R', (BLUE << 4) | LIGHTMAGENTA, 75, 0);


File: libc,  Node: ScreenPutString,  Next: ScreenRetrieve,  Prev: ScreenPutChar,  Up: Alphabetical List

ScreenPutString
===============

Syntax
------

     #include <pc.h>
     
     void  ScreenPutString(const char *str, int attr, int column, int row);

Description
-----------

Beginning at screen position given by COLUMN and ROW, this function
displays the string given by STR.  Each string character gets the
attribute given by ATTR.  If COLUMN or ROW have values outside legal
range for current video mode, nothing happens.  The variables ROW and
COLUMN are zero-based (e.g., the topmost row is row 0).

Return Value
------------

None.

Example
-------

     ScreenPutString("Hello, world!", (BLUE << 4) | LIGHTBLUE, 20, 10);


File: libc,  Node: ScreenRetrieve,  Next: ScreenRows,  Prev: ScreenPutString,  Up: Alphabetical List

ScreenRetrieve
==============

Syntax
------

     #include <pc.h>
     
     void  ScreenRetrieve(void *buf);

Description
-----------

This function stores a replica of the current primary screen contents in
the buffer pointed to by BUF.  It assumes without checking that BUF has
enough storage to hold the data.  The required storage can be computed
as `ScreenRows()*ScreenCols()*2' (*Note ScreenRows::, *Note
ScreenCols::).

Return Value
------------

None.

Example
-------

     unsigned *saved_screen = (unsigned *)alloca(ScreenRows()*ScreenCols()*2;
     
     ScreenRetrieve(saved_screen);


File: libc,  Node: ScreenRows,  Next: ScreenSetCursor,  Prev: ScreenRetrieve,  Up: Alphabetical List

ScreenRows
==========

Syntax
------

     #include <pc.h>
     
     int ScreenRows(void);

Description
-----------

This function returns the number of rows of the text screen.  It does so
by looking at the byte at the absolute address 40:84h in the BIOS area.
This method works only for video adapters with their own BIOS
extensions, like EGA, VGA, SVGA etc.

Return Value
------------

The number of rows.

Example
-------


     int rows = ScreenRows();


File: libc,  Node: ScreenSetCursor,  Next: ScreenUpdate,  Prev: ScreenRows,  Up: Alphabetical List

ScreenSetCursor
===============

Syntax
------

     #include <pc.h>
     
     void  ScreenSetCursor(int  row, int  column);

Description
-----------

This function moves the cursor position on the default video page to the
point given by (zero-based) ROW and COLUMN, by calling function 2 of
interrupt 10h.

Return Value
------------

None.

Example
-------

     ScreenSetCursor(0, 0);   /* home the cursor */


File: libc,  Node: ScreenUpdate,  Next: ScreenUpdateLine,  Prev: ScreenSetCursor,  Up: Alphabetical List

ScreenUpdate
============

Syntax
------

     #include <pc.h>
     
     void  ScreenUpdate(void *buf);

Description
-----------

This function writes the contents of the buffer BUF to the primary
screen.  The buffer should contain an exact replica of the video memory,
including the characters and their attributes.

Return Value
------------

None.

Example
-------

     ScreenUpdate(saved_screen);


File: libc,  Node: ScreenUpdateLine,  Next: ScreenVisualBell,  Prev: ScreenUpdate,  Up: Alphabetical List

ScreenUpdateLine
================

Syntax
------

     #include <pc.h>
     
     void  ScreenUpdateLine(void *buf, int row);

Description
-----------

This function writes the contents of BUF to the screen line number
given in ROW (the topmost line is row 0), on the primary screen.

Return Value
------------

None.

Example
-------

     ScreenUpdateLine(line_buf, 10);


File: libc,  Node: ScreenVisualBell,  Next: searchpath,  Prev: ScreenUpdateLine,  Up: Alphabetical List

ScreenVisualBell
================

Syntax
------

     #include <pc.h>
     
     void  ScreenVisualBell(void);

Description
-----------

This function flashes the screen colors to produce the effect of "visual
bell'.  It does so by momentarily inverting the colors of every
character on the screen.

Return Value
------------

None.

Example
-------

     ScreenVisualBell();


File: libc,  Node: searchpath,  Next: seekdir,  Prev: ScreenVisualBell,  Up: Alphabetical List

searchpath
==========

Syntax
------

     #include <dir.h>
     
     char * searchpath(const char *file);

Description
-----------

Given a name of a file in FILE, searches for that file in a list of
directories, including the current working directory and those defined
in the PATH environment variable.

Return Value
------------

When successfull, the function returns a pointer to a static buffer
where the full pathname of the found file is stored.  Otherwise, it
returns NULL.

Example
-------

       printf("%s was found as %s\n", argv[1], searchpath(argv[1]));


File: libc,  Node: seekdir,  Next: select,  Prev: searchpath,  Up: Alphabetical List

seekdir
=======

Syntax
------

     #include <dirent.h>
     
     void seekdir(DIR *dir, long loc);

Description
-----------

This function sets the location pointer in DIR to the specified LOC.
Note that the value used for LOC should be either zero or a value
returned by `telldir' (*note telldir::.).  The next call to `readdir'
(*note readdir::.) will read whatever entry follows that point in the
directory.

Return Value
------------

None.

Example
-------

     int q = telldir(dir);
     do_stuff();
     seekdir(dir, q);


File: libc,  Node: select,  Next: _set_screen_lines,  Prev: seekdir,  Up: Alphabetical List

select
======

Syntax
------

     #include <time.h>
     
     int
     select(int nfds,
     	fd_set *readfds,
     	fd_set *writefds,
     	fd_set *exceptfds,
     	struct timeval *timeout)

Description
-----------

This function waits for files to be ready for input or output, or for a
timeout.  Each fd_set represents a set of bits representing file
descriptors.  The following macros shall be used to deal with these
sets:

`FD_ZERO(p)'
     Initialize the set to all zeros.

`FD_SET(n, p)'
     Set member N in set P.

`FD_CLR(n, p)'
     Clear member N in set P.

`FD_ISSET(n, p)'
     Return the value of member N in set P.

The TIMEOUT value may be a NULL pointer (no timeout), a pointer to a
zero-value structure (poll mode), or a pointer to an interval-filled
structure (timeout).

Return Value
------------

The number of files ready.  The input sets are replaced with sets that
describe which files are ready for which operations.


File: libc,  Node: _set_screen_lines,  Next: setbuf,  Prev: select,  Up: Alphabetical List

_set_screen_lines
=================

Syntax
------

     #include <conio.h>
     void _set_screen_lines(int nlines);

Description
-----------

This function sets the text screen width to 80 and its height to the
value given by NLINES, which can be one of the following: 25, 28, 35,
40, 43 or 50.  On a CGA, only 25-line screen is supported.  On an EGA,
you can use 25, 35 and 43.  VGA, PGA and MCGA support all of the
possible dimensions.  The number of columns (i.e., screen width) is 80
for all of the above resolutions, because the standard EGA/VGA has no
way of changing it.  After this function returns, calls to
`gettextinfo()' will return the actual screen dimensions as set by
`_set_screen_lines()'.  That is, you can e.g. test whether
`_set_screen_lines()' succeeded by checking the screen height returned
by `gettextinfo()' against the desired height.  This function has a
side effect of erasing the screen contents, so application programs
which use it should make their own arrangements to redisplay it.


File: libc,  Node: setbuf,  Next: setbuffer,  Prev: _set_screen_lines,  Up: Alphabetical List

setbuf
======

Syntax
------

     #include <stdio.h>
     
     void setbuf(FILE *file, char *buffer);

Description
-----------

This function modifies the buffering characteristics of FILE.  First,
if the file already has a buffer, it is freed.  If there was any
pending data in it, it is lost, so this function should only be used
immediately after a call to `fopen'.

If the BUFFER passed is `NULL', the file is set to unbuffered.  If a
non-`NULL' buffer is passed, it must be at least `BUFSIZ' bytes in
size, and the file is set to fully buffered.

*Note setbuffer::.  *Note setlinebuf::.  *Note setvbuf::.

Return Value
------------

None.

Example
-------

     setbuf(stdout, malloc(BUFSIZ));


File: libc,  Node: setbuffer,  Next: setcbrk,  Prev: setbuf,  Up: Alphabetical List

setbuffer
=========

Syntax
------

     #include <stdio.h>
     
     void setbuffer(FILE *file, char *buffer, int length);

Description
-----------

This function modifies the buffering characteristics of FILE.  First,
if the file already has a buffer, it is freed.  If there was any
pending data in it, it is lost, so this function should only be used
immediately after a call to `fopen'.

If the BUFFER passed is `NULL', the file is set to unbuffered.  If a
non-`NULL' buffer is passed, it must be at least SIZE bytes in size,
and the file is set to fully buffered.

*Note setbuf::.  *Note setlinebuf::.  *Note setvbuf::.

Return Value
------------

None.

Example
-------

     setbuffer(stdout, malloc(10000), 10000);


File: libc,  Node: setcbrk,  Next: _setcursortype,  Prev: setbuffer,  Up: Alphabetical List

setcbrk
=======

Syntax
------

     #include <dos.h>
     
     void setcbrk(int check);

Description
-----------

Set the setting of the Ctrl-Break checking flag in MS-DOS.  If CHECK is
zero, checking is not done.  If nonzero, checking is done.

Return Value
------------

None.


File: libc,  Node: _setcursortype,  Next: setdate,  Prev: setcbrk,  Up: Alphabetical List

_setcursortype
==============

Syntax
------

     #include <conio.h>
     
     void _setcursortype(int _type);

Description
-----------

Sets the cursor type.  _TYPE is one of the following:

`_NOCURSOR'
     No cursor is displayed.

`_SOLIDCURSOR'
     A solid block is displayed.

`_NORMALCURSOR'
     An underline cursor is displayed.


File: libc,  Node: setdate,  Next: setdisk,  Prev: _setcursortype,  Up: Alphabetical List

setdate
=======

Syntax
------

     #include <dos.h>
     
     void setdate(struct date *ptr);

Description
-----------

This function sets the current time.

*Note getdate::. *Note settime::.

Return Value
------------

None.

Example
-------

     struct date d;
     setdate(&d);


File: libc,  Node: setdisk,  Next: setenv,  Prev: setdate,  Up: Alphabetical List

setdisk
=======

Syntax
------

     #include <dir.h>
     
     int setdisk(int drive);

Description
-----------

This function sets the current disk (0=A).

*Note getdisk::

Return Value
------------

The total number of possible drives.

Example
-------

     printf("There are %d drives\n", setdisk(getdisk()));


File: libc,  Node: setenv,  Next: setftime,  Prev: setdisk,  Up: Alphabetical List

setenv
======

Syntax
------

     #include <stdlib.h>
     
     int setenv(const char *name, const char *value, int rewrite);

Description
-----------

This function sets the environment variable NAME to VALUE.  If REWRITE
is set, then this function will replace any existing value.  If it is
not set, it will only put the variable into the environment if that
variable isn't already defined.

Return Value
------------

Zero on success, -1 on failure.


File: libc,  Node: setftime,  Next: setgrent,  Prev: setenv,  Up: Alphabetical List

setftime
========

Syntax
------

     #include <dos.h>
     
     int setftime(int handle, struct ftime *ftimep);

Description
-----------

This function sets the modification time of a file.  Note that since
writing to a file, and closing a file opened for writing, also sets the
modification time, you should only use this function on files opened for
reading.

*Note getftime::.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     int q = open("data.txt", O_RDONLY);
     struct ftime f;
     f.ft_sec = f.ft_min = f.ft_hour = f.ft_day = f.ft_month = f.ft_year = 0;
     setftime(q, &f);
     close(q);


File: libc,  Node: setgrent,  Next: setitimer,  Prev: setftime,  Up: Alphabetical List

setgrent
========

Syntax
------

     #include <grp.h>
     
     void setgrent(void);

Description
-----------

This function should be called before any call to `getgrent',
`getgrgid', or `getgrnam', to start searching the groups' list from the
beginning.  *Note getgrent::.

Return Value
------------

None.


File: libc,  Node: setitimer,  Next: setjmp,  Prev: setgrent,  Up: Alphabetical List

setitimer
=========

Syntax
------

     #include <sys/time.h>
     
     struct itimerval {
       struct timeval it_interval;    /* timer interval */
       struct timeval it_value;       /* current value */
     };
     
     int setitimer(int which, struct itimerval *value, struct itimerval *ovalue);

Description
-----------

Each process has two interval timers, ITIMER_REAL and ITIMER_PROF, which
signal SIGALRM and SIGPROF respectively.  These are typically used to
provide alarm() and profiling capabilities.

This function changes the current value of the interval timer specified
by WHICH to the values in structure VALUE.  The previous value of the
timer is returned if OVALUE is not NULL.  When the timer expires the
appropriate signal is raised.

A timer is defined by the itimerval structure.  If it_value is non-zero
it specifies the time to the next timer expiration.  If it_interval is
non-zero it specifies the value to reload into it_value on timer
expiration.  Setting it_value to zero disables a timer.  Setting
it_interval to zero causes the timer to only happen once instead of
repeating.

Return Value
------------

Returns 0 on success, -1 on failure (and sets errno).


File: libc,  Node: setjmp,  Next: setlinebuf,  Prev: setitimer,  Up: Alphabetical List

setjmp
======

Syntax
------

     #include <setjmp.h>
     
     int setjmp(jmp_buf j);

Description
-----------

This function stores the complete CPU state into J.  This information
is complete enough that `longjmp' (*note longjmp::.) can return the
program to that state.  It is also complete enough to implement
coroutines.

Return Value
------------

This function will return zero if it is returning from it's own call.
If longjmp is used to restore the state, it will return whatever value
was passed to longjmp, except if zero is passed to longjmp it will
return one.

Example
-------

     jmp_buf j;
     if (setjmp(j))
       return;
     do_something();
     longjmp(j);


File: libc,  Node: setlinebuf,  Next: setlocale,  Prev: setjmp,  Up: Alphabetical List

setlinebuf
==========

Syntax
------

     #include <stdio.h>
     
     void setlinebuf(FILE *file);

Description
-----------

This function modifies the buffering characteristics of FILE.  First,
if the file already has a buffer, it is freed.  If there was any
pending data in it, it is lost, so this function should only be used
immediately after a call to `fopen'.

Next, a buffer is allocated and the file is set to line buffering.

*Note setbuf::.  *Note setlinebuf::.  *Note setvbuf::.

Return Value
------------

None.

Example
-------

     setlinebuf(stderr);


File: libc,  Node: setlocale,  Next: setmntent,  Prev: setlinebuf,  Up: Alphabetical List

setlocale
=========

Syntax
------

     #include <locale.h>
     
     char *setlocale(int category, const char *locale);

Description
-----------

This function sets part or all of the current locale.  The CATEGORY is
one of the following:

`LC_ALL'
     Set all parts of the locale.

`LC_COLLATE'
     Set the collating information.

`LC_CTYPE'
     Set the character type information.

`LC_MONETARY'
     Set the monetary formatting information.

`LC_NUMERIC'
     Set the numeric formatting information.

`LC_TIME'
     Set the time formatting information.

The LOCALE should be the name of the current locale.  Currently, only
the "C" and "POSIX" locales are supported.  If the LOCALE is NULL, no
action is performed.  If LOCALE is "", the locale is identified by
environment variables (currently not supported).

*Note localeconv::.

Return Value
------------

A static string naming the current locale for the given category, or
NULL if the requested locale is not supported.

Example
-------

     setlocale(LC_ALL, "C");


File: libc,  Node: setmntent,  Next: setmode,  Prev: setlocale,  Up: Alphabetical List

setmntent
=========

Syntax
------

     #include <mntent.h>
     
     FILE *setmntent(char *filename, char *type);

Description
-----------

This function returns an open FILE* pointer which can be used by
getmntent (*note getmntent::.).

Return Value
------------

The FILE* pointer is returned.  For MS-DOS, this FILE* is not a real
pointer and may only be used by `getmntent'.


File: libc,  Node: setmode,  Next: setpgid,  Prev: setmntent,  Up: Alphabetical List

setmode
=======

Syntax
------

     #include <io.h>
     
     int setmode(int file, int mode);

Description
-----------

This function sets the mode of the given FILE to MODE, which is either
`O_TEXT' or `O_BINARY'.  It will also set the file into either cooked
or raw mode accordingly, and set any `FILE*' objects that use this file
into text or binary mode.

Note that, for buffered streams (`FILE*'), you must call `fflush'
(*note fflush::.) before `setmode', or call `setmode' before writing
anything to the file, for proper operation.

Return Value
------------

When successful, the function will return the previous mode of the
given FILE.  In case of failure, -1 is returned and ERRNO is set.

Example
-------

     setmode(0, O_BINARY);


File: libc,  Node: setpgid,  Next: setpwent,  Prev: setmode,  Up: Alphabetical List

setpgid
=======

Syntax
------

     #include <unistd.h>
     
     int setpgid(pid_t _pid, pid_t _pgid);

Return Value
------------

-1 (EPERM) if _pgid is not your current pid, else zero.


File: libc,  Node: setpwent,  Next: settime,  Prev: setpgid,  Up: Alphabetical List

setpwent
========

Syntax
------

     #include <pwd.h>
     
     void setpwent(void);

Description
-----------

This function reinitializes `getpwent' so that scanning will start from
the start of the list.  *Note getpwent::.

Return Value
------------

None.


File: libc,  Node: settime,  Next: settimeofday,  Prev: setpwent,  Up: Alphabetical List

settime
=======

Syntax
------

     #include <dos.h>
     
     void settime(struct time *ptr);

Description
-----------

This function sets the current time.

*Note gettime::. *Note setdate::.

Return Value
------------

None.

Example
-------

     struct time t;
     settime(&t);


File: libc,  Node: settimeofday,  Next: setvbuf,  Prev: settime,  Up: Alphabetical List

settimeofday
============

Syntax
------

     #include <time.h>
     
     int settimeofday(struct timeval *tp, ...);

Description
-----------

Sets the current GMT time.  For compatibility, a second argument is
accepted.  *Note gettimeofday:: for information on the structure types.

Return Value
------------

Zero if the time was set, nonzero on error.


File: libc,  Node: setvbuf,  Next: siglongjmp,  Prev: settimeofday,  Up: Alphabetical List

setvbuf
=======

Syntax
------

     #include <stdio.h>
     
     int setvbuf(FILE *file, char *buffer, int type, int length);

Description
-----------

This function modifies the buffering characteristics of FILE.  First,
if the file already has a buffer, it is freed.  If there was any
pending data in it, it is lost, so this function should only be used
immediately after a call to `fopen'.

If the TYPE is `_IONBF', the BUFFER and LENGTH are ignored and the file
is set to unbuffered mode.

If the TYPE is `_IOLBF' or `_IOFBF', then the file is set to line or
fully buffered, respectively.  If BUFFER is `NULL', a buffer of size
SIZE is created and used as the buffer.  If BUFFER is non-`NULL', it
must point to a buffer of at least size SIZE and will be used as the
buffer.

*Note setbuf::.  *Note setbuffer::.  *Note setlinebuf::.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     setbuf(stderr, NULL, _IOLBF, 1000);


File: libc,  Node: siglongjmp,  Next: signal,  Prev: setvbuf,  Up: Alphabetical List

siglongjmp
==========

Syntax
------

     #include <setjmp.h>
     
     int	siglongjmp(sigjmp_buf env, int val);

Description
-----------

*Note longjmp::.


File: libc,  Node: signal,  Next: sigsetjmp,  Prev: siglongjmp,  Up: Alphabetical List

signal
======

Syntax
------

     #include <signal.h>
     
     void	(*signal(int _sig, void (*_func)(int)))(int);

Description
-----------

This function registers signal handlers.  Signal numbers are 0..255 for
software interrupts, 256..287 for exceptions (exception number plus
256) or as specified in `<signal.h>'.

You may pass SIG_DFL to reset the default handling, SIG_ERR to force an
error when that signal happens, or SIG_IGN to ignore that signal.
Signal handlers are regular C functions, and may call any function that
the ANSI/POSIX specs say are valid for signal handlers.  Signal
handlers for hardware interrupts need special handling.

Return Value
------------

The previous handler.


File: libc,  Node: sigsetjmp,  Next: sin,  Prev: signal,  Up: Alphabetical List

sigsetjmp
=========

Syntax
------

     #include <setjmp.h>
     
     int	sigsetjmp(sigjmp_buf env, int savemask);

Description
-----------

*Note setjmp::.


File: libc,  Node: sin,  Next: sinh,  Prev: sigsetjmp,  Up: Alphabetical List

sin
===

Syntax
------

     #include <math.h>
     
     double sin(double x);

Return Value
------------

The sine of X.


File: libc,  Node: sinh,  Next: sleep,  Prev: sin,  Up: Alphabetical List

sinh
====

Syntax
------

     #include <math.h>
     
     double sinh(double x);

Return Value
------------

The hyperbolic sine of X.


File: libc,  Node: sleep,  Next: sound,  Prev: sinh,  Up: Alphabetical List

sleep
=====

Syntax
------

     #include <unistd.h>
     
     unsigned sleep(unsigned seconds);

Description
-----------

This function causes the program to pause for SECONDS seconds.

Return Value
------------

The number of seconds that haven't passed (i.e. always zero)

Example
-------

     sleep(5);


File: libc,  Node: sound,  Next: spawn*,  Prev: sleep,  Up: Alphabetical List

sound
=====

Syntax
------

     #include <pc.h>
     
     void		sound(int _frequency);

Description
-----------

Enables the PC speaker at the given frequency.


File: libc,  Node: spawn*,  Next: sprintf,  Prev: sound,  Up: Alphabetical List

spawn*
======

Syntax
------

     #include <process.h>
     
     int spawnl(int mode, const char *path, const char *argv0, ...);
     int spawnle(int mode, const char *path, const char *argv0, ... /*, const char **envp */);
     int spawnlp(int mode, const char *path, const char *argv0, ...);
     int spawnlpe(int mode, const char *path, const char *argv0, ... /*, const char **envp */);
     
     int spawnv(int mode, const char *path, const char **argv);
     int spawnve(int mode, const char *path, const char **argv, const char **envp);
     int spawnvp(int mode, const char *path, const char **argv);
     int spawnvpe(int mode, const char *path, const char **argv, const char **envp);

Description
-----------

These functions run other programs.  The PATH points to the program to
run.  The extension is optional - if not given, the usual extensions
`.com', `.exe', and `.bat' are checked.

The programs are invoked with the arguments given.  The zeroth argument
is normally not used, since MS-DOS cannot pass it separately.  There are
two ways of passing arguments.  The `l' functions (like `spawnl') take
a list of arguments, with a zero at the end of the list.  This is
useful when you know how many argument there will be ahead of time.
The `v' functions (like `spawnv') take a pointer to a list of
arguments.  This is useful when you need to compute the number of
arguments at runtime.

In either case, you may also specify `e' to indicate that you will be
giving an explicit environment, else the current environment is used.
You may also specify `p' to indicate that you would like `spawn*' to
search the PATH (in either the environment you pass or the current
environment) for the executable, else it will only check the explicit
path given.

Note that these function understand about other djgpp programs, and will
call them directly, so that you can pass command lines longer than 128
characters to them without any special code.

*Note exec*::.

Return Value
------------

If successful and `mode' is `P_WAIT', these functions return the exit
code of the child process.  Note that if the program is run by a
command processor (e.g., if it's a batch file), the exit code of that
command processor will be returned.  `COMMAND.COM' is notorious for
returning 0 even if it couldn't run the command.

If successful and MODE is `P_OVERLAY', these functions will not return.

If there is an error, these functions return -1 and set `errno' to
indicate the error.

Example
-------


     char *environ[] = {
       "PATH=c:\\dos;c:\\djgpp;c:\\usr\\local\\bin",
       "DJGPP=c:/djgpp",
       0
     };
     
     char *args[] = {
       "gcc",
       "-v",
       "hello.c",
       0
     };
     
     spawnvpe("gcc", args, environ);


File: libc,  Node: sprintf,  Next: sqrt,  Prev: spawn*,  Up: Alphabetical List

sprintf
=======

Syntax
------

     #include <stdio.h>
     
     int sprintf(char *buffer, const char *format, ...);

Description
-----------

Sends formatted output from the arguments (...) to the BUFFER.  *Note
printf::.

Return Value
------------

The number of characters written.


File: libc,  Node: sqrt,  Next: srandom,  Prev: sprintf,  Up: Alphabetical List

sqrt
====

Syntax
------

     #include <math.h>
     
     double sqrt(double x);

Return Value
------------

The square root of X.


File: libc,  Node: srandom,  Next: sscanf,  Prev: sqrt,  Up: Alphabetical List

srandom
=======

Syntax
------

     #include <stdlib.h>
     
     int srandom(int seed);

Description
-----------

This function initialized the random number generator (*note random::.).
Passing the same SEED results in `random' returning predictable
sequences of numbers.

Return Value
------------

Zero.

Example
-------

     srandom(45);


File: libc,  Node: sscanf,  Next: stat,  Prev: srandom,  Up: Alphabetical List

sscanf
======

Syntax
------

     #include <stdio.h>
     
     int sscanf(const char *string, const char *format, ...);

Description
-----------

This function scans formatted text from the STRING and stores it in the
variables pointed to by the arguments.  *Note scanf::.

Return Value
------------

The number of items successfully scanned.


File: libc,  Node: stat,  Next: statfs,  Prev: sscanf,  Up: Alphabetical List

stat
====

Syntax
------

     #include <sys/stat.h>
     
     int stat(const char *file, struct stat *sbuf);

Description
-----------

This function obtains the status of the file FILE and stores it in
SBUF, which has this structure:

     struct  stat {
             time_t   st_atime;     /* time of last modification */
             time_t   st_ctime;     /*            ''             */
             dev_t    st_dev;       /* The drive number (0 = a:) */
             gid_t    st_gid;       /* getgid() */
             ino_t    st_ino;       /* starting cluster or a unique identifier */
             mode_t   st_mode;      /* file mode - S_IF* and S_IRUSR/S_IWUSR */
             time_t   st_mtime;     /*            ''             */
             nlink_t  st_nlink;     /* 1 */
             off_t    st_size;      /* size of file in bytes */
             off_t    st_blksize;   /* the size of transfer buffer */
             uid_t    st_uid;       /* getuid() */
     };

Return Value
------------

Zero on success, nonzero on failure (and ERRNO set).

Example
-------

     struct stat s;
     stat("data.txt", &s);
     if (S_ISDIR(s.st_mode))
       printf("is directory\n");

Implementation Notes
--------------------

Supplying a 100% Unix-compatible `f?stat()' functions under DOS is an
implementation nightmare.  The following notes describe some of the
obscure points specific to their behavior in DJGPP.

1. The `drive' for character devices (like `con', `/dev/nul' and others
is returned as -1.  For drives networked by Novell Netware, it is
returned as -2.

2. The starting cluster number of a file serves as its inode number.
For files whose starting cluster number is inaccessible (empty files,
files on networked drives, etc.) the `st_inode' field will be `invented'
in a way which guarantees that no two different files will get the same
inode number (thus it is unique).  This invented inode will also be
different from any real cluster number of any local file.  However, only
for local, non-empty files/directories the inode is guaranteed to be
consistent between `stat()' and `fstat()' function calls.

3. The WRITE access mode bit is set only for the user (unless the file
is read-only, hidden or system).  EXECUTE bit is set for directories,
files which can be executed from the DOS prompt (batch files, .com,
.dll and .exe executables) or run by go32 extender.

4. Size of directories is reported as the number of its files (sans `.'
and `..' entries) multiplied by 32 bytes (the size of directory entry).

5. Time stamp for root directories is taken from the volume label entry,
if that's available; otherwise, it is reported as 1-Jan-1980.

6. The variable *Note _djstat_flags:: controls what hard-to-get fields
of `struct stat' are needed by the application.

7. `stat()' should not be used to get an up-to-date info about a file
which is open and has been written to, because `stat()' will only
return correct data after the file is closed.  Use *Note fstat:: while
the file is open.


File: libc,  Node: statfs,  Next: _status87,  Prev: stat,  Up: Alphabetical List

statfs
======

Syntax
------

     #include <sys/vfs.h>
     
     int statfs(const char *filename, struct statfs *buf);

Description
-----------

This function returns information about the given "filesystem".  The
drive letter of the given FILENAME, or the default drive if none is
given, is used to retrieve the following structure:

     struct statfs
     {
         long	f_type;   /* 0 */
         long	f_bsize;  /* bytes per cluster */
         long	f_blocks; /* clusters on drive */
         long	f_bfree;  /* available clusters */
         long	f_bavail; /* available clusters */
         long	f_files;  /* clusters on drive */
         long	f_ffree;  /* available clusters */
         fsid_t	f_fsid;   /* [0]=drive_number, [1]=MOUNT_UFS
         long	f_magic;  /* FS_MAGIC */
     };

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     struct statfs fs;
     statfs("anything", &fs);
     printf("%d bytes left\n", fs.f_bfree * fs.f_bsize);


File: libc,  Node: _status87,  Next: _stklen,  Prev: statfs,  Up: Alphabetical List

_status87
=========

Syntax
------

     #include <float.h>
     
     unsigned int _status87(void);

Description
-----------

Returns the status word of the FPU, which indicate the results of the
most recently completed FPU operation:

     ---- ---- ---- ---X = SW_INVALID - invalid operation
     ---- ---- ---- --X- = SW_DENORMAL - denormalized operand
     ---- ---- ---- -X-- = SW_ZERODIVIDE - division by zero
     ---- ---- ---- X--- = SW_OVERFLOW - overflow
     ---- ---- ---X ---- = SW_UNDERFLOW - underflow
     ---- ---- --X- ---- = SW_INEXACT - loss of precision
     ---- ---- -X-- ---- = SW_STACKFAULT - stack over/under flow
     ---- ---- X--- ---- = SW_ERRORSUMMARY - set if any errors
     -X-- -XXX ---- ---- = SW_COND - condition code
     ---- ---X ---- ---- = SW_C0
     ---- --X- ---- ---- = SW_C1
     ---- -X-- ---- ---- = SW_C2
     -X-- ---- ---- ---- = SW_C3
     --XX X--- ---- ---- = SW_TOP - top of stack (use SW_TOP_SHIFT to shift it)
     X--- ---- ---- ---- = SW_BUSY - fpu is busy


File: libc,  Node: _stklen,  Next: stpcpy,  Prev: _status87,  Up: Alphabetical List

_stklen
=======

Syntax
------

     extern int _stklen;

Description
-----------

This variable sets the minimum stack length that the program requires.
Note that the stack may be much larger than this.  This value should be
set statically, as it is only used at startup.

Example
-------

     extern int _stklen = 256000;


File: libc,  Node: stpcpy,  Next: strcase,  Prev: _stklen,  Up: Alphabetical List

stpcpy
======

Syntax
------

     #include <string.h>
     
     char *stpcpy(char *_dest, const char *_src);

Description
-----------

Like `strcpy' (*note strcpy::.), but return value different.

Return Value
------------

Returns a pointer to the trailing NUL in DEST.


File: libc,  Node: strcase,  Next: strcasecmp,  Prev: stpcpy,  Up: Alphabetical List

strcase
=======

Syntax
------

     #include <string.h>
     
     int strcase(const char *s1, const char *s2);

Description
-----------

This function compares the two strings, disregarding case.

Return Value
------------

Zero if they're the same, nonzero if different, the sign indicates
"order".

Example
-------

     if (strcase(arg, "-i") == 0)
       do_include();


File: libc,  Node: strcasecmp,  Next: strcat,  Prev: strcase,  Up: Alphabetical List

strcasecmp
==========

Syntax
------

     #include <string.h>
     
     int strcasecmp(const char *s1, const char *s2);

Description
-----------

This function compares the two strings, disregarding case.

Return Value
------------

Zero if they're the same, nonzero if different, the sign indicates
"order".

Example
-------

     if (strcasecmp(arg, "-i") == 0)
       do_include();


File: libc,  Node: strcat,  Next: strchr,  Prev: strcasecmp,  Up: Alphabetical List

strcat
======

Syntax
------

     #include <string.h>
     
     char *strcat(char *s1, const char *s2);

Description
-----------

This function concatenates S2 to the end of S1.

Return Value
------------

S1

Example
-------

     char buf[100] = "hello";
     strcat(buf, " there");


File: libc,  Node: strchr,  Next: strcmp,  Prev: strcat,  Up: Alphabetical List

strchr
======

Syntax
------

     #include <string.h>
     
     char *strchr(const char *s, int c);

Description
-----------

This function returns a pointer to the first occurrence of C in S.
Note that if C is `NULL', this will return a pointer to the end of the
string.

Return Value
------------

A pointer to the character, or `NULL' if it wasn't found.

Example
-------

     char *slash = strchr(filename, '/');


File: libc,  Node: strcmp,  Next: strcoll,  Prev: strchr,  Up: Alphabetical List

strcmp
======

Syntax
------

     #include <string.h>
     
     int strcmp(const char *s1, const char *s2);

Description
-----------

This function compares S1 and S2.

Return Value
------------

Zero if the strings are equal, a positive number if S1 comes after S2
in the ASCII collating sequense, else a negative number.

Example
-------

     if (strcmp(arg, "-i") == 0)
       do_include();


File: libc,  Node: strcoll,  Next: strcpy,  Prev: strcmp,  Up: Alphabetical List

strcoll
=======

Syntax
------

     #include <string.h>
     
     int strcoll(const char *s1, const char *s2);

Description
-----------

This function compares S1 and S2, using the collating sequences from
the current locale.

Return Value
------------

Zero if the strings are equal, a positive number if S1 comes after S2
in the collating sequense, else a negative number.

Example
-------

     while (strcoll(var, list[i]) < 0)
       i++;


File: libc,  Node: strcpy,  Next: strcspn,  Prev: strcoll,  Up: Alphabetical List

strcpy
======

Syntax
------

     #include <string.h>
     
     char *strcpy(char *s1, const char *s2);

Description
-----------

This function copies S2 into S1.

Return Value
------------

S1

Example
-------

     char buf[100];
     strcpy(buf, arg);


File: libc,  Node: strcspn,  Next: strdup,  Prev: strcpy,  Up: Alphabetical List

strcspn
=======

Syntax
------

     #include <string.h>
     
     size_t strcspn(const char *s1, const char *set);

Description
-----------

This function finds the first character in S1 that matches any
character in SET.  Note that the `NULL' bytes at the end of each string
counts, so you'll at least get a pointer to the end of the string if
nothing else.

Return Value
------------

The index of the found character.

Example
-------

     int i = strcspn(command, "<>|");
     if (command[i])
       do_redirection();


File: libc,  Node: strdup,  Next: strerror,  Prev: strcspn,  Up: Alphabetical List

strdup
======

Syntax
------

     #include <string.h>
     
     char * strdup (const char *source);

Description
-----------

Returns a newly allocated area of memory that contains a duplicate of
the string pointed to by SOURCE.  The memory returned by this call must
be freed by the caller.

Return Value
------------

Returns the newly allocated string, or NULL if there is no more memory.

Example
-------

     char *foo()
     {
       return strdup("hello");
     }


File: libc,  Node: strerror,  Next: strftime,  Prev: strdup,  Up: Alphabetical List

strerror
========

Syntax
------

     #include <string.h>
     
     char *strerror(int error);

Description
-----------

This function returns a string that describes the ERROR.

Return Value
------------

A pointer to a static string that should not be modified or free'd.

Example
-------

     if (f=fopen("foo", "r") == 0)
       printf("Error! %s: %s\n", "foo", strerror(errno));


File: libc,  Node: strftime,  Next: stricmp,  Prev: strerror,  Up: Alphabetical List

strftime
========

Syntax
------

     #include <time.h>
     
     size_t strftime(char *buf, size_t n, const char *format, const struct tm *time);

Description
-----------

This function formats the given TIME according to the given FORMAT and
stores it in BUF, not exceeding N bytes.

The format string is like `printf' in that any character other than `%'
is added to the output string, and for each character following a `%' a
pattern is added to the string as follows, with the examples as if the
time was Friday, October 1, 1993, at 03:30:34 PM EDT:

`%A'
     The full weekday name (`Friday')

`%a'
     The abbreviated weekday name (`Fri')

`%B'
     The full month name (`October')

`%b'
`%h'
     The abbreviated month name (`Oct')

`%C'
     Short for `%a %b %e %H:%M:%S %Y' (`Fri Oct  1 15:30:34 1993')

`%c'
     Short for `%m/%d/%y %H:%M:%S' (`10/01/93 15:30:34')

`%e'
     The day of the month, blank padded to two characters (` 2')

`%D'
     Short for `%m/%d/%y' (`10/01/93')

`%d'
     The day of the month, zero padded to two characters (`02')

`%H'
     The hour (0-24), zero padded to two characters (`15')

`%I'
     The hour (1-12), zero padded to two characters (`03')

`%j'
     The Julian day, zero padded to three characters (`275')

`%k'
     The hour (0-24), space padded to two characters (`15')

`%l'
     The hour (1-12), space padded to two characters(` 3')

`%M'
     The minutes, zero padded to two characters (`30')

`%m'
     The month (1-12), zero padded to two characters (`10')

`%n'
     A newline (`\n')

`%p'
     AM or PM (`PM')

`%R'
     Short for `%H:%M' (`15:30')

`%r'
     Short for `%I:%M:%S %p' (`03:30:35 PM')

`%S'
     The seconds, zero padded to two characters (`35')

`%T'
`%X'
     Short for `%H:%M:%S' (`15:30:35')

`%t'
     A tab (`\t')

`%U'
     The week of the year, with the first week defined by the first
     Sunday of the year, zero padded to two characters (`39')

`%W'
     The week of the year, with the first week defined by the first
     Monday of the year, zero padded to two characters (`39')

`%w'
     The day of the week (0-6) (`5')

`%x'
     Short for `%m/%d/%y' (`10/01/93')

`%y'
     The year (00-99) of the century (`93')

`%Y'
     The year, zero padded to four digits (`1993')

`%Z'
     The timezone abbreviation (`EDT')

`%%'
     A percent symbol (`%')

Return Value
------------

The number of characters stored.

Example
-------

     struct tm t;
     char buf[100];
     strftime(buf, 100, "%B %d, %Y", &t);


File: libc,  Node: stricmp,  Next: strlen,  Prev: strftime,  Up: Alphabetical List

stricmp
=======

Syntax
------

     #include <string.h>
     
     int stricmp(const char *s1, const char *s2);

Description
-----------

This function compares the two strings, disregarding case.

Return Value
------------

Zero if they're the same, nonzero if different, the sign indicates
"order".

Example
-------

     if (stricmp(arg, "-i") == 0)
       do_include();


File: libc,  Node: strlen,  Next: strlwr,  Prev: stricmp,  Up: Alphabetical List

strlen
======

Syntax
------

     #include <string.h>
     
     size_t strlen(const char *string);

Description
-----------

This function returns the number of characters in STRING.

Return Value
------------

The length of the string.

Example
-------

     if (strlen(fname) > PATH_MAX)
       invalid_file(fname);


File: libc,  Node: strlwr,  Next: strncase,  Prev: strlen,  Up: Alphabetical List

strlwr
======

Syntax
------

     #include <string.h>
     
     char *strlwr(char *string);

Description
-----------

This function replaces all upper case letters in STRING with lower case
letters.

Return Value
------------

The string.

Example
-------

     char buf[100] = "Hello";
     strlwr(buf);


File: libc,  Node: strncase,  Next: strncasecmp,  Prev: strlwr,  Up: Alphabetical List

strncase
========

Syntax
------

     #include <string.h>
     
     int strncase(const char *s1, const char *s2, size_t max);

Description
-----------

This function compares S1 and S2, ignoring case, up to a maximum of MAX
characters.

Return Value
------------

Zero if the strings are equal, a positive number if S1 comes after S2
in the ASCII collating sequense, else a negative number.

Example
-------

     if (strncase(foo, "-i", 2) == 0)
       do_include();


File: libc,  Node: strncasecmp,  Next: strncat,  Prev: strncase,  Up: Alphabetical List

strncasecmp
===========

Syntax
------

     #include <string.h>
     
     int strncasecmp(const char *s1, const char *s2, size_t max);

Description
-----------

This function compares S1 and S2, ignoring case, up to a maximum of MAX
characters.

Return Value
------------

Zero if the strings are equal, a positive number if S1 comes after S2
in the ASCII collating sequense, else a negative number.

Example
-------

     if (strncasecmp(foo, "-i", 2) == 0)
       do_include();


File: libc,  Node: strncat,  Next: strncmp,  Prev: strncasecmp,  Up: Alphabetical List

strncat
=======

Syntax
------

     #include <string.h>
     
     char *strncat(char *s1, const char *s2, size_t max);

Description
-----------

This function concatenates up to MAX characters of S2 to the end of S1.

Return Value
------------

S1

Example
-------

     strncat(fname, extension, 4);


File: libc,  Node: strncmp,  Next: strncpy,  Prev: strncat,  Up: Alphabetical List

strncmp
=======

Syntax
------

     #include <string.h>
     
     int strncmp(const char *s1, const char *s2, size_t max);

Description
-----------

This function compares upto MAX characters of S1 and S2.

Return Value
------------

Zero if the strings are equal, a positive number if S1 comes after S2
in the ASCII collating sequense, else a negative number.

Example
-------

     if (strncmp(arg, "-i", 2) == 0)
       do_include();


File: libc,  Node: strncpy,  Next: strnicmp,  Prev: strncmp,  Up: Alphabetical List

strncpy
=======

Syntax
------

     #include <string.h>
     
     char *strncpy(char *s1, const char *s2, size_t max);

Description
-----------

This function copies up to MAX characters of S2 into S1.

Return Value
------------

S1

Example
-------

     char buf[100];
     strcpy(buf, arg, 99);


File: libc,  Node: strnicmp,  Next: strpbrk,  Prev: strncpy,  Up: Alphabetical List

strnicmp
========

Syntax
------

     #include <string.h>
     
     int strnicmp(const char *s1, const char *s2, size_t max);

Description
-----------

This function compares S1 and S2, ignoring case, up to a maximum of MAX
characters.

Return Value
------------

Zero if the strings are equal, a positive number if S1 comes after S2
in the ASCII collating sequense, else a negative number.

Example
-------

     if (strnicmp(foo, "-i", 2) == 0)
       do_include();


File: libc,  Node: strpbrk,  Next: strrchr,  Prev: strnicmp,  Up: Alphabetical List

strpbrk
=======

Syntax
------

     #include <string.h>
     
     char *strpbrk(const char *s1, const char *set);

Description
-----------

This function finds the first character in S1 that matches any
character in SET.

Return Value
------------

A pointer to the first match, or `NULL' if none are found.

Example
-------

     if (strpbrk(command, "<>|"))
       do_redirection();


File: libc,  Node: strrchr,  Next: strsep,  Prev: strpbrk,  Up: Alphabetical List

strrchr
=======

Syntax
------

     #include <string.h>
     
     char *strrchr(const char *s1, int c);

Description
-----------

This function finds the last occurrence of `c' in `s1'.

Return Value
------------

A pointer to the last match, or `NULL' if the character isn't in the
string.

Example
-------

     char *last_slash = strrchr(filename, '/');


File: libc,  Node: strsep,  Next: strspn,  Prev: strrchr,  Up: Alphabetical List

strsep
======

Syntax
------

     #include <string.h>
     
     char *strsep(char **stringp, char *delim);

Description
-----------

This function retrieves the next token from the given string, where
STRINGP points to a variable holding, initially, the start of the
string.  Tokens are delimited by a character from DELIM.  Each time the
function is called, it returns a pointer to the next token, and sets
*STRINGP to the next spot to check, or `NULL'.

Return Value
------------

The next token, or NULL.

Example
-------

     main()
     {
       char *buf = "Hello  there,stranger";
       char **bp = &buf;
       char *tok;
       while (tok = strsep(bp, " ,"))
         printf("tok = `%s'\n", tok);
     }
     
     tok = `Hello'
     tok = `'
     tok = `there'
     tok = `stranger'


File: libc,  Node: strspn,  Next: strstr,  Prev: strsep,  Up: Alphabetical List

strspn
======

Syntax
------

     #include <string.h>
     
     size_t strspn(const char *s1, const char *set);

Description
-----------

This function finds the first character in S1 that does not match any
character in SET.  Note that the `NULL' bytes at the end of S1 counts,
so you'll at least get a pointer to the end of the string if nothing
else.

Return Value
------------

The index of the found character.

Example
-------

     int i = strcspn(entry, " \t\b");
     if (entry[i])
       do_something();


File: libc,  Node: strstr,  Next: strtod,  Prev: strspn,  Up: Alphabetical List

strstr
======

Syntax
------

     #include <string.h>
     
     char *strstr(const char *s1, const char *s2);

Description
-----------

This function finds the first occurrence of S2 in S1.

Return Value
------------

A pointer within S1, or `NULL' if S2 wasn't found.

Example
-------

     if (strstr(command, ".exe"))
       do_exe();


File: libc,  Node: strtod,  Next: strtok,  Prev: strstr,  Up: Alphabetical List

strtod
======

Syntax
------

     #include <stdlib.h>
     
     double strtod(const char *s, char **endp);

Description
-----------

This function converts as many characters of S that look like a
floating point number into one, and sets *ENDP to point to the first
unused character.

Return Value
------------

The value the string represented.

Example
-------

     char *buf = "123ret";
     char *bp;
     double x = strtod(buf, &bp);


File: libc,  Node: strtok,  Next: strtol,  Prev: strtod,  Up: Alphabetical List

strtok
======

Syntax
------

     #include <string.h>
     
     char *strtok(char *s1, const char *s2);

Description
-----------

This function retrieves tokens from S1 which are delimited by
characters from S2.

To initiate the search, pass the string to be searched as S1.  For the
remaining tokens, pass `NULL' instead.

Return Value
------------

A pointer to the token, or `NULL' if no more are found.

Example
-------

     main()
     {
       char *buf = "Hello there, stranger";
       char *tok;
       for (tok = strtok(buf, " ,");
            tok;
            tok=strtok(0, " ,"))
         printf("tok = `%s'\n", tok);
     }
     
     tok = `Hello'
     tok = `there'
     tok = `stranger'


File: libc,  Node: strtol,  Next: _strtold,  Prev: strtok,  Up: Alphabetical List

strtol
======

Syntax
------

     #include <stdlib.h>
     
     long strtol(const char *s, char **endp, int base);

Description
-----------

This function converts as much of S as looks like an appropriate number
into the value of that number, and sets *ENDP to point to the first
unused character.

The BASE argument indicates what base the digits (or letters) should be
treated as.  If BASE is zero, the base is determined by looking for
`0x', `0X', or `0' as the first part of the string, and sets the base
used to 16, 16, or 8 if it finds one.  The default base is 10 if none
of those prefixes are found.

Return Value
------------

The value.

Example
-------

     printf("Enter a number: "); fflush(stdout);
     gets(buf);
     char *bp;
     printf("The value is %d\n", strtol(buf, &bp, 0));


File: libc,  Node: _strtold,  Next: strtoul,  Prev: strtol,  Up: Alphabetical List

_strtold
========

Syntax
------

     #include <stdlib.h>
     
     long double _strtold(const char *s, char **endp);

Description
-----------

This function converts as many characters of S that look like a
floating point number into one, and sets *ENDP to point to the first
unused character.

Return Value
------------

The value the string represented.

Example
-------

     char *buf = "123ret";
     char *bp;
     long double x = _strtold(buf, &bp);


File: libc,  Node: strtoul,  Next: strupr,  Prev: _strtold,  Up: Alphabetical List

strtoul
=======

Syntax
------

     #include <stdlib.h>
     
     unsigned long strtoul(const char *s, char **endp, int base);

Description
-----------

This is just like `strtol' (*note strtol::.) except that the result is
unsigned.

Return Value
------------

The value.

Example
-------

     printf("Enter a number: "); fflush(stdout);
     gets(buf);
     char *bp;
     printf("The value is %u\n", strtoul(buf, &bp, 0));


File: libc,  Node: strupr,  Next: strxfrm,  Prev: strtoul,  Up: Alphabetical List

strupr
======

Syntax
------

     #include <string.h>
     
     char *strupr(char *string);

Description
-----------

This function converts all lower case characters in STRING to upper
case.

Return Value
------------

STRING

Example
-------

     char buf[] = "Foo!";
     strupr(buf);


File: libc,  Node: strxfrm,  Next: swab,  Prev: strupr,  Up: Alphabetical List

strxfrm
=======

Syntax
------

     #include <string.h>
     
     size_t strxfrm(char *s1, const char *s2, size_t max);

Description
-----------

This copies characters from S2 to S1, which must be able to hold MAX
characters.  Each character is transformed according to the locale such
that `strcmp(s1b, s2b)' is just like `strcoll(s1, s2)' where `s1b' and
`s2b' are the transforms of `s1' and `s2'.

Return Value
------------

The actual number of bytes required to transform S2, including the
`NULL'.


File: libc,  Node: swab,  Next: sync,  Prev: strxfrm,  Up: Alphabetical List

swab
====

Syntax
------

     #include <stdlib.h>
     
     void swab(const void *from, void *to, int nbytes);

Description
-----------

This function copies NBYTES bytes from the address pointed to by FROM
to the address pointed by TO, exchanging adjacent even and odd bytes.
It is useful for carrying binary data between little-endian and
big-endian machines.  The argument NBYTES should be even, and the
buffers FROM and TO should not overlap.

Return Value
------------

None.


File: libc,  Node: sync,  Next: sys_errlist,  Prev: swab,  Up: Alphabetical List

sync
====

Description
-----------

This function is provided only to assist in porting from Unix.  It
always returns zero.


File: libc,  Node: sys_errlist,  Next: sys_nerr,  Prev: sync,  Up: Alphabetical List

sys_errlist
===========

Syntax
------

     #include <errno.h>
     
     extern char *sys_errlist[];

Description
-----------

This array contains error messages, indexed by `errno', that describe
the errors.

Example
-------

     printf("Error: %s\n", sys_errlist[errno]);


File: libc,  Node: sys_nerr,  Next: sysconf,  Prev: sys_errlist,  Up: Alphabetical List

sys_nerr
========

Syntax
------

     #include <errno.h>
     
     extern int sys_nerr;

Description
-----------

This variable gives the number of error messages in `sys_errlist'
(*note sys_errlist::.).

Example
-------

     if (errno < sys_nerr)
       printf("Error: %s\n", sys_errlist[errno]);


File: libc,  Node: sysconf,  Next: system,  Prev: sys_nerr,  Up: Alphabetical List

sysconf
=======

Syntax
------

     #include <unistd.h>
     
     long sysconf(int which);

Description
-----------

This function returns various system configuration values, based on
WHICH:

       case _SC_ARG_MAX:	return ARG_MAX;
       case _SC_CHILD_MAX:	return CHILD_MAX;
       case _SC_CLK_TCK:	return CLOCKS_PER_SEC;
       case _SC_NGROUPS_MAX:	return NGROUPS_MAX;
       case _SC_OPEN_MAX:	return 255;
       case _SC_JOB_CONTROL:	return -1;
       case _SC_SAVED_IDS:	return -1;
       case _SC_STREAM_MAX:	return _POSIX_STREAM_MAX;
       case _SC_TZNAME_MAX:	return TZNAME_MAX;
       case _SC_VERSION:	return _POSIX_VERSION;

Return Value
------------

The value.


File: libc,  Node: system,  Next: tan,  Prev: sysconf,  Up: Alphabetical List

system
======

Syntax
------

     #include <stdlib.h>
     
     int system(const char *cmd);

Description
-----------

This function runs the specified command.  When calling programs
compiled by djgpp this function will not use command.com and so will
not be subject to its 126 character limit on command lines.

Command lines and pipes( i.e., the use of "<", ">", ">>", and "|") will
be simulated internally in this function.

Command.com will only be invoked to run commands internal to it, or to
run batch files.  In these cases, the returned error code will always
be zero, since command.com always exits with code 0.

Return Value
------------

The return value of the child process.

Example
-------

     system("cc1plus.exe @cc123456.gp");


File: libc,  Node: tan,  Next: tanh,  Prev: system,  Up: Alphabetical List

tan
===

Syntax
------

     #include <math.h>
     
     double tan(double x);

Return Value
------------

The tangent of X.


File: libc,  Node: tanh,  Next: tell,  Prev: tan,  Up: Alphabetical List

tanh
====

Syntax
------

     #include <math.h>
     
     double tanh(double x);

Return Value
------------

The hyperbolic tangent of X.


File: libc,  Node: tell,  Next: telldir,  Prev: tanh,  Up: Alphabetical List

tell
====

Syntax
------

     #include <io.h>
     
     off_t tell(int file);

Description
-----------

This function returns the location of the file pointer for FILE.

Return Value
------------

The file pointer, or -1 on error.

Example
-------

     off_t q = tell(fd);


File: libc,  Node: telldir,  Next: textattr,  Prev: tell,  Up: Alphabetical List

telldir
=======

Syntax
------

     #include <dirent.h>
     
     long telldir(DIR *dir);

Description
-----------

This function returns a value which indicates the position of the
pointer in the given directory.  This value is only useful as an
argument to `seekdir' (*note seekdir::.).

Return Value
------------

The directory pointer.

Example
-------

     DIR *dir;
     long q = telldir(dir);
     do_something();
     seekdir(dir, q);


File: libc,  Node: textattr,  Next: textbackground,  Prev: telldir,  Up: Alphabetical List

textattr
========

Syntax
------

     #include <conio.h>
     
     void textattr(int _attr);

Description
-----------

Sets the attribute used for future writes to the screen:

     ---- XXXX = foreground color
     -XXX ---- = background color
     X--- ---- = 1=blink 0=steady


File: libc,  Node: textbackground,  Next: textcolor,  Prev: textattr,  Up: Alphabetical List

textbackground
==============

Syntax
------

     #include <conio.h>
     
     void textbackground(int _color);

Description
-----------

Sets just the background of the text attribute. *Note textattr::.


File: libc,  Node: textcolor,  Next: textmode,  Prev: textbackground,  Up: Alphabetical List

textcolor
=========

Syntax
------

     #include <conio.h>
     
     void textcolor(int _color);

Description
-----------

Sets just the foreground of the text attribute. *Note textattr::.


File: libc,  Node: textmode,  Next: time,  Prev: textcolor,  Up: Alphabetical List

textmode
========

Syntax
------

     #include <conio.h>
     
     void textmode(int _mode);

Description
-----------

Sets the text mode of the screen.  _MODE is one of the following:

`LASTMODE'
     The text mode which was in effect *before* the last call to
     `textmode()'.

`BW40'
     40-column black and white (on a color screen)

`C40'
     40-color color.

`BW80'
     80-column black and white (on a color screen)

`C80'
     80-column color

`MONO'
     The monochrome monitor

`C4350'
     80-column, 43- (on EGAs) or 50-row (on VGAs) color

*Note _set_screen_lines::, for a more versatile method of setting text
screen dimensions.


File: libc,  Node: time,  Next: times,  Prev: textmode,  Up: Alphabetical List

time
====

Syntax
------

     #include <time.h>
     
     time_t time(time_t *t);

Description
-----------

If T is not `NULL', the current time is stored in `*t'.

Return Value
------------

The current time is returned.

Example
-------

     printf("Time is %d\n", time(0));


File: libc,  Node: times,  Next: tmpfile,  Prev: time,  Up: Alphabetical List

times
=====

Syntax
------

     #include <sys/times.h>
     
     clock_t times(struct tms *buf);

Description
-----------

This function returns the number of clock ticks used by the current
process and all of its children until the moment of call.  The number
of tics per second is `CLOCKS_PER_SEC', defined on time.h.

This is the structure in which `times' returns its info:

     struct  tms {
       clock_t tms_cstime;
       clock_t tms_cutime;
       clock_t tms_stime;
       clock_t tms_utime;
     };

Currently, the elapsed time of the running program is returned in the
`tms_utime' field, and all other fields return as zero.

Return Value
------------

The number of elapsed tics since the program started.

Example
-------

     printf("We used %d seconds of elapsed time\n", times(&buf)/CLOCKS_PER_SEC);


File: libc,  Node: tmpfile,  Next: tmpnam,  Prev: times,  Up: Alphabetical List

tmpfile
=======

Syntax
------

     #include <stdio.h>
     
     FILE *tmpfile(void);

Description
-----------

This function opens a temporary file.  It will automatically be removed
if the file is closed or when the program exits.  The name of the file
is generated by the same algorithm as described under tmpnam() (*note
tmpnam::.).

Return Value
------------

A newly opened file.

Example
-------

     FILE *tmp = tmpfile();


File: libc,  Node: tmpnam,  Next: toascii,  Prev: tmpfile,  Up: Alphabetical List

tmpnam
======

Syntax
------

     #include <stdio.h>
     
     char *tmpnam(char *s);

Description
-----------

This functions generates a string that is a valid file name and that is
not the same as the name of an existing file.  A different string is
guaranteed to be produced each time it is called, up to `TMP_MAX' times
(`TMP_MAX' is defined on stdio.h).  If `tmpnam' is called more than
TMP_MAX times, the behavior is implementation-dependent (ours just
wraps around and tries to reuse the same file names from the beginning).

This function examines the environment to determine the directory in
which the temporary file will be opened.  It looks for one of the
variables `"TMPDIR"', `"TEMP"' and `"TMP"', in that order.  The first
one which is found in the environment will be used on the assumption
that it points to a directory.  If neither of the above variables is
defined, `tmpnam' defaults to the "c:/" directory (which under MS-DOS
might mean that it fails to generate TMP_MAX unique names, because DOS
root directories cannot grow beyond certain limits).

Return Value
------------

If S is a null pointer, `tmpnam' leaves its result in an internal
static buffer and returns a pointer to that buffer.  If S is not a null
pointer, it is assumed to point to an array of at least `L_tmpnam'
characters, and `tmpnam' writes its result in that array and returns a
pointer to it as its value.

Example
-------

     char buf[L_tmpnam];
     char *s = tmpname(buf);


File: libc,  Node: toascii,  Next: tolower,  Prev: tmpnam,  Up: Alphabetical List

toascii
=======

Syntax
------

     #include <ctype.h>
     
     int toascii(int c);

Description
-----------

This function strips the high bit of C, forcing it to be an ASCII
character.

Return Value
------------

The ASCII character.

Example
-------

     for (i=0; buf[i]; i++)
       buf[i] = toascii(buf[i]);


File: libc,  Node: tolower,  Next: toupper,  Prev: toascii,  Up: Alphabetical List

tolower
=======

Syntax
------

     #include <ctype.h>
     
     int tolower(int c);

Description
-----------

This function returns C, converting it to lower case if it is upper
case.  *Note toupper::.

Return Value
------------

The lower case letter.

Example
-------

     for (i=0; buf[i]; i++)
       buf[i] = tolower(buf[i]);


File: libc,  Node: toupper,  Next: _truename,  Prev: tolower,  Up: Alphabetical List

toupper
=======

Syntax
------

     #include <ctype.h>
     
     int toupper(int c);

Description
-----------

This function returns C, converting it to upper case if it is lower
case. *Note tolower::.

Return Value
------------

The upper case letter.

Example
-------

     for (i=0; buf[i]; i++)
       buf[i] = toupper(buf[i]);


File: libc,  Node: _truename,  Next: truncate,  Prev: toupper,  Up: Alphabetical List

_truename
=========

Syntax
------

     #include <sys/stat.h>
     
     char * _truename(const char *path, char *true_path);

Description
-----------

Given a PATH of a file, returns in TRUE_PATH its canonicalized
pathname, with all letters uppercased, default drive and directory made
explicit, forward slashes converted to backslashes, asterisks converted
to appropriate number of of question marks, file and directory names
truncated to 8.3 if necessary, "." and ".." resolved, extra slashes (but
the last, if present) removed, SUBSTed, JOINed and ASSIGNed drives
resolved.  Character devices return as "X:/DEVNAME" (note the forward
slash!), where X is the CURRENT drive and DEVNAME is the device name
(e.g.  CON).  This is exactly what DOS TRUENAME command does.  See
Ralph Brown's Interrupt List for more details.

The named PATH doesn't have to exist, but the drive, if given as part
of it, should be a legal DOS drive, as this function hits the disk.

The function will fail if given a PATH which (1) is an empty string; or
(2) contains only the drive letter (e.g. "c:"); or (3) has leading
whitespace.  It will also fail if it couldn't allocate memory required
for its communication with DOS or for TRUE_PATH (see below).

Upon success, the function will place the result in TRUE_PATH, if
that's non-NULL; the buffer should be large enough to contain the
largest possible pathname (PATH_MAX characters).  If TRUE_PATH is a
NULL pointer, the space to hold the result will be allocated by calling
*Note malloc::; it is up to the caller to release the buffer by calling
*Note free::.

Return Value
------------

The function returns the pointer to the result.  In case of any failure,
a NULL pointer is returned, and ERRNO is set.

Example
-------

       fprintf(stderr,
               "True name of %s is %s\n", path, _truename(path, (char *)0));


File: libc,  Node: truncate,  Next: ttyname,  Prev: _truename,  Up: Alphabetical List

truncate
========

Syntax
------

     #include <unistd.h>
     
     int truncate(const char *file, off_t size);

Description
-----------

This function truncates FILE to SIZE bytes.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     ftruncate("/tmp/data.txt", 400);


File: libc,  Node: ttyname,  Next: uclock,  Prev: truncate,  Up: Alphabetical List

ttyname
=======

Syntax
------

     #include <unistd.h>
     
     char *ttyname(int file);

Description
-----------

Gives the name of the terminal associated with FILE.

Return Value
------------

Returns "con" if FILE is a device, else `NULL'.

Example
-------

     char *tty = ttyname(0);


File: libc,  Node: uclock,  Next: umask,  Prev: ttyname,  Up: Alphabetical List

uclock
======

Syntax
------

     #include <time.h>
     
     uclock_t uclock(void);

Description
-----------

This function returns the number of uclock ticks since an arbitrary
time, actually, since the first call to `uclock', which itself returns
zero.  The number of tics per second is UCLOCKS_PER_SEC.

`uclock' is provided for very high-resulution timing.  It is currently
accurate to better than 1 microsecond (actually about 840 nanoseconds).
You cannot time across two midnights with this implementation, giving
a maximum useful period of 48 hours and an effective limit of 24 hours.
Casting to a 32-bit integer limits its usefulness to about an hour
before 32 bits will wrap.

Note that `printf' cannot print a value of type `uclock_t', even though
it is an integer value, because it is a 64-bit integer.

Also note that `uclock' reprograms the interval timer in your PC to act
as a rate generator rather than a square wave generator.  I've had no
problems running in this mode all the time, but if you notice strange
things happening with the clock (losing time) after using `uclock',
check to see if this is the cause of the problem.

Return Value
------------

The number of tics.

Example
-------

     printf("%d seconds have elapsed\n", (int)(uclock()/UCLOCKS_PER_SEC));


File: libc,  Node: umask,  Next: uname,  Prev: uclock,  Up: Alphabetical List

umask
=====

     #include <sys/stat.h>
     
     mode_t umask(mode_t cmask);

Description
-----------

This function does nothing.  It exists to assist porting.


File: libc,  Node: uname,  Next: ungetc,  Prev: umask,  Up: Alphabetical List

uname
=====

Syntax
------

     #include <sys/utsname.h>
     
     #int uname(struct utsname *u);

Description
-----------

Fills in the structure with information about the system.

     struct utsname {
       char machine[9];
       char nodename[32];
       char release[9];
       char sysname[9];
       char version[9];
     };

`machine'
     "pc"

`nodename'
     The name of your PC (if networking is installed), else "pc".

`release'
     The minor release of dos.  For example, dos 1.23 would return "23"
     here.

`sysname'
     The flavor of the OS.

`version'
     The major release of dos.  For example, dos 1.23 would return "1"
     here.

Return Value
------------

Zero on success, else nonzero.


File: libc,  Node: ungetc,  Next: ungetch,  Prev: uname,  Up: Alphabetical List

ungetc
======

Syntax
------

     #include <stdio.h>
     
     int ungetc(int c, FILE *file);

Description
-----------

This function pushes C back into the FILE.  You can only push back one
character at a time.

Return Value
------------

The pushed-back character, or `EOF' on error.

Example
-------

     int q;
     while (q = getc(stdin) != 'q');
     ungetc(q);


File: libc,  Node: ungetch,  Next: unlink,  Prev: ungetc,  Up: Alphabetical List

ungetch
=======

Syntax
------

     #include <conio.h>
     
     int ungetch(int);

Description
-----------

Puts a character back, so that *Note getch:: will return it instead of
actually reading the console.

Return Value
------------

The charater is returned.


File: libc,  Node: unlink,  Next: unlock,  Prev: ungetch,  Up: Alphabetical List

unlink
======

Syntax
------

     #include <unistd.h>
     
     int unlink(const char *file);

Description
-----------

This function removes a file from the file system.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     unlink("data.txt");


File: libc,  Node: unlock,  Next: _use_lfn,  Prev: unlink,  Up: Alphabetical List

unlock
======

Syntax
------

     #include <io.h>
     
     int unlock(int fd, long offset, long length);

Description
-----------

Unlocks a region previously locked by `lock'.

*Note lock::.

Return Value
------------

Zero if successful, nonzero if not.


File: libc,  Node: _use_lfn,  Next: usleep,  Prev: unlock,  Up: Alphabetical List

_use_lfn
========

Syntax
------

     #include <libc/dosio.h>
     
     int _use_lfn(void);

Description
-----------

This function returns a nonzero value if the low level libc routines
should try to use the Long File Name (LFN) functions provided with
Windows 95.  This routine can be replaced with one always returning 0
to disable using long file names.

Long file names can also be disabled by setting the flag
_CRT0_FLAG_NO_LFN in _crt0_startup_flags for an image which should not
allow use of long file names.  Long names can be suppressed at runtime
on a global basis by setting the environment variable LFN to N, i.e.
SET LFN=N.  This might be needed if a distribution expected the
truncation of long file names to 8.3 format to work.  For example, if a
C source routine included the file exception.h (9 letters) and the file
was unzipped as exceptio.h, then GCC would not find the file unless the
environment variable was set.  The environment variable can be set in
the djgpp.env file to always disable LFN support on any system, or can
be set in the DOS environment for a short term (single project) basis.
If you dual boot a system between Windows 95 and DOS, you probably
should set LFN=n in your djgpp.env file, since long file names would not
be visable under DOS, and working with the short names under DOS will
damage the long names when returning to Windows 95.

Return Value
------------

If LFN APIs are supported and should be used, it returns 1, else 0.


File: libc,  Node: usleep,  Next: utime,  Prev: _use_lfn,  Up: Alphabetical List

usleep
======

Syntax
------

     #include <unistd.h>
     
     unsigned usleep(unsigned usec);

Description
-----------

This function pauses the program for USEC microseconds.

Return Value
------------

The number of unslept microseconds (i.e. zero).

Example
-------

     usleep(500000);


File: libc,  Node: utime,  Next: utimes,  Prev: usleep,  Up: Alphabetical List

utime
=====

Syntax
------

     #include <utime.h>
     
     int utime(const char *file, const struct utimbuf *time);

Description
-----------

This function sets the modification timestamp on the FILE.  The new
time is stored in this structure:

     struct utimbuf
     {
         time_t  actime;  /* access time (unused) */
         time_t  modtime; /* modification time */
     };

Note that, as under DOS a file only has a single timestamp, the
`actime' field of `struct utimbuf' is ignored by this function, and
only `modtime' field is used.

Return Value
------------

Zero for success, nonzero for failure.

Example
-------

     struct utimbuf t;
     t.modtime = time(0);
     utime("data.txt", &t);


File: libc,  Node: utimes,  Next: vfprintf,  Prev: utime,  Up: Alphabetical List

utimes
======

Syntax
------

     #include <sys/time.h>
     
     int utimes(const char *file, struct timeval tvp[2]);

Description
-----------

This function sets the timestamp of the file to `tvp[1].tv_sec'.

Return Value
------------

Zero on success, nonzero on failure.

Example
-------

     time_t now;
     struct timeval tvp[2];
     time(&now);
     tvp[0].tv_sec = now + 100;
     utimes("foo.dat", tvp);


File: libc,  Node: vfprintf,  Next: vprintf,  Prev: utimes,  Up: Alphabetical List

vfprintf
========

Syntax
------

     #include <stdio.h>
     #include <stdarg.h>
     
     int vfprintf(FILE *file, const char *format, va_list arguments);

Description
-----------

Sends formatted output from the ARGUMENTS to the FILE.  *Note printf::.

Return Value
------------

The number of characters written.

Example
-------

     void my_errmsg(char *format, ...)
     {
       va_list arg;
     
       va_start(arg, format);
       fprintf(stderr, "my_errmsg: ");
       vfprintf(stderr, format, arg);
       va_end(arg);
     }


File: libc,  Node: vprintf,  Next: vsprintf,  Prev: vfprintf,  Up: Alphabetical List

vprintf
=======

Syntax
------

     #include <stdio.h>
     #include <stdarg.h>
     
     int vprintf(const char *format, va_list arguments);

Description
-----------

Sends formatted output from the ARGUMENTS to `stdout'.  *Note printf::.
*Note vfprintf::.

Return Value
------------

The number of characters written.


File: libc,  Node: vsprintf,  Next: wait,  Prev: vprintf,  Up: Alphabetical List

vsprintf
========

Syntax
------

     #include <stdio.h>
     #include <stdarg.h>
     
     int vsprintf(char *buffer, const char *format, va_list arguments);

Description
-----------

Sends formatted output from the ARGUMENTS to the BUFFER.  *Note
printf::. *Note vfprintf::.

Return Value
------------

The number of characters written.


File: libc,  Node: wait,  Next: waitpid,  Prev: vsprintf,  Up: Alphabetical List

wait
====

Syntax
------

     #include <sys/wait.h>
     
     pid_t pid = wait(int *status);

Description
-----------

This function causes its caller to delay its execution until a signal
is received or one of its child processes terminates.  If any child has
terminated, return is immediate, returning the process ID and its exit
status, if that's available.  If no children processes were called since
the last call, then -1 is returned and `errno' is set.

Return Value
------------

If successful, this function returns the exit status of the child.  If
there is an error, these functions return -1 and set `errno' to
indicate the error type.

Bugs
----

Currently, this function always fails.


File: libc,  Node: waitpid,  Next: wcstombs,  Prev: wait,  Up: Alphabetical List

waitpid
=======

Syntax
------

     #include <sys/wait.h>
     
     pid_t pid = waitpid((pid_t pid, int *status, int options);

Description
-----------

Currently, this function always fails. A -1 is returned and `errno' is
set to indicate there are no children.

Return Value
------------

If successful, this function returns the exit status of the child.  If
there is an error, these functions return -1 and set `errno' to
indicate the error type.

Bugs
----

Currently, this function always fails.


File: libc,  Node: wcstombs,  Next: wctomb,  Prev: waitpid,  Up: Alphabetical List

wcstombs
========

Syntax
------

     #include <stdlib.h>
     
     size_t wcstombs(char *s, const wchar_t *wcs, size_t n);

Description
-----------

Converts a wide character string to a multibyte string.  At most N
characters are stored.

Return Value
------------

The number of characters stored.

Example
-------

     int len = wcstombs(buf, wstring, sizeof(buf));


File: libc,  Node: wctomb,  Next: wherex,  Prev: wcstombs,  Up: Alphabetical List

wctomb
======

Syntax
------

     #include <stdlib.h>
     
     int wctomb(char *s, wchar_t wchar);

Description
-----------

Convert a wide character to a multibyte character.  The string S must
be at least `MB_LEN_MAX' bytes long.

Return Value
------------

The number of characters stored.

Example
-------

     char s[MB_LEN_MAX];
     int mlen = wctomb(s, wc);


File: libc,  Node: wherex,  Next: wherey,  Prev: wctomb,  Up: Alphabetical List

wherex
======

Syntax
------

     #include <conio.h>
     
     int wherex(void);

Return Value
------------

The column the cursor is on.  The leftmost column is 1.


File: libc,  Node: wherey,  Next: window,  Prev: wherex,  Up: Alphabetical List

wherey
======

Syntax
------

     #include <conio.h>
     
     int     wherey(void);

Return Value
------------

The row the cursor is on.  The topmost row is 1.


File: libc,  Node: window,  Next: write,  Prev: wherey,  Up: Alphabetical List

window
======

Syntax
------

     #include <conio.h>
     
     void    window(int _left, int _top, int _right, int _bottom);

Description
-----------

Specifies the window on the screen to be used for future output
requests.  The upper left corner of the physical screen is (1,1).


File: libc,  Node: write,  Next: _write,  Prev: window,  Up: Alphabetical List

write
=====

Syntax
------

     #include <unistd.h>
     
     int write(int file, const void *buffer, unsigned count);

Description
-----------

This function writes COUNT bytes from BUFFER to FILE.  It returns the
number of bytes actually written.  It will return zero if the disk is
full, and may return less than COUNT even under valid conditions.

Note that if FILE is a text file, `write' may write more bytes than it
reports.

If COUNT is zero, the function does nothing and returns zero.  Use
_write if you want to actually ask dos to write zero bytes.

Return Value
------------

The number of bytes written, zero at EOF, or -1 on error.

Example
-------

     write(fd, "hello", 5);


File: libc,  Node: _write,  Next: xfree,  Prev: write,  Up: Alphabetical List

_write
======

Syntax
------

     #include <io.h>
     
     ssize_t _write(int fildes, void *buf, size_t nbyte);

Description
-----------

This is a direct connection to the MS-DOS write function call, int
0x21, %ah = 0x40.  No conversion is done on the data; it is written as
raw binary data.

Return Value
------------

The number of bytes written.


File: libc,  Node: xfree,  Next: xmalloc,  Prev: _write,  Up: Alphabetical List

xfree
=====

Syntax
------

     #include <stdlib.h>
     
     void xfree(void *ptr);

Description
-----------

Frees memory allocated by `xmalloc' (*note xmalloc::.).  This function
guarantees that a NULL pointer is handled gracefully.

Example
-------

     void *f = xmalloc(100);
     xfree(f);


File: libc,  Node: xmalloc,  Next: xrealloc,  Prev: xfree,  Up: Alphabetical List

xmalloc
=======

Syntax
------

     #include <stdlib.h>
     
     void *xmalloc(size_t size);

Description
-----------

This function is just like `malloc' (*note malloc::.), except that if
there is no more memory, it prints an error message and exits.

Return Value
------------

A pointer to the newly allocated memory.

Example
-------

     char *f = xmalloc(100);


File: libc,  Node: xrealloc,  Prev: xmalloc,  Up: Alphabetical List

xrealloc
========

Syntax
------

     #include <stdlib.h>
     
     void *xrealloc(void *ptr, size_t size);

Description
-----------

This function is just like `realloc' (*note realloc::.), except that if
there is no more memory, it prints an error message and exits.  It can
also properly handle PTR being `NULL'.

Return Value
------------

A pointer to a possibly new block.

Example
-------

     char *buf;
     buf = (char *)xrealloc(buf, new_size);


File: libc,  Node: Index,  Up: Top

* Menu:
*Note Alphabetical List::



Tag Table:
Node: Top168
Node: Introduction468
Node: Functional Categories1674
Node: bios functions2384
Node: conio functions2768
Node: cpu functions3565
Node: ctype functions4076
Node: dos functions4410
Node: dpmi functions5097
Node: environment functions9044
Node: file system functions9246
Node: go32 functions10066
Node: io functions10469
Node: locale functions10867
Node: math functions11134
Node: memory functions11590
Node: misc functions12342
Node: mono functions12707
Node: posix functions12908
Node: process functions13109
Node: random number functions13460
Node: shell functions13675
Node: signal functions13863
Node: sound functions14044
Node: startup functions14226
Node: stdio functions14510
Node: stdlib functions15391
Node: string functions15563
Node: time functions16142
Node: unix functions16536
Node: Alphabetical List17110
Node: abort27700
Node: abs28115
Node: access28409
Node: acos29302
Node: acosh29515
Node: addmntent29745
Node: alarm30160
Node: alloca30755
Node: asctime31266
Node: asin31980
Node: asinh32192
Node: assert32417
Node: atan33297
Node: atan233511
Node: atanh33786
Node: atexit34015
Node: atof34738
Node: atoi35303
Node: atol35854
Node: _atold36409
Node: bcmp37001
Node: bcopy37600
Node: bdos38071
Node: bdosptr38843
Node: _bios_disk39969
Node: _bios_equiplist44767
Node: _bios_keybrd45973
Node: _bios_memsize48562
Node: _bios_printer49023
Node: _bios_serialcom50333
Node: _bios_timeofday53197
Node: bioscom54173
Node: biosdisk56266
Node: biosequip58126
Node: bioskey59457
Node: biosmemory60308
Node: biosprint60852
Node: biostime61632
Node: brk62104
Node: bsearch62736
Node: bzero63986
Node: calloc64341
Node: ceil65063
Node: cfree65310
Node: cgets65705
Node: chdir66285
Node: chmod66905
Node: _chmod67571
Node: chown68691
Node: chsize69084
Node: _clear8769395
Node: clearerr69716
Node: clock70073
Node: close70590
Node: _close70999
Node: closedir71348
Node: clreol71697
Node: clrscr71949
Node: _conio_kbhit72174
Node: _control8772700
Node: cos74226
Node: cosh74434
Node: cprintf74653
Node: cputs75139
Node: creat75452
Node: _creat76180
Node: crlf2nl76583
Node: __crt0_glob_function76936
Node: __crt0_load_environment_file77652
Node: __crt0_setup_arguments78305
Node: _crt0_startup_flags78930
Node: cscanf83093
Node: ctime83447
Node: delay83869
Node: delline84297
Node: difftime84563
Node: disable85053
Node: div85596
Node: __djgpp_map_physical_memory86316
Node: __djgpp_memory_handle87887
Node: __djgpp_memory_handle_list88523
Node: __djgpp_nearptr_disable89101
Node: __djgpp_nearptr_enable89503
Node: __djgpp_set_page_attributes91116
Node: _djstat_describe_lossage92424
Node: _djstat_fail_bits94603
Node: _djstat_flags97770
Node: _doprnt99917
Node: _dos_close100561
Node: _dos_commit101228
Node: _dos_creat101811
Node: _dos_creatnew102948
Node: _dos_findfirst104096
Node: _dos_findnext105668
Node: _dos_getdate106121
Node: _dos_getdiskfree106880
Node: _dos_getdrive107871
Node: _dos_getfileattr108462
Node: _dos_getftime109876
Node: _dos_gettime111788
Node: _dos_lock112496
Node: _dos_open112867
Node: _dos_read114402
Node: _dos_setdate115781
Node: _dos_setdrive116767
Node: _dos_setfileattr117509
Node: _dos_setftime118514
Node: _dos_settime119979
Node: _dos_unlock120885
Node: _dos_write121270
Node: _doscan122686
Node: dosexterr123386
Node: dosmemget129012
Node: dosmemgetb129883
Node: dosmemgetl130798
Node: dosmemgetw131732
Node: dosmemput132662
Node: dosmemputb133500
Node: dosmemputl134389
Node: dosmemputw135287
Node: DPMI Overview136191
Node: DPMI Specification141238
Node: __dpmi_allocate_dos_memory141573
Node: __dpmi_allocate_ldt_descriptors142505
Node: __dpmi_allocate_linear_memory143274
Node: __dpmi_allocate_memory144055
Node: __dpmi_allocate_real_mode_callback144678
Node: __dpmi_allocate_shared_memory145590
Node: __dpmi_allocate_specific_ldt_descriptor146207
Node: __dpmi_clear_debug_watchpoint146855
Node: __dpmi_create_alias_descriptor147464
Node: __dpmi_discard_page_contents148108
Node: __dpmi_free_dos_memory148791
Node: __dpmi_free_ldt_descriptor149459
Node: __dpmi_free_memory150132
Node: __dpmi_free_physical_address_mapping150702
Node: __dpmi_free_real_mode_callback151413
Node: __dpmi_free_serialization_on_shared_memory152059
Node: __dpmi_free_shared_memory152722
Node: __dpmi_get_and_disable_virtual_interrupt_state153338
Node: __dpmi_get_and_enable_virtual_interrupt_state154033
Node: __dpmi_get_and_set_virtual_interrupt_state154748
Node: __dpmi_get_capabilities155551
Node: __dpmi_get_coprocessor_status156678
Node: __dpmi_get_descriptor157263
Node: __dpmi_get_descriptor_access_rights158559
Node: __dpmi_get_extended_exception_handler_vector_pm159260
Node: __dpmi_get_extended_exception_handler_vector_rm160021
Node: __dpmi_get_free_memory_information160775
Node: __dpmi_get_memory_block_size_and_base161513
Node: __dpmi_get_memory_information162190
Node: __dpmi_get_multiple_descriptors162844
Node: __dpmi_get_page_attributes163797
Node: __dpmi_get_page_size164548
Node: __dpmi_get_processor_exception_handler_vector165134
Node: __dpmi_get_protected_mode_interrupt_vector165889
Node: __dpmi_get_raw_mode_switch_addr166679
Node: __dpmi_get_real_mode_interrupt_vector167326
Node: __dpmi_get_segment_base_address168178
Node: __dpmi_get_segment_limit168950
Node: __dpmi_get_selector_increment_value169514
Node: __dpmi_get_state_of_debug_watchpoint170173
Node: __dpmi_get_state_save_restore_addr170898
Node: __dpmi_get_vendor_specific_api_entry_point171569
Node: __dpmi_get_version172265
Node: __dpmi_get_virtual_interrupt_state173131
Node: __dpmi_install_resident_service_provider_callback173752
Node: __dpmi_int174426
Node: __dpmi_lock_linear_region175429
Node: __dpmi_map_conventional_memory_in_memory_block176105
Node: __dpmi_map_device_in_memory_block176915
Node: __dpmi_mark_page_as_demand_paging_candidate177728
Node: __dpmi_mark_real_mode_region_as_pageable178472
Node: __dpmi_physical_address_mapping179218
Node: __dpmi_relock_real_mode_region179981
Node: __dpmi_reset_debug_watchpoint180690
Node: __dpmi_resize_dos_memory181255
Node: __dpmi_resize_linear_memory182004
Node: __dpmi_resize_memory182786
Node: __dpmi_segment_to_descriptor183515
Node: __dpmi_serialize_on_shared_memory184279
Node: __dpmi_set_coprocessor_emulation184911
Node: __dpmi_set_debug_watchpoint185502
Node: __dpmi_set_descriptor186217
Node: __dpmi_set_descriptor_access_rights186846
Node: __dpmi_set_extended_exception_handler_vector_pm188099
Node: __dpmi_set_extended_exception_handler_vector_rm188861
Node: __dpmi_set_multiple_descriptors189614
Node: __dpmi_set_page_attributes190436
Node: __dpmi_set_processor_exception_handler_vector191191
Node: __dpmi_set_protected_mode_interrupt_vector191971
Node: __dpmi_set_real_mode_interrupt_vector192951
Node: __dpmi_set_segment_base_address193754
Node: __dpmi_set_segment_limit194414
Node: __dpmi_simulate_real_mode_interrupt195248
Node: __dpmi_simulate_real_mode_procedure_iret196081
Node: __dpmi_simulate_real_mode_procedure_retf196888
Node: __dpmi_simulate_real_mode_procedure_retf_stack197735
Node: __dpmi_terminate_and_stay_resident198910
Node: __dpmi_unlock_linear_region199568
Node: __dpmi_yield200193
Node: dup200723
Node: dup2201139
Node: _dxe_load201675
Node: enable202375
Node: endgrent202921
Node: endmntent203283
Node: endpwent203648
Node: errno203968
Node: exec*205838
Node: _exit206905
Node: exit207462
Node: exp207977
Node: fabs208180
Node: _far*208465
Node: fclose210874
Node: fcntl211262
Node: fdopen211605
Node: feof212147
Node: ferror212555
Node: fflush212984
Node: ffs213511
Node: fgetc213976
Node: fgetgrent214411
Node: fgetpos214711
Node: fgets215115
Node: File System Extensions215885
Node: __file_exists217898
Node: file_tree_walk218607
Node: filelength221291
Node: fileno221991
Node: findfirst222330
Node: findnext224532
Node: _fixpath224903
Node: floor225672
Node: fmod225920
Node: _fmode226144
Node: fnmatch226590
Node: fnmerge228140
Node: fnsplit228972
Node: fopen230238
Node: fork231806
Node: fpathconf232085
Node: _fpreset232530
Node: fprintf232763
Node: fpurge233115
Node: fputc233443
Node: fputs233825
Node: fread234255
Node: free234716
Node: freopen235108
Node: frexp235659
Node: fscanf236103
Node: fseek236516
Node: fsetpos237590
Node: __FSEXT_add_open_handler238022
Node: __FSEXT_alloc_fd238695
Node: __FSEXT_call_open_handlers239608
Node: __FSEXT_get_function240158
Node: __FSEXT_set_function240859
Node: fstat241397
Node: fsync244355
Node: ftell244736
Node: ftime245134
Node: ftruncate245865
Node: ftw246354
Node: _fwalk250772
Node: fwrite251207
Node: _get_dev_info251687
Node: _get_dos_version252144
Node: getc253995
Node: getcbrk254395
Node: getch254722
Node: getchar255173
Node: getche255467
Node: getcwd255913
Node: getdate256627
Node: getdfree257125
Node: getdisk257858
Node: getdtablesize258233
Node: getegid258558
Node: getenv258822
Node: geteuid259258
Node: getftime259513
Node: getgid260236
Node: getgrent260491
Node: getgrgid261585
Node: getgrnam261995
Node: gethostname262411
Node: getitimer263286
Node: getkey263796
Node: getlogin264367
Node: getlongpass264803
Node: getmntent265663
Node: getpagesize269440
Node: getpass269783
Node: getpgrp270599
Node: getpid270909
Node: getpwent271232
Node: getpwnam272112
Node: getpwuid272489
Node: getrusage272859
Node: gets273580
Node: gettext274157
Node: gettextinfo274499
Node: gettime275325
Node: gettimeofday275886
Node: getuid276680
Node: getw276930
Node: getwd277406
Node: getxkey277809
Node: glob278371
Node: globfree279735
Node: gmtime279987
Node: _go32_conventional_mem_selector281159
Node: _go32_dpmi_allocate_dos_memory282254
Node: _go32_dpmi_allocate_iret_wrapper283465
Node: _go32_dpmi_allocate_real_mode_callback_iret284664
Node: _go32_dpmi_allocate_real_mode_callback_retf286430
Node: _go32_dpmi_chain_protected_mode_interrupt_vector287618
Node: _go32_dpmi_free_dos_memory288615
Node: _go32_dpmi_free_iret_wrapper289377
Node: _go32_dpmi_free_real_mode_callback290023
Node: _go32_dpmi_get_free_memory_information290726
Node: _go32_dpmi_get_protected_mode_interrupt_vector292030
Node: _go32_dpmi_get_real_mode_interrupt_vector292893
Node: _go32_dpmi_lock_code293598
Node: _go32_dpmi_lock_data294278
Node: _go32_dpmi_remaining_physical_memory294894
Node: _go32_dpmi_remaining_virtual_memory295385
Node: _go32_dpmi_resize_dos_memory295880
Node: _go32_dpmi_set_protected_mode_interrupt_vector296831
Node: _go32_dpmi_set_real_mode_interrupt_vector298723
Node: _go32_dpmi_simulate_fcall299440
Node: _go32_dpmi_simulate_fcall_iret300561
Node: _go32_dpmi_simulate_int301693
Node: _go32_info_block302826
Node: _go32_interrupt_stack_size306198
Node: _go32_my_cs306565
Node: _go32_my_ds306920
Node: _go32_my_ss307245
Node: _go32_rmcb_stack_size307580
Node: _go32_want_ctrl_break307941
Node: _go32_was_ctrl_break_hit308856
Node: gotoxy309636
Node: gppconio_init309954
Node: hasmntopt310430
Node: highvideo310919
Node: htonl311185
Node: htons311690
Node: hypot312188
Node: inb312526
Node: index312784
Node: inp313328
Node: inportb313589
Node: inportl314037
Node: inportsb314503
Node: inportsl314820
Node: inportsw315139
Node: inportw315458
Node: inpw315910
Node: insline316178
Node: insque316482
Node: int386317071
Node: int386x317445
Node: int86317835
Node: int86x320117
Node: intdos320788
Node: intdosx321136
Node: _is_executable321513
Node: isalnum323385
Node: isalpha323718
Node: isascii324007
Node: isatty324317
Node: iscntrl324722
Node: isdigit325032
Node: isgraph325319
Node: islower325672
Node: isprint325972
Node: ispunct326321
Node: isspace326673
Node: isupper327041
Node: isxdigit327355
Node: itoa327702
Node: kbhit328584
Node: kill329352
Node: labs329668
Node: ldexp329945
Node: ldiv330243
Node: link330955
Node: localeconv331451
Node: localtime334281
Node: lock334710
Node: log335471
Node: log10335685
Node: log2335905
Node: longjmp336125
Node: lowvideo336894
Node: lseek337154
Node: malloc337858
Node: mblen338433
Node: mbstowcs339008
Node: mbtowc339506
Node: memccpy340090
Node: memchr341057
Node: memcmp341546
Node: memcpy341946
Node: memmove342321
Node: memset342869
Node: mkdir343314
Node: mkfifo343747
Node: mknod343971
Node: mkstemp344195
Node: mktemp344935
Node: mktime345697
Node: modf346158
Node: modfl346543
Node: _mono_clear346951
Node: _mono_printf347204
Node: _mono_putc347509
Node: movedata347780
Node: movedatab349355
Node: movedatal349690
Node: movedataw350077
Node: movetext350463
Node: mprotect350850
Node: _my_cs351995
Node: _my_ds352322
Node: _my_ss352647
Node: nice352970
Node: normvideo353293
Node: nosound353567
Node: ntohl353788
Node: ntohs354288
Node: open354782
Node: _open356489
Node: opendir356886
Node: outb357990
Node: outp358266
Node: outportb358544
Node: outportl358954
Node: outportsb359369
Node: outportsl359679
Node: outportsw359991
Node: outportw360304
Node: outpw360718
Node: pathconf361004
Node: pause362275
Node: pclose362598
Node: perror363165
Node: pipe363699
Node: popen363918
Node: pow365173
Node: pow10365395
Node: pow2365613
Node: printf365830
Node: putc369131
Node: putch369511
Node: putchar369971
Node: putenv370348
Node: puts371176
Node: puttext371571
Node: putw371909
Node: qsort372377
Node: raise373843
Node: rand374161
Node: random374513
Node: rawclock374796
Node: read375218
Node: _read375854
Node: readdir376279
Node: realloc377030
Node: remove377830
Node: remque378291
Node: rename378848
Node: rewind380393
Node: rewinddir380772
Node: rindex381212
Node: rmdir381760
Node: sbrk382163
Node: scanf383041
Node: Screen Variables386367
Node: ScreenClear387497
Node: ScreenCols387962
Node: ScreenGetCursor388622
Node: ScreenMode389147
Node: ScreenPutChar389600
Node: ScreenPutString390237
Node: ScreenRetrieve390975
Node: ScreenRows391679
Node: ScreenSetCursor392243
Node: ScreenUpdate392759
Node: ScreenUpdateLine393271
Node: ScreenVisualBell393754
Node: searchpath394239
Node: seekdir394910
Node: select395531
Node: _set_screen_lines396573
Node: setbuf397684
Node: setbuffer398483
Node: setcbrk399295
Node: _setcursortype399672
Node: setdate400106
Node: setdisk400485
Node: setenv400887
Node: setftime401429
Node: setgrent402160
Node: setitimer402563
Node: setjmp403848
Node: setlinebuf404623
Node: setlocale405284
Node: setmntent406409
Node: setmode406882
Node: setpgid407719
Node: setpwent407997
Node: settime408347
Node: settimeofday408725
Node: setvbuf409174
Node: siglongjmp410231
Node: signal410478
Node: sigsetjmp411271
Node: sin411514
Node: sinh411719
Node: sleep411934
Node: sound412323
Node: spawn*412567
Node: sprintf415402
Node: sqrt415772
Node: srandom415989
Node: sscanf416418
Node: stat416846
Node: statfs419946
Node: _status87421018
Node: _stklen422124
Node: stpcpy422537
Node: strcase422896
Node: strcasecmp423360
Node: strcat423836
Node: strchr424211
Node: strcmp424715
Node: strcoll425197
Node: strcpy425728
Node: strcspn426071
Node: strdup426681
Node: strerror427242
Node: strftime427717
Node: stricmp430311
Node: strlen430773
Node: strlwr431178
Node: strncase431571
Node: strncasecmp432132
Node: strncat432706
Node: strncmp433100
Node: strncpy433626
Node: strnicmp434014
Node: strpbrk434572
Node: strrchr435047
Node: strsep435492
Node: strspn436374
Node: strstr436974
Node: strtod437398
Node: strtok437924
Node: strtol438714
Node: _strtold439603
Node: strtoul440150
Node: strupr440666
Node: strxfrm441043
Node: swab441632
Node: sync442196
Node: sys_errlist442405
Node: sys_nerr442771
Node: sysconf443164
Node: system443933
Node: tan444766
Node: tanh444971
Node: tell445188
Node: telldir445545
Node: textattr446076
Node: textbackground446452
Node: textcolor446755
Node: textmode447043
Node: time447779
Node: times448142
Node: tmpfile449046
Node: tmpnam449564
Node: toascii451127
Node: tolower451531
Node: toupper451953
Node: _truename452376
Node: truncate454323
Node: ttyname454718
Node: uclock455100
Node: umask456473
Node: uname456718
Node: ungetc457520
Node: ungetch457975
Node: unlink458326
Node: unlock458692
Node: _use_lfn459037
Node: usleep460602
Node: utime460982
Node: utimes461777
Node: vfprintf462280
Node: vprintf462910
Node: vsprintf463321
Node: wait463747
Node: waitpid464533
Node: wcstombs465122
Node: wctomb465582
Node: wherex466038
Node: wherey466289
Node: window466537
Node: write466903
Node: _write467680
Node: xfree468115
Node: xmalloc468499
Node: xrealloc468956
Node: Index469487

End Tag Table
