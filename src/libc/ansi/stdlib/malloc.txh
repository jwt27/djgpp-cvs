@node malloc, memory
@subheading Syntax

@example
#include <stdlib.h>

void *malloc(size_t size);
@end example

@subheading Description

This function allocates a chunk of memory from the heap large enough to
hold any object that is @var{size} bytes in length.  This memory must be
returned to the heap with @code{free} (@pxref{free}). 

Note: this version of malloc is designed to reduce memory usage.  A
faster but less efficient version is available in the libc sources
(@file{djlsr*.zip}) in the file @file{src/libc/ansi/stdlib/fmalloc.c}.

@subheading Return Value

A pointer to the allocated memory, or @code{NULL} if there isn't enough
free memory to satisfy the request. 

@subheading Portability

@portability ansi, posix

@subheading Example

@example
char *c = (char *)malloc(100);
@end example

@c ----------------------------------------------------------------------

@node free, memory
@subheading Syntax

@example
#include <stdlib.h>

void free(void *ptr);
@end example

@subheading Description

Returns the allocated memory to the heap (@pxref{malloc}).  If the
@var{ptr} is @code{NULL}, @code{free} does nothing. 

@subheading Return Value

None.

@subheading Portability

@portability ansi, posix

@subheading Example

@example
char *q = (char *)malloc(20);
free(q);
@end example

@c ----------------------------------------------------------------------

@node realloc, memory
@subheading Syntax

@example
#include <stdlib.h>

void *realloc(void *ptr, size_t size);
@end example

@subheading Description

This function changes the size of the region pointed to by @var{ptr}. 
If it can, it will reuse the same memory space, but it may have to
allocate a new memory space to satisfy the request.  In either case, it
will return the pointer that you should use to refer to the (possibly
new) memory area.  The pointer passed may be @code{NULL}, in which case
this function acts just like @code{malloc} (@pxref{malloc}).

An application that wants to be robust in the face of a possible failure
of @code{realloc} to enlarge a buffer should save a copy of the old
pointer in a local variable, to be able to use the original buffer in
case @code{realloc} returns @code{NULL}.  See the example below for
details.

@subheading Return Value

On success, a pointer is returned to the memory you should now refer
to.  On failure, @code{NULL} is returned and the memory pointed to by
@var{ptr} prior to the call is not freed.

@subheading Portability

@portability ansi, posix

@subheading Example

@example
if (now+new > max)
@{
  char *old = p;

  max = now+new;
  p = realloc(p, max);
  if (p == NULL)
    p = old;  /* retain the old pointer */
@}
@end example

