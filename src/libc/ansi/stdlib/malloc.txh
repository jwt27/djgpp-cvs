@node malloc, memory
@findex malloc
@subheading Syntax

@example
#include <stdlib.h>

void *malloc(size_t size);
@end example

@subheading Description

This function allocates a chunk of memory from the heap large enough to
hold any object that is @var{size} bytes in length.  This memory must be
returned to the heap with @code{free} (@pxref{free}). 

Note: this version of malloc is designed to reduce memory usage.  A
faster but less efficient version is available in the libc sources
(@file{djlsr*.zip}) in the file @file{src/libc/ansi/stdlib/fmalloc.c}.

@subheading Return Value

A pointer to the allocated memory, or @code{NULL} if there isn't enough
free memory to satisfy the request. 

@subheading Portability

@portability ansi, posix

@subheading Example

@example
char *c = (char *)malloc(100);
@end example

@c ----------------------------------------------------------------------

@node free, memory
@findex free
@subheading Syntax

@example
#include <stdlib.h>

void free(void *ptr);
@end example

@subheading Description

Returns the allocated memory to the heap (@pxref{malloc}).  If the
@var{ptr} is @code{NULL}, @code{free} does nothing. 

@subheading Return Value

None.

@subheading Portability

@portability ansi, posix

@subheading Example

@example
char *q = (char *)malloc(20);
free(q);
@end example

@c ----------------------------------------------------------------------

@node realloc, memory
@findex realloc
@subheading Syntax

@example
#include <stdlib.h>

void *realloc(void *ptr, size_t size);
@end example

@subheading Description

This function changes the size of the region pointed to by @var{ptr}. 
If it can, it will reuse the same memory space, but it may have to
allocate a new memory space to satisfy the request.  In either case, it
will return the pointer that you should use to refer to the (possibly
new) memory area.  The pointer passed may be @code{NULL}, in which case
this function acts just like @code{malloc} (@pxref{malloc}).

An application that wants to be robust in the face of a possible failure
of @code{realloc} to enlarge a buffer should save a copy of the old
pointer in a local variable, to be able to use the original buffer in
case @code{realloc} returns @code{NULL}.  See the example below for
details.

@subheading Return Value

On success, a pointer is returned to the memory you should now refer
to.  On failure, @code{NULL} is returned and the memory pointed to by
@var{ptr} prior to the call is not freed.

@subheading Portability

@portability ansi, posix

@subheading Example

@example
if (now+new > max)
@{
  char *old = p;

  max = now+new;
  p = realloc(p, max);
  if (p == NULL)
    p = old;  /* retain the old pointer */
@}
@end example

@c ----------------------------------------------------------------------

@node mallinfo, memory
@findex mallinfo
@tindex mallinfo@r{ structure}
@subheading Syntax

@example
#include <stdlib.h>

struct mallinfo mallinfo(void);
@end example

@subheading Description

This function returns information about heap space usage.  It is
intended to be used for debugging dynamic memory allocation and tracking
heap usage.  The @code{struct mallinfo} structure is defined by
@file{stdlib.h} as follows:

@example
 struct mallinfo @{
   int arena;
   int ordblks;
   int smblks;
   int hblks;
   int hblkhd;
   int usmblks;
   int fsmblks;
   int uordblks;
   int fordblks;
   int keepcost;
 @};
@end example

@noindent
whose members are:

@table @code
@item arena
The total amount of space, in bytes, handed by @code{sbrk} to
@code{malloc}.  Note that this is not the same as @code{sbrk(0)}, since
@code{sbrk} allocates memory in large chunks and then subdivides them
and passes them to @code{malloc} as required.  In particular, the result
of @code{sbrk(0)} might be much larger than the @code{arena} member of
@code{struct mallinfo} when the DPMI host allocates memory in
non-contiguous regions (happens on MS-Windows).

@item ordblks
The number of ``ordinary blocks'': the total number of allocated and
free blocks maintained by @code{malloc}.

@item smblks
The number of ``small blocks''.  This is normally zero, unless
@code{malloc} was compiled with the symbol @code{NUMSMALL} defined to a
non-zero value.  Doing so activates an optional algorithm which serves
small allocations quickly from a special pool.  If this option is
activated, the @code{smblks} member returns the number of free small
blocks (the allocated small blocks are included in the value of
@code{ordblks}).

@item hblks
@itemx hblkhd
Always zero, kept for compatibility with other systems.

@item usmblks
The space (in bytes) in ``small blocks'' that are in use.  This is
always zero in the DJGPP implementation.

@item fsmblks
The space in free ``small blocks''.  Non-zero only of @code{malloc} was
compiled with @code{NUMSMALL} defined to a non-zero value.  In that
case, gives the amount of space in bytes in free small blocks.

@item uordblks
The amount of space, in bytes, in the heap space currently used by the
application.  This does not include the small overhead (8 bytes per
block) used by @code{malloc} to maintain its hidden information in each
allocated block.

@item fordblks
The amount of free heap space maintained by @code{malloc} in its free
list.

@item keepcost
Always zero, kept for compatibility.
@end table

@subheading Return Value

The @code{mallinfo} structure filled with information.

@subheading Portability

@port-note posix This function is available on many Unix systems.
@portability !ansi, !posix

@subheading Example

@example
 struct mallinfo info = mallinfo();

 printf("Memory in use: %d bytes\n",
        info.usmblks + info.uordblks);
 printf("Total heap size: %d bytes\n", info.arena);
@end example

@c ----------------------------------------------------------------------

@node malloc_verify, memory
@findex malloc_verify
@subheading Syntax

@example
#include <stdlib.h>

int malloc_verify(void);
@end example

@subheading Description

This function attempts to determine if the heap has been corrupted.  It
scans all the blocks allocated by @code{malloc} and handed to the
application, and also all the free blocks maintained by @code{malloc}
and @code{free} in the internal free list.  Each block is checked for
consistency of the hidden bookkeeping information recorded in it by
@code{malloc} and @code{free}.  The blocks on the free list are
additionally validated by chasing all the @code{next} pointers in the
linked list and checking them against limits for valid pointers (between
0x1000 and the data segment limit), and the alignment.  (Unaligned
pointers are probably corrupted, since @code{malloc} always returns a
properly aligned storage.)

What happens when a bad block is found depends on the current
@dfn{malloc diagnostics level}: for example, the block can be reported,
or the program may be aborted.  @xref{malloc_debug}, for the details.

@subheading Return Value

If the program isn't aborted during the function's run (this depends on
the current diagnostics level), @code{malloc_verify} returns 1 if the
heap passes all tests, or zero of some of the tests failed.

@subheading Portability

@port-note posix This function is available on many Unix systems.
@portability !ansi, !posix

@subheading Example

@example
 if (malloc_verify() == 0)
   printf ("Heap corruption detected!\n");
@end example

@c ----------------------------------------------------------------------

@node malloc_debug, memory
@findex malloc_debug
@subheading Syntax

@example
#include <stdlib.h>

int malloc_debug(int level);
@end example

@subheading Description

This function sets the level of error diagnosis and reporting during
subsequent calls to @code{malloc}, @code{free}, @code{realloc}, and all
functions which call them internally.  The argument @var{level} is
interpreted as follows:

@table @asis
@item Level 0
No checking; the memory allocation functions behave as they do if
@code{malloc_debug} was never called.  Memory in use by the application
which was allocated while level 0 was in effect cannot be checked by
@code{malloc_verify} unless it is @code{free}d first.

@item Level 1
Each one of the allocated blocks is recorded in a special structure,
where @code{malloc_verify} can test them for corruption, even if these
blocks were not yet @code{free}d.  If errors are detected by
@code{malloc_verify}, it prints diagnostic messages to the standard
error stream, with address and size of the offending block and other
pertinent information.  This level slows down memory allocation to some
extent due to additional overhead of calling special functions which
record extra debugging info.

@item Level 2
Like level 1, but in addition the consistency of the entire heap is
verified (by calling @code{malloc_verify}) on every call to the memory
allocation functions.  @emph{Warning: this may significantly slow down
the application.}

@item Level 3
Like level 2, except that the program is aborted whenever a heap
corruption is detected.  In addition, failed allocations (i.e.@: when
@code{malloc} returns @code{NULL} because it cannot satisfy a request)
are reported to standard error.  Also, if the storage where allocated
blocks are recorded is exhausted, a message to that effect is printed.

@item Level 4
Like level 3, but calls to @code{free} with a @code{NULL} pointer as an
argument are also reported.
@end table

When @code{malloc_debug} is first called with a positive argument, it
allocates storage for recording blocks in use.  To avoid reentrancy
problems, this storage is allocated via a direct call to @code{sbrk},
and its size is fixed.  The size used to allocate this storage is by
default 400KB, which is enough to record 100 thousand allocated blocks.
You can tailor the size to your needs by setting the environment
variable @code{MALLOC_DEBUG} to the maximum number of blocks you want to
be able to track.  (The value of @code{MALLOC_DEBUG} should only be as
large as the maximum number of allocations which is expected to be in
use at any given time, because when a buffer is freed, it is removed
from this storage and its cell can be reused for another allocation.)
Note that the larger this storage size, the more slow-down will your
program experience when the diagnostic level is set to a non-zero value,
since the debugging code needs to search the list of recorded blocks in
use each time you call @code{malloc} or @code{free}.

@subheading Return Value

@code{malloc_debug} returns the previous error diagnostic level.  The
default level is 0.

@subheading Portability

@port-note posix This function is available on many Unix systems.
@portability !ansi, !posix

@subheading Example

@example
 malloc_debug(2);
 ...
 malloc_verify();
@end example

@c ----------------------------------------------------------------------

@node mallocmap, memory
@findex mallocmap
@subheading Syntax

@example
#include <stdlib.h>

void mallocmap(int level);
@end example

@subheading Description

This function prints a map of the heap storage to standard output.  For
each block, its address and size are printed, as well as an indication
whether it is free or in use.  If the @dfn{slop} (a special free block
cached for performance reasons) and the small blocks are available, they
are printed as well (these two are variants of free blocks).  Blocks in
use will only be printed if the diagnostic level was set to a non-zero
value by a call to @code{malloc_debug} (@pxref{malloc_debug}), since
otherwise the allocated blocks are not recorded by @code{malloc}.

@subheading Return Value

None.

@subheading Portability

@port-note posix This function is available on many Unix systems.
@portability !ansi, !posix

@c ----------------------------------------------------------------------

@node malloc hook functions, memory
@vindex __libc_malloc_hook
@vindex __libc_malloc_fail_hook
@vindex __libc_free_hook
@vindex __libc_free_null_hook
@vindex __libc_realloc_hook
@subheading Syntax

@example
#include <stdlib.h>
#include <libc/malloc.h>

void (*__libc_malloc_hook)(size_t size, void *block);
void (*__libc_malloc_fail_hook)(size_t size);
void (*__libc_free_hook)(void *block);
void (*__libc_free_null_hook)(void);
void (*__libc_realloc_hook)(void *block, size_t size);
@end example

@subheading Description

These hooks are provided for building custom @code{malloc} debugging
packages.  Such packages typically need to be notified when memory is
allocated and freed by the application, in order to be able to find
memory leaks, code that writes beyond the limits of allocated buffers or
attempts to free buffers which were not allocated by @code{malloc}, etc.
These hooks can be used to define callback functions which will be
called by the library at strategic points.  Each callback is only called
if it is non-@code{NULL}; by default, all of them are initialized to a
@code{NULL} value.

@table @code
@item __libc_malloc_hook
Called just before a chunk of memory is about to be returned to the
application in response to an allocation request.  @var{size} is the
size requested by the application (@strong{not} the actual size of the
allocated buffer, which may be larger).  @var{block} is a pointer to the
block that was allocated, which is 4 bytes before the pointer that
@code{malloc} will return to the application; these 4 bytes are used to
record the actual size of the buffer.  An additional copy of the block's
size is recorded immediately after the buffer's end.  Thus,
@w{@code{*(size_t *)((char *)block + 4 + (BLOCK *)block->size)}} gives
the second copy of the block's size.

@item __libc_malloc_fail_hook
Called if @code{malloc} failed to find a free block large enough to
satisfy a request, and also failed to obtain additional memory from
@code{sbrk}.  @var{size} is the requested allocation size.

@item __libc_free_hook
Called when a buffer is about to be freed.  @var{block} is a pointer 4
bytes before the address passed to @code{free} by the application,
i.e.@: it is a pointer to the beginning of the size information
maintained before the user buffer.

@item __libc_free_null_hook
Called whenever a @code{NULL} pointer is passed to @code{free}.
@acronym{ANSI} C specifically rules that this is allowed and should have
no effect, but you might want to catch such cases if your program needs
to be portable to old compilers whose libraries don't like @code{NULL}
pointers in @code{free}.

@item __libc_realloc_hook
Called at entry to @code{realloc}, before the actual reallocation.
@var{block} is a pointer 4 bytes before the address passed to
@code{free} by the application, i.e.@: it is a pointer to the beginning
of the size information maintained before the user buffer.  @var{size}
is the new size requested by the application.  (This hook is called
@emph{in addition} to the other hooks which will be called by
@code{free} and @code{malloc} if and when @code{realloc} calls them.)
@end table

The @code{BLOCK} data type is used by @code{malloc} and @code{free} to
maintain the heap.  The only member which is always guaranteed to be
valid is @code{size} (the additional copy of the size, recorded beyond
the buffer's end, is also guaranteed to be valid).  The @code{next}
member is valid in all blocks that are part of the free list.  This
means that @code{__libc_malloc_hook} can use the @code{next} member, but
@code{__libc_free_hook} cannot.

@subheading Portability

@portability !ansi, !posix

These hooks are specific to DJGPP.

