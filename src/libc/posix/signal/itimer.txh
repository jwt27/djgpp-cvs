@node getitimer, process
@subheading Syntax

@example
#include <sys/time.h>

int getitimer(int which, struct itimerval *value);
@end example

@subheading Description

This function gets the current value of the interval timer specified by
@var{which} into structure @var{value}.  Variable @var{which} can have
the value of ITIMER_REAL or ITIMER_PROF. @xref{setitimer}.

@subheading Return Value

Returns 0 on success, -1 on failure (and sets errno).

@subheading Portability

@portability !ansi, !posix

@c ----------------------------------------------------------------------
@node setitimer, process
@subheading Syntax

@example
#include <sys/time.h>

struct itimerval @{
  struct timeval it_interval;    /* timer interval */
  struct timeval it_value;       /* current value */
@};

int setitimer(int which, struct itimerval *value, struct itimerval *ovalue);
@end example

@subheading Description

Each process has two interval timers, @code{ITIMER_REAL} and
@code{ITIMER_PROF}, which signal @code{SIGALRM} and @code{SIGPROF}
respectively.  These are typically used to provide @code{alarm()} and
profiling capabilities.

This function changes the current value of the interval timer specified by
@var{which} to the values in structure @var{value}.  The previous value
of the timer is returned if @var{ovalue} is not NULL.  When the timer
expires the appropriate signal is raised.

A timer is defined by the @code{itimerval} structure.  If its
@code{it_value} member is non-zero, it specifies the time to the next
timer expiration.  If the @code{it_interval} member is non-zero, it
specifies the value to reload into the @code{it_value} member on timer
expiration.  Setting @code{it_value} to zero disables a timer.  Setting
@code{it_interval} to zero causes the timer to only happen once instead
of repeating.

Although times can be given with microsecond resolution, the granularity is
determined by the timer interrupt frequency (usually, 18.2 times a second).

@subheading Return Value

Returns 0 on success, -1 on failure (and sets errno).

@subheading Portability

@portability !ansi, !posix

@subheading Bugs

This version uses @code{uclock} (@pxref{uclock}) to determine the time
of expiration.  Under Windows 9X, @code{uclock} sometimes reports
erratic (non-increasing) time values because the OS reprograms the
timer; in these cases the timer might fire at a wrong time.  Also, some
versions of debuggers cannot cope with hardware interrupts and report
@code{SIGSEGV} or @code{SIGABRT}.

A misfeature of Windows 9X prevents the timer tick interrupt from being
delivered to programs that are in the background (i.e. don't have the
focus), even though the program itself might continue to run, if you
uncheck the @cite{Background: Always suspend} property in the Property
Sheets.  Therefore, the timers will not work in background programs on
Windows 9X.
