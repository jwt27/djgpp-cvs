\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename ../../info/utils.inf
@settitle DJGPP Utilities Reference
@c %**end of header

@setchapternewpage odd
@paragraphindent 0

@ifinfo
This is the reference manual for DJGPP V2's miscellaneous utilities

Copyright (c) 1995 DJ Delorie
@end ifinfo

@titlepage
@sp 10
@comment The title is printed in a large font.
@center @titlefont{DJGPP Utilities Reference}

@vskip 0pt plus 1filll
Copyright @copyright{} 1995 DJ Delorie (dj@delorie.com)
@end titlepage

@c -----------------------------------------------------------------------------
@node Top,,,(dir)
@comment node, next, previous, up

This is the reference manual for the miscellaneous utility programs that
come with DJGPP.

@menu

* bin2h::       Convert binary data files to C include files.

* djtar::       Extract or list files from (possibly compressed)
		tar archives, with DOS filename conversion.

* dtou::        Convert text files from dos to unix.
* utod::        Convert text files from unix to dos.

* echo::        Echo long command lines to files.

* gxx::         Build and link C++ programs

* redir::       Manage I/O Redirection.

* split::       split large files into multiple files.
* merge::       Merge multiple files into one file.

* texi2ps::     Convert texinfo files to Postscript.

* update::      conditionally copy one file to another.

@end menu

@c -----------------------------------------------------------------------------
@node bin2h,djtar,,Top
@chapter bin2h

@code{bin2h} allows a developer to embed a binary file into a source
file, bu converting the binary data to an array of integer values.

Usage: @code{bin2h} @file{datafile} @var{symbol} @file{headerfile}

The resulting header file has a format like this:

@example
unsigned char symbol[] = @{
  ... data ...
@};
@end example

@c -----------------------------------------------------------------------------
@node djtar, dtou, bin2h, Top
@chapter djtar

Usage: @code{djtar} [@code{-n} @file{changeFile}] [@code{-o} @file{dir}]
[@code{-t}|@code{-x}] [@code{-i}] [@code{-v}] [@code{-p}]
[@code{-.}|@code{-!.}] [@code{-d}|@code{-u}|@code{-b}] @file{tarfile}

@code{djtar} is a program that is designed to ease the problems related
to extracting Unix tar files on a DOS machine.  The long file names and
illegal characters make regular tar programs useless.  What @code{djtar}
does is make some obvious name conversions automatically and give you an
opportunity to provide alternate names for more difficult cases, where
several filenames map to the same name in the restricted 8+3 DOS filename
space.

@code{djtar} can read compressed tar files and decompress them on the
fly.  (This can be also achieved by piping the output of @code{gzip} to
@code{djtar}, but for very large archives you can run out of free disk
space, because DOS implements pipes as temporary disk files.)
@code{djtar} knows about all the compression methods supported by
@code{gzip}, namely, deflation (aka LZ77, either by @code{gzip}, by
@code{zip}, or by @code{pkzip}), LZW compression (by @code{compress}), LZH
compression (as with @code{compress -H} available with some versions of
@code{compress}), or Huffman compression (by @code{pack}).  Tar files
compressed with @code{zip} or @code{pkzip} can be decompressed by
@code{djtar} only if the @file{.zip} file contains a single tar file
compressed with either the @code{deflation} or @code{stored} (i.e.,
uncompressed, like with @samp{pkzip -e0}) methods; if more than a single
tar file was put into a compressed zip file, files beyond the first one
will be ignored by @code{djtar} (a message to this effect will be printed
under @code{-v} option).

@code{djtar} can also read tar archives (compressed or otherwise) written
on a Unix machine to a diskette as a raw device (i.e., without DOS
filesystem).  To use @code{djtar} with such archives, specify a name
of the drive (like @code{A:}) as a tarfile argument.

When extracting files from compressed archives, @code{djtar} will
validate them with whatever reduntant checks are available with the
compression format, and print diagnostic messages whenever these checks
fail.  The checks and the diagnostics are generally identical to those
performed by @code{gzip}.  Some of the diagnostics are only printed under
the verbose operation switched on by the @code{-v} switch.  Unless you use
the @code{-i} switch, @code{djtar} will refuse to create files and
directories beyond the first tar directory entry which fails the checksum
test; this usually means the file is either corrupted or not in a valid
tar format.

An additional bonus of using @code{djtar} is that it can convert
Unix-style text files to DOS-style text files, and vice versa.  By
default, it will write all files exactly as found in the archive, but the
@code{-u} and @code{-d} options can change that.

@code{djtar} performs a number of file name conversions in an attempt
to make the files fit into MS-DOS's restricted file names.  Any file
ending in @file{.info-N} becomes @file{.iN}.  Any file ending in
@file{.tar.gz} becomes @file{.tgz}.  Any file with @file{++} becomes
@file{plus}.  Any leading dots are changed to underscores (but current
and parent directories, @file{./} and @file{../} are left alone).  Any
remaining multiple dots are changed to dashes, unless the part before the
dot is shorter than 3 characters and there are more than 1 dot in the
filename, in which case the dot also becomes an underscore.  As a result,
e.g., @file{.foo.a.b} becomes @file{_foo.a-b}, and @file{sh.lex.c} becomes
@file{sh_lex.c}.

While @code{djtar} is running, if it cannot successfully perform an
exclusive open of the given file (it will refuse to overwrite an
existing file), it will prompt you for a new name.  You may type in
either a complete path, a replacement file name (no directory part), or
just hit return (the file is skipped).

If @code{djtar} is called as @code{djtart}, it behaves as if it were
called with the @code{-t} switch; when called as @code{djtarx}, it
behaves like @code{djtar -x}.  Thus you can create 2 links to
@file{djtar.exe} which will save you some typing.

By default, @code{djtar} just lists the contents of the archive(s)
given as its arguments.  If you want to extract files, you must use
the @code{-x} option.

@strong{Options:}

@table @code

@item -x

By default, @code{djtar} just lists the contents of the archive(s)
given as its arguments.  If you want to extract files, you must use
this option, or call @code{djtar} via a link named @code{djtarx}.

@item -t

This option causes @code{djtar} to only print the contents of the tar
file, without actually creating any files.  All the decompression, CRC
checks etc. are still performed; thus, this option can also be used to
test archive integrity.  This is the default behavior of
@code{djtar}, unless you call it via a link named @code{djtarx}.

@item -v

This option modifies the output format slightly to aid in debugging tar
file problems.  It also causes @code{djtar} to emit more verbose warning
messages and print the compression method for compressed archices.

@item -.

Enable the automatic conversion of dots to underscores and dashes.  This
is the default.

@item -!.

Disable the conversion of dots.  You get the control of file renaming when
names of several files clash.

@item -n @file{changeFile}

This option allows you to specify a list of filename conversions ahead of
time.  Thus, you can use @code{djtart} or @code{djtar -t} to list the
files, figure out the new names with your favorite editor, and supply that
file to @code{djtar}.  This way, you have the fullest possible control on
how the extracted files will be named on your system.

The format of the @file{changeFile} file is like this:

@example
dir/dir/dir/old.name.here  dir/dir/dir/newname.hre
dir/dir/dir/old2.name.here  dir/dir/dir/newname2.hre
@end example

The directories must be complete, not relative.  The "old" directories
must match the complete path in the tar file, and the "new" directories
indicate where the file goes on the DOS disk.

@item -d

Convert all text files to DOS text format on output.  This won't usually
affect binary files, but as @code{djtar} detects the file type by looking
at its first 512 bytes, a small possibility of a binary file rendered
useless by this conversion still exists, so you're advised to only use
this option with archives of text files.

By default, @code{djtar} writes all files exactly as it finds them.

@item -u

Convert all text files to UNIX text format on output.  This won't usually
affect binary files, but as @code{djtar} detects the file type by looking
at its first 512 bytes, a small possibility of a binary file rendered
useless by this conversion still exists, so you're advised to only use
this option with archives of text files.

By default, @code{djtar} writes all files exactly as it finds them.

@item -b

Write all files exactly as found in the archive.  This is the default.
Files written to the console (when @code{-p} is in effect) are always
written in text mode, so this option doesn't have any effect when used
with @code{-p}, unless the output of @code{djtar} is redirected to a file
or a pipe.

@item -o @file{dir}

Only extract files which are children of the given directory @file{dir}.
This option can be used to extract portions of archive.  Files which aren't
extracted will still be shown, but with a string @code{[ skipped ]}
appended to their names.  When given the @code{-o} option, @code{djtar}
actually checks if @file{dir} is contained in filenames as a substring, so
you can specify incomplete directory names, thus using it as a poor man's
wildcard facility.

@item -i

By default, @code{djtar} will refuse to create files whose directory
entries in the tar archive fail the checksum test, and any files beyond
that point.  This option tells @code{djtar} to ignore the checksum test
and proceed anyway.  Checksum failure usually means that the tar file is
either corrupted or not in valid tar format, so this option is meant to be
used either with the @code{-t} option, or in the rare cases when you
@emph{know} for sure the tar file is valid (like if you had to edit it to
change the filenames).

@item -p

When given this switch, @code{djtar} will write the files to its standard
output, which can be piped into another program (like a pager) or
redirected to a file.  This option is designed to allow you to view or
extract individual files (e.g., the @code{README} files) without having to
open the entire archive, and should be used with an appropriate @code{-o
filename} option.

When this option is used, diagnostic messages will be directed to the
standard error stream (as opposed to standard output in normal operation),
so that they won't get mixed with the files' data.

@end table

@c -----------------------------------------------------------------------------
@node dtou, utod, djtar, Top
@chapter dtou

Each file specified on the command line is converted from dos's CR/LF
text file mode to unix's NL text file mode.

All djgpp wildcards are supported.  Timestamps of the files are preserved.

@c -----------------------------------------------------------------------------
@node utod, echo, dtou, Top
@chapter utod

Each file specified on the command line is converted from unix's NL text
file mode to dos's CR/LF text file mode.

All djgpp wildcards are supported.  Timestamps of the files are preserved.

@c -----------------------------------------------------------------------------
@node echo, gxx, utod, Top
@chapter echo

This program simply echos whatever is given to it on the command line.

Usage: @code{echo} [@code{-n}] [@code{-o} @var{file}] stuff . . .

@table @code

@item -n

Do not emit the trailing newline after printing the text.

@item -o @var{file}

Send output to a @var{file}.

@end table

The purpose of this program is to be able to interact directly with
@code{make}'s ability to pass long command lines to programs.  If you
use redirection, you aren't always able to handle long command lines.
With @code{echo}, you can, and you can use the @code{-o} option to
redirect output to a file (and use the file later as a response file)
without using dos's redirection.

@c -----------------------------------------------------------------------------
@node gxx, redir, echo, Top
@chapter gxx

This program is exactly like @code{gcc} (in fact, it @i{calls} gcc), except
that it provides the extra libraries required to link most C++ programs,
including the iostreams, stdc, and libg++ libraries.

@c -----------------------------------------------------------------------------
@node    redir, split, gxx, Top
@chapter redir

DOS, in its many flavors and versions, lacks a decent I/O redirection
mechanism.  Sure, it's got < and > and >>, but what about error
messages?  Lots of people ask, ``How do you send those error messages
to a file?''  Well, you use a program like @code{redir}.

@code{redir} is basically a program that manipulates the standard file
descriptors by copying them, closing and opening them, etc.  Once it
has the file descriptors where it wants them, it runs your program,
which inherits the changed descriptors.  Thus, @code{redir} has nearly
complete control over the input and output of your program.

It also allows you to view the exit code of the program, and the
elapsed time of the program, by supplying the appropriate options on
the command line.

Note that @code{redir} is built with command-line expansion and response files
disabled, so as to allow the application to control that themselves.
This means that you can't use those features to provide @code{redir}'s options
or the command name, but if you use them for the command's options, the
command will do the expansion if it wants to.

The exit code of @code{redir} is 1 if it exits on its own accord, else it
returns the same error code as the program it runs.

Usage: @code{redir} [@code{-i} @var{file}] [@code{-o} @var{file}]
[@code{-oa} @var{file}] [@code{-e} @var{file}] [@code{-ea} @var{file}]
[@code{-eo}] [@code{-oe}] [@code{-x}] [@code{-t}] @var{command}
[@var{args} . . .]

@table @code

@item -i @var{file}
Redirect stdandard input from file

@item -o @var{file}
Redirect standard output to file

@item -oa @var{file}
Append standard output to file

@item -e @var{file}
Redirect standard error to file

@item -ea @var{file}
Append standard error to file

@item -eo
Redirect standard error to standard output

@item -oe
Redirect standard output to standard error

@item -x
Print the exit code of the command after it exits.  If the exit code is
0..255, it is printed as is.  If it is not, the low byte (0..255) is
printed in decimal and the whole value is also printed in hex.

@item -t
Print elapsed time, either in seconds (for short runs) or
hours:minutes:seconds.

@end table

Options are processed in the order they are encountered.  Thus, "-o foo
-eo" means "redirect output to foo, then redirect errors there also",
whereas "-eo -o foo" means "send errors to where output was going, then
move output to foo".


Examples:

To redirect errors to a file:

@example
redir -e errors.lst command ...
@end example

To redirect output to a file, and errors through a pipe:

@example
redir -eo -o prog.out command ... | pipe
@end example

@c -----------------------------------------------------------------------------
@node split, merge, redir, Top
@chapter split

The @code{split} and @code{merge} programs are designed to assist in
transporting files across unreliable channels or small media (like
floppies).  @code{split} takes a big file and splits it into up to 1000
smaller files.  @code{merge} puts them back together again.

Usage: @code{split} @var{inputfile} @var{chunksize} @var{outputbase}

Each output file is made from appending a sequence number to
@var{outputbase}.  For example:

@example
split foo.tgz 1300k footgz
@end example

would result in @code{footgz.000}, @code{footgz.001}, etc.

The @code{chunksize} parameter can be expressed as bytes (NNN),
kilobytes(NNNk) or megabytes (NNNm).

@c -----------------------------------------------------------------------------
@node merge, texi2ps, split, Top
@chapter merge

The @code{split} and @code{merge} programs are designed to assist in
transporting files across unreliable channels or small media (like
floppies).  @code{split} takes a big file and splits it into up to 1000
smaller files.  @code{merge} puts them back together again.

Usage: @code{split} @var{inputbase} @var{outputfile}

Each input file is made from appending a sequence number to
@var{inputbase}.  For example, given @code{footgz.000},
@code{footgz.001}, etc,

@example
merge footgz foo.tgz
@end example

would result in @code{foo.tgz} being created.

@c -----------------------------------------------------------------------------
@node texi2ps, update, merge, Top
@chapter texi2ps

@code{texi2ps} is a modified version of @code{makeinfo} that quickly turns
texinfo files (such as info files are generated from) into crude
Postscript files, ready for printing.  The program is designed to
produce a crude page, so please don't complain if the printed copy looks
ugly.  If you want clean pages, get and install TeX and print it with
that.  It will produce a much cleaner print.  I'm also pretty sure that
texi2ps won't support 100% of the texinfo documents out there.  Again,
if you want it right use TeX.

Note that the input files are @i{texinfo} files, not TeX or LaTeX or
info files.  In normal djgpp distributions, the texinfo files are part
of the source distributions, and the info files are in the binary
distributions.

The default settings produce a pretty densely packed page - small font,
small margins.  You can set the margins and font even smaller to save on
paper, or make them bigger for more conventional manuals.

Usage: @code{texi2ps} [@code{-f} @var{size}] [@code{-I} @var{dir}]
[@code{-I}@var{dir}] [@code{-v}] [@code{-m} @var{pts}] @var{file}

@table @code

@item -f @var{size}

The font size, in points.  The default is 10 points.

@item -I @var{path}

Specifies an additional path to search for include files.

@item -v

Print verbose messages about files read, nodes encountered, and pages
generated.

@item -m @var{pts}

Set the margin size in points.  The default is 54 points, or 3/4 inches
(72 points = 1 inch).

@end table

Note that the Postscript file is sent to standard output, so you must
redirect the output to a file or a printer.

@c -----------------------------------------------------------------------------
@node update, , texi2ps, Top
@chapter update

@code{update} is a fancy copy-if-needed program.  Basically, it compares
the two files you give it, and if they differ, copies one to the other.
This is useful in makefiles where a file is generated often, but its
contents changes rarely, and other files depend on it.  For example,
@code{bison} emits a header file each time it parses the grammar.  The
header rarely changes, but the grammar changes often.  So, you use
@code{update} to copy the header to its real name only when it changes,
and everything else won't need to be recompiled each time.

Usage: @code{update} @var{new_file} @var{copied_to}

Example:

@example
foo.c foo.h : foo.y
        bison foo.y
        update y_tab.h foo.h
        update y_tab.c foo.c
@end example

@bye
