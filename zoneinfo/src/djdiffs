2013-02-15  Juan Manuel Guerrero <juan.guerrero@gmx.de>

	* djgpp/zoneinfo/src/date.c:  Fix warning: function declaration isn't
	a prototype [-Wstrict-prototypes].


2012-11-24  Juan Manuel Guerrero <juan.guerrero@gmx.de>

	* djgpp/distrib/p/djtzn204/djtzn204.dsm:  Update author-email and
	author-ftp-site.

	* djgpp/distrib/p/djtzs204/djtzs204.dsm:  Update author-email and
	author-ftp-site.

	* djgpp/distrib/p/djtzn204/files:  Man pages will be stored in
	/share/man/manN.

	* djgpp/zoneinfo/src/asctime.c [!__DJGPP__]:  Use DJGPP's libc
	implementations of asctime and asctime_r.

	* djgpp/zoneinfo/src/date.c [OLD_TIME]:  Only if OLD_TIME defined
	include utmp.h.
	[__MSDOS__]:  For MSDOS do not declare and do not define oops().
	(main):  Cast variable to time_t.
	[TSP_SETDATE]:  Only if TSP_SETDATE defined include syslog.h,
	sys/socket.h, netinet/in.h, netdb.h and protocols/timed.h and
	define TSPTYPES.
	(reset) [__MSDOS__]:  MSDOS does not support TSP_SETDATE.
	Fix -Wunused-but-set-variable.
	(convert):  Cast variable to time_t.
	(display):  Use ATTRIBUTE_NORETURN macro.
	(iffy):  Use ATTRIBUTE_NORETURN macro.
	(usage):  Use ATTRIBUTE_NORETURN macro.
	(nondigit):  Use ATTRIBUTE_PURE macro.
	(main):  Fix -Wunused-but-set-variable.

	* djgpp/zoneinfo/src/localtime.c:  Define IS_SLASH and IS_ABSOLUTE
	for portable testing of absolute file names.
	(tzload):  Use IS_ABSOLUTE for portable testing of absolute file
	names.
	[WRONG]:  Cast variable to time_t.
	[!__DJGPP__]:  Use DJGPP's own libc implementations of localtime,
	localtime_r, gmtime, gmtime_r, ctime, ctime_r and mktime.

	* djgpp/zoneinfo/src/private.h [STD_INSPIRED]:  Provide function
	declarations.
	[__MSDOS__]:  Define IS_SLASH(c), HAS_DEVICE, IS_ABSOLUTE and
	TZDIR macros.
	[__GNUC__, __GNUC_MINOR__]:  Define ATTRIBUTE_NORETURN macro.

	* djgpp/zoneinfo/src/zdump.c [__GNUC__, __GNUC_MINOR__]:  Define
	ATTRIBUTE_NORETURN macro.
	(show) [TM_GMTOFF]:  Cast variable to long.
	(usage):  Use ATTRIBUTE_NORETURN macro.

	* djgpp/zoneinfo/src/zic.c [HAVE_SYS_WAIT_H]:  Include sys/wait.h
	and define WEXITSTATUS if not defined.
	[IS_SLASH, IS_ABSOLUTE]:  If not defined define them.
	(dolink):  Use IS_ABSOLUTE for portable testing of absolute file
	names.  Replace '+' by '%' in file names or directory names.
	(itsdir) [D_OK]:  On MSDOS/WINDOWS use access() to check if it is
	a directory.
	(writezone):  Replace '+' by '%' in file names or directory names.
	(mkdirs):  Use HAS_DEVICE and IS_SLASH to handle directory creationg
	in a portable way.

	* djgpp/zoneinfo/src/makefile:  Support building with gcc 3.4.4 and
	from gcc 4.0.0 up to gcc 4.7.2.
	Install man pages into /share/man/manN.






diff -aprNU5 djgpp.orig/distrib/p/djtzn204/djtzn204.dsm djgpp/distrib/p/djtzn204/djtzn204.dsm
--- djgpp.orig/distrib/p/djtzn204/djtzn204.dsm	2003-11-23 21:26:10 +0000
+++ djgpp/distrib/p/djtzn204/djtzn204.dsm	2012-12-08 05:39:06 +0000
@@ -19,12 +19,12 @@ license: Various: public domain, BSD
 web-site: http://www.delorie.com/djgpp/
 newsgroup: comp.os.msdos.djgpp
 newsgroup-email-gateway: djgpp@delorie.com
 
 author: The Timezone Caballeros
-author-email: tz@elsie.nci.nih.gov
-author-ftp-site: ftp://elsie.nci.nih.gov/pub/
+author-email: tz@iana.org
+author-ftp-site: 'ftp://ftp.iana.org/tz/
 
 simtelnet-path: v2/
 zip: djtzn204.zip
 
 replaces: djtzn < 2.04 beta 1
diff -aprNU5 djgpp.orig/distrib/p/djtzn204/files djgpp/distrib/p/djtzn204/files
--- djgpp.orig/distrib/p/djtzn204/files	2003-02-04 19:08:18 +0000
+++ djgpp/distrib/p/djtzn204/files	2012-12-08 05:39:06 +0000
@@ -1,14 +1,14 @@
 etc/date.exe
 etc/tzselect
 etc/zdump.exe
 etc/zic.exe
-info/date.1
-info/newctime.3
-info/newtzset.3
-info/time2posix.3
-info/tzfile.5
-info/tzselect.8
-info/zdump.8
-info/zic.8
+share/man/man1/date.1
+share/man/man3/newctime.3
+share/man/man3/newtzset.3
+share/man/man3/time2posix.3
+share/man/man5/tzfile.5
+share/man/man8/tzselect.8
+share/man/man8/zdump.8
+share/man/man8/zic.8
 lib/libtz.a
 zoneinfo
diff -aprNU5 djgpp.orig/distrib/p/djtzs204/djtzs204.dsm djgpp/distrib/p/djtzs204/djtzs204.dsm
--- djgpp.orig/distrib/p/djtzs204/djtzs204.dsm	2003-11-23 21:26:10 +0000
+++ djgpp/distrib/p/djtzs204/djtzs204.dsm	2012-12-08 05:39:06 +0000
@@ -19,12 +19,12 @@ license: Various: public domain, BSD
 web-site: http://www.delorie.com/djgpp/
 newsgroup: comp.os.msdos.djgpp
 newsgroup-email-gateway: djgpp@delorie.com
 
 author: The Timezone Caballeros
-author-email: tz@elsie.nci.nih.gov
-author-ftp-site: ftp://elsie.nci.nih.gov/pub/
+author-email: tz@iana.org
+author-ftp-site: 'ftp://ftp.iana.org/tz/
 
 simtelnet-path: v2/
 zip: djtzs204.zip
 
 replaces: djtzs < 2.04 beta 1
diff -aprNU5 djgpp.orig/zoneinfo/src/asctime.c djgpp/zoneinfo/src/asctime.c
--- djgpp.orig/zoneinfo/src/asctime.c	2012-12-08 05:33:24 +0000
+++ djgpp/zoneinfo/src/asctime.c	2012-12-08 05:39:06 +0000
@@ -1,5 +1,9 @@
+#ifndef __DJGPP__
+/*  Use DJGPP's own implementation of asctime and asctime_r.  */
+
+
 /*
 ** This file is in the public domain, so clarified as of
 ** 1996-06-05 by Arthur David Olson.
 */
 
@@ -128,5 +132,6 @@ asctime_r(register const struct tm *time
 char *
 asctime(register const struct tm *timeptr)
 {
 	return asctime_r(timeptr, buf_asctime);
 }
+#endif  /* !__DJGPP__ */
diff -aprNU5 djgpp.orig/zoneinfo/src/date.c djgpp/zoneinfo/src/date.c
--- djgpp.orig/zoneinfo/src/date.c	2012-12-08 05:33:24 +0000
+++ djgpp/zoneinfo/src/date.c	2012-12-08 05:39:06 +0000
@@ -28,11 +28,13 @@ static char sccsid[] = "@(#)date.c	4.23
 #include "private.h"
 #if HAVE_ADJTIME || HAVE_SETTIMEOFDAY
 #include "sys/time.h"	/* for struct timeval, struct timezone */
 #endif /* HAVE_ADJTIME || HAVE_SETTIMEOFDAY */
 #include "locale.h"
+#ifdef OLD_TIME
 #include "utmp.h"	/* for OLD_TIME (or its absence) */
+#endif
 #if HAVE_UTMPX_H
 #include "utmpx.h"
 #endif
 
 #ifndef OTIME_MSG
@@ -72,11 +74,13 @@ static void		display(const char *);
 static void		dogmt(void);
 static void		errensure(void);
 static void		iffy(time_t, time_t, const char *, const char *);
 int			main(int, char**);
 static const char *	nondigit(const char *);
+#ifndef __MSDOS__
 static void		oops(const char *);
+#endif
 static void		reset(time_t, int);
 static int		sametm(const struct tm *, const struct tm *);
 static void		timeout(FILE *, const char *, const struct tm *);
 static void		usage(void);
 static void		wildinput(const char *, const char *,
@@ -92,19 +96,23 @@ main(const int argc, char *argv[])
 	register int		dousg;
 	register int		aflag = 0;
 	register int		dflag = 0;
 	register int		nflag = 0;
 	register int		tflag = 0;
+#if HAVE_SETTIMEOFDAY == 2
 	register int		minuteswest;
 	register int		dsttime;
+#endif /* HAVE_SETTIMEOFDAY == 2 */
 	register double		adjust;
 	time_t			now;
 	time_t			t;
 
 	INITIALIZE(dousg);
+#if HAVE_SETTIMEOFDAY == 2
 	INITIALIZE(minuteswest);
 	INITIALIZE(dsttime);
+#endif /* HAVE_SETTIMEOFDAY == 2 */
 	INITIALIZE(adjust);
 	INITIALIZE(t);
 #ifdef LC_ALL
 	(void) setlocale(LC_ALL, "");
 #endif /* defined(LC_ALL) */
@@ -133,11 +141,13 @@ main(const int argc, char *argv[])
 					_("date: error: multiple -d's used"));
 				usage();
 			}
 			dflag = 1;
 			cp = optarg;
+#if HAVE_SETTIMEOFDAY == 2
 			dsttime = atoi(cp);
+#endif /* HAVE_SETTIMEOFDAY == 2 */
 			if (*cp == '\0' || *nondigit(cp) != '\0')
 				wildinput(_("-t value"), optarg,
 					_("must be a non-negative number"));
 			break;
 		case 't':		/* minutes west of UTC */
@@ -146,11 +156,13 @@ main(const int argc, char *argv[])
 					_("date: error: multiple -t's used"));
 				usage();
 			}
 			tflag = 1;
 			cp = optarg;
+#if HAVE_SETTIMEOFDAY == 2
 			minuteswest = atoi(cp);
+#endif /* HAVE_SETTIMEOFDAY == 2 */
 			if (*cp == '+' || *cp == '-')
 				++cp;
 			if (*cp == '\0' || *nondigit(cp) != '\0')
 				wildinput(_("-d value"), optarg,
 					_("must be a number"));
@@ -246,11 +258,11 @@ _("date: error: multiple values in comma
 		tv.tv_usec = (int) ((adjust - tv.tv_sec) * 1000000L);
 		if (adjtime(&tv, NULL) != 0)
 			oops("adjtime");
 #endif /* HAVE_ADJTIME */
 #if !HAVE_ADJTIME
-		reset(now + adjust, nflag);
+		reset(now + (time_t)adjust, nflag);
 #endif /* !HAVE_ADJTIME */
 		/*
 		** Sun silently ignores everything else; we follow suit.
 		*/
 		exit(retval);
@@ -424,16 +436,18 @@ reset(const time_t newt, const int nflag
 #ifndef BSD4_4
 #define TIME_NAME	""
 #endif /* !defined BSD4_4 */
 #endif /* !defined TIME_NAME */
 
+#ifdef TSP_SETDATE
 #include "syslog.h"
 #include "sys/socket.h"
 #include "netinet/in.h"
 #include "netdb.h"
 #define TSPTYPES
 #include "protocols/timed.h"
+#endif /* TSP_SETDATE */
 
 extern int		logwtmp();
 
 #if HAVE_SETTIMEOFDAY == 1
 #define settimeofday(t, tz) (settimeofday)(t)
@@ -448,18 +462,21 @@ static int netsettime(struct timeval);
 #endif /* !defined TSP_SETDATE */
 static void
 reset(const time_t newt, const int nflag)
 {
 	register const char *	username;
+#ifndef __MSDOS__
 	static struct timeval	tv;	/* static so tv_usec is 0 */
+#endif /* !__MSDOS__ */
 
 #ifdef EBUG
 	return;
 #endif /* defined EBUG */
 	username = getlogin();
 	if (username == NULL || *username == '\0') /* single-user or no tty */
 		username = "root";
+#ifndef __MSDOS__
 	tv.tv_sec = newt;
 #ifdef TSP_SETDATE
 	if (nflag || !netsettime(tv))
 #endif /* defined TSP_SETDATE */
 	{
@@ -471,15 +488,16 @@ reset(const time_t newt, const int nflag
 			logwtmp("{", TIME_NAME, "");	/* } */
 			syslog(LOG_AUTH | LOG_NOTICE, _("date set by %s"),
 				username);
 		} else	oops("settimeofday");
 	}
+#endif /* !__MSDOS__ */
 }
 
 #endif /* !defined OLD_TIME */
 
-static void
+static ATTRIBUTE_NORETURN void
 wildinput(const char *const item, const char *const value,
 	  const char *const reason)
 {
 	(void) fprintf(stderr,
 		_("date: error: bad command line %s \"%s\", %s\n"),
@@ -492,27 +510,28 @@ errensure(void)
 {
 	if (retval == EXIT_SUCCESS)
 		retval = EXIT_FAILURE;
 }
 
-static const char *
+static ATTRIBUTE_PURE const char *
 nondigit(register const char *cp)
 {
 	while (is_digit(*cp))
 		++cp;
 	return cp;
 }
 
-static void
+static ATTRIBUTE_NORETURN void
 usage(void)
 {
 	(void) fprintf(stderr, _("date: usage is date [-u] [-c] [-n] [-d dst] \
 [-t min-west] [-a sss.fff] [[yyyy]mmddhhmm[yyyy][.ss]] [+format]\n"));
 	errensure();
 	exit(retval);
 }
 
+#ifndef __MSDOS__
 static void
 oops(const char *const string)
 {
 	int		e = errno;
 
@@ -520,12 +539,13 @@ oops(const char *const string)
 	errno = e;
 	(void) perror(string);
 	errensure();
 	display(NULL);
 }
+#endif /* !__MSDOS__ */
 
-static void
+static ATTRIBUTE_NORETURN void
 display(const char *const format)
 {
 	struct tm	tm;
 	time_t		now;
 
@@ -634,11 +654,11 @@ convert(register const char * const valu
 				_("seconds part is not two digits"));
 		secs = ATOI2(cp);
 	}
 
 	cp = value;
-	switch (dotp - cp) {
+	switch ((int)(dotp - cp)) {
 		default:
 			wildinput(_("time"), value,
 				_("main part is wrong length"));
 		case 12:
 			if (!dousg) {
@@ -685,11 +705,11 @@ convert(register const char * const valu
 	tm.tm_min = mins;
 	tm.tm_sec = secs;
 	tm.tm_isdst = -1;
 	outtm = tm;
 	outt = mktime(&outtm);
-	return sametm(&tm, &outtm) ? outt : -1;
+	return sametm(&tm, &outtm) ? outt : (time_t)-1;
 }
 
 /*
 ** Code from here on out is either based on code provided by UCB
 ** or is only called just before the program exits.
@@ -759,11 +779,11 @@ checkfinal(const char * const	value,
 				iffy(t, othert, value,
 					_("multiple matching times exist"));
 		}
 }
 
-static void
+static ATTRIBUTE_NORETURN void
 iffy(const time_t thist, const time_t thatt,
 	const char * const value, const char * const reason)
 {
 	struct tm	tm;
 
diff -aprNU5 djgpp.orig/zoneinfo/src/localtime.c djgpp/zoneinfo/src/localtime.c
--- djgpp.orig/zoneinfo/src/localtime.c	2012-12-08 05:33:24 +0000
+++ djgpp/zoneinfo/src/localtime.c	2012-12-08 05:39:06 +0000
@@ -27,10 +27,21 @@
 #ifndef TZ_ABBR_ERR_CHAR
 #define TZ_ABBR_ERR_CHAR	'_'
 #endif /* !defined TZ_ABBR_ERR_CHAR */
 
 /*
+** Portable testing for absolute file names.
+*/
+
+#ifndef IS_SLASH
+#define IS_SLASH(c)     ((c) == '/')
+#endif
+#ifndef IS_ABSOLUTE
+#define IS_ABSOLUTE(n)  (IS_SLASH((n)[0]))
+#endif
+
+/*
 ** SunOS 4.1.1 headers lack O_BINARY.
 */
 
 #ifdef O_BINARY
 #define OPEN_MODE	(O_RDONLY | O_BINARY)
@@ -197,14 +208,17 @@ static struct state	gmtmem;
 
 static char		lcl_TZname[TZ_STRLEN_MAX + 1];
 static int		lcl_is_set;
 static int		gmt_is_set;
 
+#ifndef __DJGPP__
+/*  Use DJGPP's own definition of tzname.  */
 char *			tzname[2] = {
 	wildabbr,
 	wildabbr
 };
+#endif  /* !__DJGPP__ */
 
 /*
 ** Section 4.12.3 of X3.159-1989 requires that
 **	Except for the strftime function, these functions [asctime,
 **	ctime, gmtime, localtime] return values in one of two static
@@ -358,11 +372,11 @@ tzload(register const char *name, regist
 		*/
 		char		fullname[FILENAME_MAX + 1];
 
 		if (name[0] == ':')
 			++name;
-		doaccess = name[0] == '/';
+		doaccess = IS_ABSOLUTE(name);
 		if (!doaccess) {
 			if ((p = TZDIR) == NULL)
 				goto oops;
 			if ((strlen(p) + strlen(name) + 1) >= sizeof fullname)
 				goto oops;
@@ -1300,10 +1314,12 @@ localsub(const time_t *const timep, cons
 	tmp->TM_ZONE = &sp->chars[ttisp->tt_abbrind];
 #endif /* defined TM_ZONE */
 	return result;
 }
 
+#ifndef __DJGPP__
+/*  Use DJGPP's own implementation of localtime and localtime_r.  */
 struct tm *
 localtime(const time_t *const timep)
 {
 	tzset();
 	return localsub(timep, 0L, &tm);
@@ -1316,10 +1332,11 @@ localtime(const time_t *const timep)
 struct tm *
 localtime_r(const time_t *const timep, struct tm *tmp)
 {
 	return localsub(timep, 0L, tmp);
 }
+#endif  /* !__DJGPP__ */
 
 /*
 ** gmtsub is to gmtime as localsub is to localtime.
 */
 
@@ -1357,10 +1374,12 @@ gmtsub(const time_t *const timep, const
 	}
 #endif /* defined TM_ZONE */
 	return result;
 }
 
+#ifndef __DJGPP__
+/*  Use DJGPP's own implementation of gmtime and gmtime_r.  */
 struct tm *
 gmtime(const time_t *const timep)
 {
 	return gmtsub(timep, 0L, &tm);
 }
@@ -1372,10 +1391,11 @@ gmtime(const time_t *const timep)
 struct tm *
 gmtime_r(const time_t *const timep, struct tm *tmp)
 {
 	return gmtsub(timep, 0L, tmp);
 }
+#endif  /* !__DJGPP__ */
 
 #ifdef STD_INSPIRED
 
 struct tm *
 offtime(const time_t *const timep, const long offset)
@@ -1527,10 +1547,12 @@ timesub(const time_t *const timep, const
 	tmp->TM_GMTOFF = offset;
 #endif /* defined TM_GMTOFF */
 	return tmp;
 }
 
+#ifndef __DJGPP__
+/*  Use DJGPP's own implementation of ctime and ctime_r.  */
 char *
 ctime(const time_t *const timep)
 {
 /*
 ** Section 4.12.3.2 of X3.159-1989 requires that
@@ -1546,10 +1568,11 @@ ctime_r(const time_t *const timep, char
 {
 	struct tm	mytm;
 
 	return asctime_r(localtime_r(timep, &mytm), buf);
 }
+#endif  /* !__DJGPP__ */
 
 /*
 ** Adapted from code provided by Robert Elz, who writes:
 **	The "best" way to do mktime I think is based on an idea of Bob
 **	Kridle's (so its said...) from a long time ago.
@@ -1557,11 +1580,11 @@ ctime_r(const time_t *const timep, char
 **	just 32 bits, its a max of 32 iterations (even at 64 bits it
 **	would still be very reasonable).
 */
 
 #ifndef WRONG
-#define WRONG	(-1)
+#define WRONG  ((time_t)-1)
 #endif /* !defined WRONG */
 
 /*
 ** Normalize logic courtesy Paul Eggert.
 */
@@ -1907,16 +1930,19 @@ time1(struct tm *const tmp,
 		}
 	}
 	return WRONG;
 }
 
+#ifndef __DJGPP__
+/*  Use DJGPP's own implementation of mktime.  */
 time_t
 mktime(struct tm *const tmp)
 {
 	tzset();
 	return time1(tmp, localsub, 0L);
 }
+#endif  /* !__DJGPP__ */
 
 #ifdef STD_INSPIRED
 
 time_t
 timelocal(struct tm *const tmp)
diff -aprNU5 djgpp.orig/zoneinfo/src/makefile djgpp/zoneinfo/src/makefile
--- djgpp.orig/zoneinfo/src/makefile	2012-12-08 05:33:24 +0000
+++ djgpp/zoneinfo/src/makefile	2012-12-08 05:39:06 +0000
@@ -40,35 +40,49 @@ POSIXRULES=	America/New_York
 # Also see TZDEFRULESTRING below, which takes effect only
 # if the time zone files cannot be accessed.
 
 # Everything gets put in subdirectories of. . .
 
-TOPDIR=		/usr/local
+TOPDIR=		../..
 
 # "Compiled" time zone information is placed in the "TZDIR" directory
 # (and subdirectories).
 # Use an absolute path name for TZDIR unless you're just testing the software.
 
-TZDIR=		$(TOPDIR)/etc/zoneinfo
+TZDIR=		$(TOPDIR)/zoneinfo
 
 # The "tzselect", "zic", and "zdump" commands get installed in. . .
 
 ETCDIR=		$(TOPDIR)/etc
 
 # If you "make INSTALL", the "date" command gets installed in. . .
 
-BINDIR=		$(TOPDIR)/bin
+BINDIR=		$(TOPDIR)/etc
 
 # Manual pages go in subdirectories of. . .
 
-MANDIR=		$(TOPDIR)/man
+SHAREDIR=	$(TOPDIR)/share
+MANDIR=		$(SHAREDIR)/man
 
 # Library functions are put in an archive in LIBDIR.
 
 LIBDIR=		$(TOPDIR)/lib
 TZLIB=		$(LIBDIR)/libtz.a
 
+# This defines several variables that enable zoneinfo/src/* files to be
+# built both natively and with cross-tools on Unix.
+
+include $(TOPDIR)/src/makefile.def
+export CROSS_BUILD
+
+GCC_MAJOR := $(word 3, $(shell ../../src/misc.exe | $(CROSS_GCC) -E -dD -x c - | egrep 'define\ *__GNUC__'))
+GCC_MINOR := $(word 3, $(shell ../../src/misc.exe | $(CROSS_GCC) -E -dD -x c - | egrep 'define\ *__GNUC_MINOR__'))
+
+# A replacement for (possibly missing) Unix programs:
+
+UTIL=		$(TOPDIR)/src/misc.exe
+
 # If you always want time values interpreted as "seconds since the epoch
 # (not counting leap seconds)", use
 #	REDO=		posix_only
 # below.  If you always want right time values interpreted as "seconds since
 # the epoch" (counting leap seconds)", use
@@ -81,11 +95,11 @@ TZLIB=		$(LIBDIR)/libtz.a
 #	REDO=		right_posix
 # below.
 # POSIX mandates that leap seconds not be counted; for compatibility with it,
 # use either "posix_only" or "posix_right".
 
-REDO=		posix_right
+REDO=		posix_only
 
 # Since "." may not be in PATH...
 
 YEARISTYPE=	./yearistype
 
@@ -119,11 +133,71 @@ LDLIBS=
 #	if you do not want run time warnings about formats that may cause
 #	year 2000 grief
 #  -DZIC_MAX_ABBR_LEN_WO_WARN=3
 #	(or some other number) to set the maximum time zone abbreviation length
 #	that zic will accept without a warning (the default is 6)
-GCC_DEBUG_FLAGS = -Dlint -g3 -O3 -fno-common -fstrict-aliasing \
+#GCC_DEBUG_FLAGS = -Dlint -g3 -O0 -fno-common -fstrict-aliasing \
+#	-Wall -Wextra \
+#	-Wbad-function-cast -Wcast-align -Wcast-qual \
+#	-Wformat=2 -Winit-self \
+#	-Wmissing-declarations -Wmissing-noreturn -Wmissing-prototypes \
+#	-Wnested-externs \
+#	-Wno-format-nonliteral -Wno-sign-compare -Wno-sign-conversion \
+#	-Wno-type-limits \
+#	-Wno-unused-parameter -Woverlength-strings -Wpointer-arith \
+#	-Wshadow -Wstrict-prototypes -Wsuggest-attribute=const \
+#	-Wsuggest-attribute=noreturn -Wsuggest-attribute=pure -Wtrampolines \
+#	-Wwrite-strings
+
+ifeq ($(CROSS_BUILD),0)
+GCC_DEBUG_FLAGS_FOR_ALL = -Dlint -g -fno-common -fstrict-aliasing \
+	-Wall -Wextra \
+	-Wbad-function-cast -Wcast-align -Wcast-qual \
+	-Wformat=2 -Winit-self \
+	-Wmissing-declarations -Wmissing-noreturn -Wmissing-prototypes \
+	-Wnested-externs -Wno-format-nonliteral -Wno-sign-compare \
+	-Wno-unused-parameter  -Wpointer-arith -Wshadow -Wstrict-prototypes \
+	-Wwrite-strings
+
+ifeq ($(GCC_MAJOR),3)
+ifeq ($(GCC_MINOR),4)
+GCC_DEBUG_FLAGS = $(GCC_DEBUG_FLAGS_FOR_ALL) -Wconversion -Wtraditional
+endif
+endif
+
+ifeq ($(GCC_MAJOR),4)
+ ifeq ($(GCC_MINOR),0)
+GCC_DEBUG_FLAGS_SPECIAL = 
+ else
+  ifeq ($(GCC_MINOR),1)
+GCC_DEBUG_FLAGS_SPECIAL = 
+  else
+   ifeq ($(GCC_MINOR),2)
+GCC_DEBUG_FLAGS_SPECIAL = -Woverlength-strings
+   else
+    ifeq ($(GCC_MINOR),3)
+GCC_DEBUG_FLAGS_SPECIAL = -Woverlength-strings -Wno-sign-conversion -Wno-type-limits
+    else
+     ifeq ($(GCC_MINOR),4)
+GCC_DEBUG_FLAGS_SPECIAL = -Woverlength-strings -Wno-sign-conversion -Wno-type-limits
+     else
+      ifeq ($(GCC_MINOR),5)
+GCC_DEBUG_FLAGS_SPECIAL = -Woverlength-strings -Wno-sign-conversion -Wno-type-limits
+      else
+# gcc 4.6 and later works.
+GCC_DEBUG_FLAGS_SPECIAL = -Woverlength-strings -Wno-sign-conversion -Wno-type-limits -Wsuggest-attribute=const -Wsuggest-attribute=noreturn -Wsuggest-attribute=pure -Wtrampolines
+      endif
+     endif
+    endif
+   endif
+  endif
+GCC_DEBUG_FLAGS = $(GCC_DEBUG_FLAGS_FOR_ALL) $(GCC_DEBUG_FLAGS_SPECIAL)
+ endif
+endif
+
+else
+GCC_DEBUG_FLAGS = -Dlint -g -fno-common -fstrict-aliasing \
 	-Wall -Wextra \
 	-Wbad-function-cast -Wcast-align -Wcast-qual \
 	-Wformat=2 -Winit-self \
 	-Wmissing-declarations -Wmissing-noreturn -Wmissing-prototypes \
 	-Wnested-externs \
@@ -131,10 +205,12 @@ GCC_DEBUG_FLAGS = -Dlint -g3 -O3 -fno-co
 	-Wno-type-limits \
 	-Wno-unused-parameter -Woverlength-strings -Wpointer-arith \
 	-Wshadow -Wstrict-prototypes -Wsuggest-attribute=const \
 	-Wsuggest-attribute=noreturn -Wsuggest-attribute=pure -Wtrampolines \
 	-Wwrite-strings
+endif
+
 #
 # If you want to use System V compatibility code, add
 #	-DUSG_COMPAT
 # to the end of the "CFLAGS=" line.  This arrange for "timezone" and "daylight"
 # variables to be kept up-to-date by the time conversion functions.  Neither
@@ -223,22 +299,30 @@ GCC_DEBUG_FLAGS = -Dlint -g3 -O3 -fno-co
 # to the end of the "CFLAGS=" line.  This causes "strftime" to always return
 # 53 as a week number (rather than 52 or 53) for those days in January that
 # before the first Monday in January when a "%V" format is used and January 1
 # falls on a Friday, Saturday, or Sunday.
 
-CFLAGS=
+CFLAGS=		-DHAVE_ADJTIME=0 -DHAVE_LONG_DOUBLE=1 -DHAVE_SETTIMEOFDAY=1 \
+		-DHAVE_STRERROR=1 -DHAVE_SYMLINK=0 \
+		-DSTD_INSPIRED \
+		-DLOCALE_HOME=\"/dev/env/DJDIR~c:/djgpp~/share/locale\" \
+		$(GCC_DEBUG_FLAGS) -O2
+
+# Don't use -s here, since "gcc -s" on DJ's Irix machine dumps core
+# when invoked with -s.  To work around, we use strip explicitly.
+LFLAGS=
 
 # Linker flags.  Default to $(LFLAGS) for backwards compatibility
 # to tzcode2012h and earlier.
 
 LDFLAGS=	$(LFLAGS)
-
-zic=		./zic
+EXEEXT=		.exe
+zic=		./host-zic
 ZIC=		$(zic) $(ZFLAGS)
 
 # The name of a Posix-compliant `awk' on your system.
-AWK=		awk
+AWK=		gawk
 
 # The full path name of a Posix-compliant shell that supports the Korn shell's
 # 'select' statement, as an extension.  These days, Bash is the most popular.
 KSHELL=		/bin/bash
 
@@ -272,24 +356,24 @@ TARFLAGS=	`if tar $(GNUTARFLAGS) --versi
 # Flags to give 'gzip' when making a distribution.
 GZIPFLAGS=	-9n
 
 ###############################################################################
 
-cc=		cc
-CC=		$(cc) -DTZDIR=\"$(TZDIR)\"
+cc=		$(CROSS_GCC)
+CC=		$(cc) -DTZDIR=\"/dev/env/DJDIR~c:/djgpp~/zoneinfo\"
 
 TZCSRCS=	zic.c localtime.c asctime.c scheck.c ialloc.c
 TZCOBJS=	zic.o localtime.o asctime.o scheck.o ialloc.o
 TZDSRCS=	zdump.c localtime.c ialloc.c
 TZDOBJS=	zdump.o localtime.o ialloc.o
-DATESRCS=	date.c localtime.c strftime.c asctime.c
-DATEOBJS=	date.o localtime.o strftime.o asctime.o
+DATESRCS=	date.c localtime.c logwtmp.c strftime.c asctime.c
+DATEOBJS=	date.o localtime.o logwtmp.o strftime.o asctime.o
 LIBSRCS=	localtime.c asctime.c difftime.c
 LIBOBJS=	localtime.o asctime.o difftime.o
 HEADERS=	tzfile.h private.h
 NONLIBSRCS=	zic.c zdump.c scheck.c ialloc.c
-NEWUCBSRCS=	date.c strftime.c
+NEWUCBSRCS=	date.c logwtmp.c strftime.c
 SOURCES=	$(HEADERS) $(LIBSRCS) $(NONLIBSRCS) $(NEWUCBSRCS) tzselect.ksh
 MANS=		newctime.3 newstrftime.3 newtzset.3 time2posix.3 \
 			tzfile.5 tzselect.8 zic.8 zdump.8
 COMMON=		Makefile
 DOCS=		README Theory $(MANS) date.1
@@ -300,68 +384,88 @@ NDATA=		systemv factory
 SDATA=		solar87 solar88 solar89
 TDATA=		$(YDATA) $(NDATA) $(SDATA)
 TABDATA=	iso3166.tab zone.tab
 DATA=		$(YDATA) $(NDATA) $(SDATA) $(TABDATA) leapseconds yearistype.sh
 WEB_PAGES=	tz-art.htm tz-link.htm
-MISC=		usno1988 usno1989 usno1989a usno1995 usno1997 usno1998 \
+MISC=		usno1988 usno1989 usno1989.orig usno1995 usno1997 usno1998 \
 			$(WEB_PAGES) checktab.awk workman.sh \
 			zoneinfo2tdf.pl
 ENCHILADA=	$(COMMON) $(DOCS) $(SOURCES) $(DATA) $(MISC)
 
 # And for the benefit of csh users on systems that assume the user
 # shell should be used to handle commands in Makefiles. . .
 
 SHELL=		/bin/sh
 
-all:		tzselect zic zdump $(LIBOBJS)
-
-ALL:		all date
+INSTALL:	ALL install date.1
+		-$(UTIL) mkdir $(TOPDIR)
+		-$(UTIL) mkdir $(BINDIR)
+		$(UTIL) cp date$(EXEEXT) $(BINDIR)/date$(EXEEXT)
+		-$(UTIL) mkdir $(SHAREDIR)
+		-$(UTIL) mkdir $(MANDIR)
+		-$(UTIL) mkdir $(MANDIR)/man1
+		-$(UTIL) rm $(MANDIR)/man1/date.1
+		$(UTIL) cp date.1 $(MANDIR)/man1/date.1
 
 install:	all $(DATA) $(REDO) $(TZLIB) $(MANS) $(TABDATA)
 		$(ZIC) -y $(YEARISTYPE) \
 			-d $(TZDIR) -l $(LOCALTIME) -p $(POSIXRULES)
-		-rm -f $(TZDIR)/iso3166.tab $(TZDIR)/zone.tab
-		cp iso3166.tab zone.tab $(TZDIR)/.
-		-mkdir $(TOPDIR) $(ETCDIR)
-		cp tzselect zic zdump $(ETCDIR)/.
-		-mkdir $(TOPDIR) $(MANDIR) \
-			$(MANDIR)/man3 $(MANDIR)/man5 $(MANDIR)/man8
-		-rm -f $(MANDIR)/man3/newctime.3 \
+		-$(UTIL) rm -f $(TZDIR)/iso3166.tab $(TZDIR)/zone.tab
+		$(UTIL) cp iso3166.tab $(TZDIR)/iso3166.tab
+		$(UTIL) cp zone.tab $(TZDIR)/zone.tab
+		-$(UTIL) mkdir $(TOPDIR)
+		-$(UTIL) mkdir $(ETCDIR)
+		$(UTIL) cp zic$(EXEEXT) $(ETCDIR)/zic$(EXEEXT)
+		$(UTIL) cp zdump$(EXEEXT) $(ETCDIR)/zdump$(EXEEXT)
+		$(UTIL) cp tzselect $(ETCDIR)/tzselect
+		-$(UTIL) mkdir $(SHAREDIR)
+		-$(UTIL) mkdir $(MANDIR)
+		-$(UTIL) mkdir $(MANDIR)/man3
+		-$(UTIL) mkdir $(MANDIR)/man5
+		-$(UTIL) mkdir $(MANDIR)/man8
+		-$(UTIL) rm -f $(MANDIR)/man3/newctime.3 \
 			$(MANDIR)/man3/newtzset.3 \
 			$(MANDIR)/man5/tzfile.5 \
 			$(MANDIR)/man8/tzselect.8 \
 			$(MANDIR)/man8/zdump.8 \
 			$(MANDIR)/man8/zic.8
-		cp newctime.3 newtzset.3 $(MANDIR)/man3/.
-		cp tzfile.5 $(MANDIR)/man5/.
-		cp tzselect.8 zdump.8 zic.8 $(MANDIR)/man8/.
+		$(UTIL) cp newctime.3 $(MANDIR)/man3/newctime.3
+		$(UTIL) cp newtzset.3 $(MANDIR)/man3/newtzset.3
+		$(UTIL) cp time2posix.3 $(MANDIR)/man3/time2posix.3
+		$(UTIL) cp tzfile.5 $(MANDIR)/man5/tzfile.5
+		$(UTIL) cp tzselect.8 $(MANDIR)/man8/tzselect.8
+		$(UTIL) cp zdump.8 $(MANDIR)/man8/zdump.8
+		$(UTIL) cp zic.8 $(MANDIR)/man8/zic.8
 
-INSTALL:	ALL install date.1
-		-mkdir $(TOPDIR) $(BINDIR)
-		cp date $(BINDIR)/.
-		-mkdir $(TOPDIR) $(MANDIR) $(MANDIR)/man1
-		-rm -f $(MANDIR)/man1/date.1
-		cp date.1 $(MANDIR)/man1/.
+all:		host-zic zic$(EXEEXT) zdump$(EXEEXT) $(LIBOBJS)
+
+ALL:		all date$(EXEEXT) tzselect
 
 version.h:
 		(echo 'static char const PKGVERSION[]="($(PACKAGE)) ";' && \
 		 echo 'static char const TZVERSION[]="$(VERSION)";') >$@
 
-zdump:		$(TZDOBJS)
+zdump$(EXEEXT):	$(TZDOBJS)
 		$(CC) -o $@ $(CFLAGS) $(LDFLAGS) $(TZDOBJS) $(LDLIBS)
+		$(CROSS_STRIP) $@
 
-zic:		$(TZCOBJS) yearistype
+host-zic:	$(TZCSRCS) yearistype version.h
+		$(GCC) -DTZDIR=\"/dev/env/DJDIR~c:/djgpp~/zoneinfo\" \
+		$(CFLAGS) $(LDFLAGS) $(TZCSRCS) $(LDLIBS) -o $@
+		$(STRIP) $@
+
+zic$(EXEEXT):	$(TZCOBJS) yearistype
 		$(CC) -o $@ $(CFLAGS) $(LDFLAGS) $(TZCOBJS) $(LDLIBS)
+		$(CROSS_STRIP) $@
 
 yearistype:	yearistype.sh
-		cp yearistype.sh yearistype
-		chmod +x yearistype
+		$(UTIL) cp yearistype.sh yearistype
 
-posix_only:	zic $(TDATA)
+posix_only:	$(zic) $(TDATA)
 		$(ZIC) -y $(YEARISTYPE) -d $(TZDIR) -L /dev/null $(TDATA)
 
-right_only:	zic leapseconds $(TDATA)
+right_only:	$(zic) leapseconds $(TDATA)
 		$(ZIC) -y $(YEARISTYPE) -d $(TZDIR) -L leapseconds $(TDATA)
 
 # In earlier versions of this makefile, the other two directories were
 # subdirectories of $(TZDIR).  However, this led to configuration errors.
 # For example, with posix_right under the earlier scheme,
@@ -369,11 +473,11 @@ right_only:	zic leapseconds $(TDATA)
 # but gmtime without leap seconds, which led to problems with applications
 # like sendmail that subtract gmtime from localtime.
 # Therefore, the other two directories are now siblings of $(TZDIR).
 # You must replace all of $(TZDIR) to switch from not using leap seconds
 # to using them, or vice versa.
-other_two:	zic leapseconds $(TDATA)
+other_two:	$(zic) leapseconds $(TDATA)
 		$(ZIC) -y $(YEARISTYPE) -d $(TZDIR)-posix -L /dev/null $(TDATA)
 		$(ZIC) -y $(YEARISTYPE) \
 			-d $(TZDIR)-leaps -L leapseconds $(TDATA)
 
 posix_right:	posix_only other_two
@@ -381,48 +485,52 @@ posix_right:	posix_only other_two
 right_posix:	right_only other_two
 
 zones:		$(REDO)
 
 $(TZLIB):	$(LIBOBJS)
-		-mkdir $(TOPDIR) $(LIBDIR)
-		ar ru $@ $(LIBOBJS)
-		if [ -x /usr/ucb/ranlib ] || [ -x /usr/bin/ranlib ]; \
-			then ranlib $@ ; fi
-
-date:		$(DATEOBJS)
-		$(CC) -o $@ $(CFLAGS) $(LDFLAGS) $(DATEOBJS) $(LDLIBS)
+		-$(UTIL) mkdir $(TOPDIR)
+		-$(UTIL) mkdir $(LIBDIR)
+		$(CROSS_AR) rus $@ $(LIBOBJS)
+
+# We use the system's logwtmp in preference to ours if available.
+
+date$(EXEEXT):	$(DATEOBJS)
+		$(CROSS_AR) rs logwtmpl.a logwtmp.o
+		$(CC) $(CFLAGS) date.o localtime.o asctime.o strftime.o \
+			$(LDLIBS) -lc logwtmpl.a -o $@
+		$(CROSS_STRIP) $@
+		$(UTIL) rm logwtmpl.a
+		$(CROSS_STRIP) $@
 
 tzselect:	tzselect.ksh
 		sed \
-			-e 's|#!/bin/bash|#!$(KSHELL)|g' \
 			-e 's|AWK=[^}]*|AWK=$(AWK)|g' \
 			-e 's|\(PKGVERSION\)=.*|\1='\''($(PACKAGE)) '\''|' \
-			-e 's|TZDIR=[^}]*|TZDIR=$(TZDIR)|' \
+			-e 's|TZDIR=[^}]*|TZDIR=/dev/env/DJDIR/zoneinfo|' \
 			-e 's|\(TZVERSION\)=.*|\1=$(VERSION)|' \
 			<$? >$@
-		chmod +x $@
 
 check:		check_tables check_web
 
 check_tables:	checktab.awk $(PRIMARY_YDATA)
 		$(AWK) -f checktab.awk $(PRIMARY_YDATA)
 
 check_web:	$(WEB_PAGES)
 		$(VALIDATE_ENV) $(VALIDATE) $(VALIDATE_FLAGS) $(WEB_PAGES)
 
 clean:
-		rm -f core *.o *.out \
-		  date tzselect version.h zdump zic yearistype
-		rm -f -r tzpublic
+		$(UTIL) rm core *.o *.out tzselect zdump$(EXEEXT) zic$(EXEEXT) \
+			yearistype date$(EXEEXT) logwtmpl* *.tar.gz host-zic *.exe
+		$(UTIL) rm -f -r tzpublic
 
 maintainer-clean: clean
 		@echo 'This command is intended for maintainers to use; it'
 		@echo 'deletes files that may need special tools to rebuild.'
 		rm -f *.[1-8].txt *.asc *.tar.gz
 
 names:
-		@echo $(ENCHILADA)
+		@$(UTIL) echo $(ENCHILADA)
 
 public:		check check_public set-timestamps tarballs signatures
 
 # Set the time stamps to those of the git repository, if available,
 # and if the files have not changed since then.
diff -aprNU5 djgpp.orig/zoneinfo/src/private.h djgpp/zoneinfo/src/private.h
--- djgpp.orig/zoneinfo/src/private.h	2012-12-08 05:33:24 +0000
+++ djgpp/zoneinfo/src/private.h	2012-12-08 05:39:06 +0000
@@ -143,13 +143,15 @@ typedef long		int_fast64_t;
 #ifndef INT32_MIN
 #define INT32_MIN (-1 - INT32_MAX)
 #endif /* !defined INT32_MIN */
 
 #if 2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)
-# define ATTRIBUTE_PURE __attribute__ ((__pure__))
+# define ATTRIBUTE_PURE      __attribute__ ((__pure__))
+# define ATTRIBUTE_NORETURN  __attribute__ ((__noreturn__))
 #else
-# define ATTRIBUTE_PURE /* empty */
+# define ATTRIBUTE_PURE      /* empty */
+# define ATTRIBUTE_NORETURN  /* empty */
 #endif
 
 /*
 ** Workarounds for compilers/systems.
 */
@@ -171,10 +173,30 @@ extern char *	asctime_r(struct tm const
 char *		icatalloc(char * old, const char * new);
 char *		icpyalloc(const char * string);
 const char *	scheck(const char * string, const char * format);
 
 /*
+** Declarations for functions which shut up GCC $(GCC_DEBUG_FLAGS).
+*/
+#ifndef STD_INSPIRED
+static
+#endif /* !defined STD_INSPIRED */
+void tzsetwall(void);
+struct tm *localtime_r(const time_t * const __timep, struct tm * __tmp);
+struct tm *gmtime_r(const time_t * const __tp, struct tm * __tm);
+char *ctime_r(const time_t * const __tp, char * __buf);
+char *asctime_r(const struct tm *, char *);
+#ifdef STD_INSPIRED
+struct tm *offtime(const time_t * const __tp, const long __off);
+time_t timelocal(struct tm * const __tmp);
+time_t timegm(struct tm * const __tmp);
+time_t timeoff(struct tm * const __tmp, const long __off);
+time_t time2posix(time_t);
+time_t posix2time(time_t);
+#endif /* defined STD_INSPIRED */
+
+/*
 ** Finally, some convenience items.
 */
 
 #ifndef TRUE
 #define TRUE	1
@@ -235,10 +257,20 @@ const char *	scheck(const char * string,
 #ifndef GNUC_or_lint
 #define INITIALIZE(x)
 #endif /* !defined GNUC_or_lint */
 #endif /* !defined INITIALIZE */
 
+#ifdef __MSDOS__
+#define IS_SLASH(c)     ((c) == '/' || (c) == '\\')
+#define HAS_DEVICE(n)   ((n)[0] && (n)[1] == ':')
+#define IS_ABSOLUTE(n)  (IS_SLASH((n)[0]) || HAS_DEVICE(n))
+#undef  TZDIR
+#define TZDIR           (getenv("TZDIR") ? getenv("TZDIR") : "/dev/env/DJDIR/zoneinfo")
+#else /* !__MSDOS__ */
+#define HAS_DEVICE(n) 0
+#endif /* !__MSDOS__ */
+
 /*
 ** For the benefit of GNU folk...
 ** `_(MSGID)' uses the current locale's message library string for MSGID.
 ** The default is to use gettext if available, and use MSGID otherwise.
 */
diff -aprNU5 djgpp.orig/zoneinfo/src/strftime.c djgpp/zoneinfo/src/strftime.c
--- djgpp.orig/zoneinfo/src/strftime.c	2012-12-08 05:33:26 +0000
+++ djgpp/zoneinfo/src/strftime.c	2012-12-08 05:39:06 +0000
@@ -1,5 +1,9 @@
+#ifndef __DJGPP__
+/*  Use DJGPP's own implementation of strftime.  */
+
+
 #include "private.h"
 
 /*
 ** Copyright (c) 1989 The Regents of the University of California.
 ** All rights reserved.
@@ -729,5 +733,6 @@ no_locale:
 	localebuf = C_time_locale;
 	locale_buf = NULL;
 	return &localebuf;
 }
 #endif /* defined LOCALE_HOME */
+#endif /* !__DJGPP__ */
diff -aprNU5 djgpp.orig/zoneinfo/src/zdump.c djgpp/zoneinfo/src/zdump.c
--- djgpp.orig/zoneinfo/src/zdump.c	2012-12-08 05:33:26 +0000
+++ djgpp/zoneinfo/src/zdump.c	2012-12-08 05:39:06 +0000
@@ -119,13 +119,15 @@
 #define INITIALIZE(x)
 #endif /* !defined GNUC_or_lint */
 #endif /* !defined INITIALIZE */
 
 #if 2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)
-# define ATTRIBUTE_PURE __attribute__ ((__pure__))
+# define ATTRIBUTE_PURE      __attribute__ ((__pure__))
+# define ATTRIBUTE_NORETURN  __attribute__ ((__noreturn__))
 #else
-# define ATTRIBUTE_PURE /* empty */
+# define ATTRIBUTE_PURE      /* empty */
+# define ATTRIBUTE_NORETURN  /* empty */
 #endif
 
 /*
 ** For the benefit of GNU folk...
 ** `_(MSGID)' uses the current locale's message library string for MSGID.
@@ -264,11 +266,11 @@ abbrok(const char *const abbrp, const ch
 		_("%s: warning: zone \"%s\" abbreviation \"%s\" %s\n"),
 		progname, zone, abbrp, wp);
 	warned = TRUE;
 }
 
-static void
+static ATTRIBUTE_NORETURN void
 usage(FILE * const stream, const int status)
 {
 	(void) fprintf(stream,
 _("%s: usage is %s [ --version ] [ --help ] [ -v ] [ -c [loyear,]hiyear ] zonename ...\n\
 \n\
@@ -563,11 +565,11 @@ show(char *zone, time_t t, int v)
 		if (*abbr(tmp) != '\0')
 			(void) printf(" %s", abbr(tmp));
 		if (v) {
 			(void) printf(" isdst=%d", tmp->tm_isdst);
 #ifdef TM_GMTOFF
-			(void) printf(" gmtoff=%ld", tmp->TM_GMTOFF);
+			(void) printf(" gmtoff=%ld", (long)tmp->TM_GMTOFF);
 #endif /* defined TM_GMTOFF */
 		}
 	}
 	(void) printf("\n");
 	if (tmp != NULL && *abbr(tmp) != '\0')
diff -aprNU5 djgpp.orig/zoneinfo/src/zic.c djgpp/zoneinfo/src/zic.c
--- djgpp.orig/zoneinfo/src/zic.c	2012-12-08 05:33:26 +0000
+++ djgpp/zoneinfo/src/zic.c	2012-12-08 05:39:06 +0000
@@ -17,17 +17,34 @@ typedef int_fast64_t	zic_t;
 #endif /* !defined ZIC_MAX_ABBR_LEN_WO_WARN */
 
 #if HAVE_SYS_STAT_H
 #include "sys/stat.h"
 #endif
+#if HAVE_SYS_WAIT_H
+#include "sys/wait.h"
+#ifndef WEXITSTATUS
+#define WEXITSTATUS(x)  (((x) >> 8) & 0xff)
+#endif
+#endif
 #ifdef S_IRUSR
 #define MKDIR_UMASK (S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)
 #else
 #define MKDIR_UMASK 0755
 #endif
 
 /*
+** Portable testing for absolute file names.
+*/
+
+#ifndef IS_SLASH
+#define IS_SLASH(c)     ((c) == '/')
+#endif
+#ifndef IS_ABSOLUTE
+#define IS_ABSOLUTE(n)  (IS_SLASH((n)[0]))
+#endif
+
+/*
 ** On some ancient hosts, predicates like `isspace(C)' are defined
 ** only if isascii(C) || C == EOF. Modern hosts obey the C Standard,
 ** which says they are defined only if C == ((unsigned char) C) || C == EOF.
 ** Neither the C Standard nor Posix require that `isascii' exist.
 ** For portability, we check both ancient and modern requirements.
@@ -417,11 +434,11 @@ warning(const char *const string)
 	error(cp);
 	free(cp);
 	--errors;
 }
 
-static void
+static ATTRIBUTE_NORETURN void
 usage(FILE *stream, int status)
 {
 	(void) fprintf(stream, _("%s: usage is %s \
 [ --version ] [ --help ] [ -v ] [ -l localtime ] [ -p posixrules ] \\\n\
 \t[ -d directory ] [ -L leapseconds ] [ -y yearistype ] [ filename ... ]\n\
@@ -580,24 +597,38 @@ static void
 dolink(const char *const fromfield, const char *const tofield)
 {
 	register char *	fromname;
 	register char *	toname;
 
-	if (fromfield[0] == '/')
+	if (IS_ABSOLUTE(fromfield))
 		fromname = ecpyalloc(fromfield);
 	else {
 		fromname = ecpyalloc(directory);
 		fromname = ecatalloc(fromname, "/");
 		fromname = ecatalloc(fromname, fromfield);
 	}
-	if (tofield[0] == '/')
+	if (IS_ABSOLUTE(tofield))
 		toname = ecpyalloc(tofield);
 	else {
 		toname = ecpyalloc(directory);
 		toname = ecatalloc(toname, "/");
 		toname = ecatalloc(toname, tofield);
 	}
+	/* Some zone names use `+' as part of their names, but DOS
+	   doesn't allow `+' in file names.  Replace with a `%'.  */
+	if (getenv ("COMSPEC") || getenv ("CROSS_BUILD"))
+	{
+		char *p;
+
+		for (p = fromname; *p; p++)
+			if (*p == '+')
+				*p = '%';
+		for (p = toname; *p; p++)
+			if (*p == '+')
+				*p = '%';
+	}
+
 	/*
 	** We get to be careful here since
 	** there's a fair chance of root running us.
 	*/
 	if (!itsdir(toname))
@@ -649,17 +680,24 @@ static const zic_t min_time = (zic_t) -1
 static const zic_t max_time = -1 - ((zic_t) -1 << (TIME_T_BITS_IN_FILE - 1));
 
 static int
 itsdir(const char *const name)
 {
-	register char *	myname;
 	register int	accres;
 
+#ifdef D_OK
+	/* MS-DOS/MS-Windows normalize "foo/." to "foo" before testing,
+	   so we think foo is a directory.  Use D_OK instead.  */
+	accres = access(name, D_OK);
+#else
+	register char *	myname;
+
 	myname = ecpyalloc(name);
 	myname = ecatalloc(myname, "/.");
 	accres = access(myname, F_OK);
 	free(myname);
+#endif
 	return accres == 0;
 }
 
 /*
 ** Associate sets of rules with zones.
@@ -1469,11 +1507,26 @@ writezone(const char *const name, const
 		--leapcnt32;
 		++leapi32;
 	}
 	fullname = erealloc(fullname,
 			    strlen(directory) + 1 + strlen(name) + 1);
-	(void) sprintf(fullname, "%s/%s", directory, name);
+
+	/* Some zone names use `+' as part of their names, but DOS
+	   doesn't allow `+' in file names.  Replace with a `%'.  */
+	if (getenv ("COMSPEC") || getenv ("CROSS_BUILD"))
+	{
+		char new_name[FILENAME_MAX + 1], *p;
+
+		strcpy(new_name, name);
+		for (p = new_name; *p; p++)
+			if (*p == '+')
+				*p = '%';
+		(void) sprintf(fullname, "%s/%s", directory, new_name);
+	}
+	else
+		(void) sprintf(fullname, "%s/%s", directory, name);
+
 	/*
 	** Remove old file, if any, to snap links.
 	*/
 	if (!itsdir(fullname) && remove(fullname) != 0 && errno != ENOENT) {
 		const char *e = strerror(errno);
@@ -2573,42 +2626,40 @@ mkdirs(char *argname)
 	register char *	cp;
 
 	if (argname == NULL || *argname == '\0')
 		return 0;
 	cp = name = ecpyalloc(argname);
-	while ((cp = strchr(cp + 1, '/')) != 0) {
-		*cp = '\0';
-#ifndef unix
-		/*
-		** DOS drive specifier?
-		*/
-		if (isalpha((unsigned char) name[0]) &&
-			name[1] == ':' && name[2] == '\0') {
-				*cp = '/';
-				continue;
-		}
-#endif /* !defined unix */
-		if (!itsdir(name)) {
-			/*
-			** It doesn't seem to exist, so we try to create it.
-			** Creation may fail because of the directory being
-			** created by some other multiprocessor, so we get
-			** to do extra checking.
-			*/
-			if (mkdir(name, MKDIR_UMASK) != 0) {
-				const char *e = strerror(errno);
-
-				if (errno != EEXIST || !itsdir(name)) {
-					(void) fprintf(stderr,
-_("%s: Can't create directory %s: %s\n"),
-						progname, name, e);
-					free(name);
-					return -1;
-				}
-			}
-		}
-		*cp = '/';
+	/*
+	** Get past a DOS-style drive specifier, if any.
+	*/
+	if (HAS_DEVICE(name))
+		cp += 2;
+	while (*cp++) {
+		if (IS_SLASH(*cp)) {
+			*cp = '\0';
+			if (!itsdir(name)) {
+				/*
+				** It doesn't seem to exist, so we try to
+				** create it.  Creation may fail because
+				** of the directory being created by some
+				** other multiprocessor, so we get to do
+				** extra checking.
+				*/
+				if (mkdir(name, MKDIR_UMASK) != 0) {
+					const char *e = strerror(errno);
+  
+					if (errno != EEXIST || !itsdir(name)) {
+						(void) fprintf(stderr,
+  _("%s: Can't create directory %s: %s\n"),
+						       progname, name, e);
+						free(name);
+						return -1;
+					}
+  				}
+  			}
+			*cp = '/';
+  		}
 	}
 	free(name);
 	return 0;
 }
 
diff -aprNU5 djgpp.orig/zoneinfo/src/date.c djgpp/zoneinfo/src/date.c
--- djgpp.orig/zoneinfo/src/date.c	2013-01-31 22:37:10 +0000
+++ djgpp/zoneinfo/src/date.c	2013-02-16 02:55:10 +0000
@@ -54,18 +54,18 @@ static char sccsid[] = "@(#)date.c	4.23
 
 #ifndef SECSPERMIN
 #define SECSPERMIN	60
 #endif /* !defined SECSPERMIN */
 
-extern double		atof();
+extern double		atof(const char *s);
 extern char **		environ;
-extern char *		getlogin();
-extern time_t		mktime();
+extern char *		getlogin(void);
+extern time_t		mktime(struct tm *tptr);
 extern char *		optarg;
 extern int		optind;
-extern char *		strchr();
-extern time_t		time();
+extern char *		strchr(const char *s, int c);
+extern time_t		time(time_t *t);
 extern char *		tzname[2];
 
 static int		retval = EXIT_SUCCESS;
 
 static void		checkfinal(const char *, int, time_t, time_t);
@@ -445,11 +445,11 @@ reset(const time_t newt, const int nflag
 #include "netdb.h"
 #define TSPTYPES
 #include "protocols/timed.h"
 #endif /* TSP_SETDATE */
 
-extern int		logwtmp();
+extern int		logwtmp(char *line, char *name, char *host);
 
 #if HAVE_SETTIMEOFDAY == 1
 #define settimeofday(t, tz) (settimeofday)(t)
 #endif /* HAVE_SETTIMEOFDAY == 1 */
 
@@ -561,11 +561,11 @@ display(const char *const format)
 		errensure();
 	}
 	exit(retval);
 }
 
-extern size_t	strftime();
+extern size_t	strftime(char *s, size_t maxsize, const char *format, const struct tm *t);
 
 #define INCR	1024
 
 static void
 timeout(FILE *const fp, const char *const format, const struct tm *const tmp)
